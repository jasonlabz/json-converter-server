<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>JSON ‚Üí Â§öËØ≠Ë®ÄÁªìÊûÑ‰ΩìÁîüÊàêÂô®</title>
    <link rel="stylesheet" href="./libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* CSSÊ†∑ÂºèÔºàÂåÖÂê´‰øÆÂ§çÔºâ */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 12px;
            gap: 12px;
        }

        .header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 4px;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .header .subtitle {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 2px;
        }

        .config-panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 10px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .config-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-row {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .code-gen-config {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .compact-group {
            margin-bottom: 0;
        }

        .compact-group label {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .language-select {
            position: relative;
        }

        .language-select select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 8px 12px;
            padding-right: 32px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            min-width: 120px;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
        }

        .compact-select {
            padding: 6px 10px;
            min-width: 100px;
            font-size: 12px;
        }

        .language-select select:hover {
            border-color: #60a5fa;
            background: #1e293b;
        }

        .language-select select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .language-select::after {
            content: "‚ñº";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 10px;
            pointer-events: none;
        }

        .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .compact-options {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .compact-item {
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 12px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-item label {
            font-size: 11px;
            min-width: 32px;
        }

        .go-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-width: 300px;
        }

        .compact-tags {
            gap: 6px;
            max-width: 280px;
        }

        .tag-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .compact-tag {
            gap: 3px;
        }

        .tag-checkbox input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .compact-tag input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        .tag-checkbox input[type="checkbox"]:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .tag-checkbox input[type="checkbox"]:checked::after {
            content: "‚úì";
            position: absolute;
            color: white;
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .tag-checkbox label {
            font-size: 11px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-tag label {
            font-size: 10px;
            padding: 1px 3px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 0;
        }

        .compact-actions {
            gap: 6px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }

        /* ÂÜÖËÅîÂºÄÂÖ≥Ê†∑Âºè */
        .mode-switch-inline {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-switch-inline .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 18px;
            margin: 0;
        }

        .mode-switch-inline .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-switch-inline .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 18px;
        }

        .mode-switch-inline .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .mode-switch-inline input:checked + .slider {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
        }

        .mode-switch-inline input:checked + .slider:before {
            transform: translateX(18px);
        }

        .mode-switch-inline .switch-label {
            font-size: 12px;
            color: #cbd5e1;
            user-select: none;
            white-space: nowrap;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 90px;
            justify-content: center;
        }

        .btn-compact {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 80px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(90deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .editor-panels {
            display: flex;
            flex: 1;
            gap: 12px;
            min-height: 0;
            height: calc(100vh - 240px);
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            height: 100%;
            transition: all 0.3s ease;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            min-height: 40px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .panel-title i {
            color: #60a5fa;
            font-size: 14px;
        }

        .panel-stats {
            font-size: 11px;
            color: #94a3b8;
        }

        .panel-content {
            flex: 1;
            position: relative;
            min-height: 300px;
            overflow: hidden;
        }

        .json-panel {
            flex: 1;
        }

        .code-panel {
            flex: 1;
            opacity: 1;
            transform: translateX(0);
        }

        /* ‰øÆÂ§çÔºö‰ΩøÁî®CSSÁ±ªÊéßÂà∂ÈöêËóè */
        .code-panel.hidden {
            display: none !important;
            flex: 0;
            width: 0;
            min-width: 0;
        }

        .json-panel.full-width {
            flex: 1;
            width: 100%;
        }

        .json-panel.partial-width {
            flex: 1;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 12px;
            color: #94a3b8;
            min-height: 36px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .language-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .info-icon {
            color: #60a5fa;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            .config-row {
                gap: 12px;
            }

            .compact-group {
                min-width: 100px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 8px;
                gap: 8px;
            }

            .header h1 {
                font-size: 18px;
            }

            .editor-panels {
                flex-direction: column;
                height: auto;
            }

            .panel {
                min-height: 300px;
            }

            .config-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .mode-switch-inline {
                order: -1;
                width: 100%;
                justify-content: center;
                margin-right: 0;
                margin-bottom: 8px;
            }

            .compact-actions {
                justify-content: center;
            }

            .compact-group {
                width: 100%;
            }

            .compact-input {
                width: 100%;
            }

            .compact-select {
                width: 100%;
            }

            .compact-actions {
                flex-wrap: wrap;
                justify-content: center;
            }

            .btn-compact {
                flex: 1;
                min-width: 60px;
                padding: 5px 8px;
                font-size: 11px;
            }

            .code-gen-config {
                padding-top: 8px;
                margin-top: 8px;
            }
        }

        .error-message {
            color: #f87171;
            font-size: 12px;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .time-type-hint {
            font-size: 10px;
            color: #86efac;
            margin-top: 2px;
            display: inline-block;
        }

        /* JSONÂ∑•ÂÖ∑ÊåâÈíÆÁªÑ */
        .json-tools {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .format-select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-select:hover {
            border-color: #60a5fa;
        }

        .format-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .case-format-select {
            min-width: 100px;
        }

        /* Ê≥®ÈáäÊ†∑Âºè */
        .comment-indicator {
            position: absolute;
            right: 8px;
            top: 8px;
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .generation-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
        }

        .generation-info-compact {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 6px;
        }

        .generation-info-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .generation-info-stat {
            font-size: 11px;
        }

        .generation-info-stat .label {
            color: #94a3b8;
        }

        .generation-info-stat .value {
            color: #60a5fa;
            font-weight: 500;
            margin-left: 2px;
        }

        .generation-info-stat .value.warning {
            color: #fbbf24;
        }

        .warning-message {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #fbbf24;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ËæìÂÖ•Ê°ÜÊ†∑Âºè */
        .compact-input {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 6px 8px;
            border-radius: 5px;
            font-size: 12px;
            width: 100px;
            outline: none;
            transition: all 0.2s;
        }

        .compact-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* ÊäòÂè†Âå∫ÂüüÊ†∑Âºè */
        .fold-widget {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* Á°Æ‰øùÁºñËæëÂô®ÊúâË∂≥Â§üÈ´òÂ∫¶ */
        .monaco-editor {
            height: 100% !important;
        }
    </style>
</head>
<body>

<div id="root"></div>

<!-- React & ReactDOM -->
<script src="./libs/react/react.development.js"></script>
<script src="./libs/react-dom/react-dom.development.js"></script>

<!-- Monaco Editor -->
<script src="./libs/monaco-editor/min/vs/loader.js"></script>

<script>
    // ÈÖçÁΩÆMonaco EditorË∑ØÂæÑ
    require.config({
        paths: {
            vs: "./libs/monaco-editor/min/vs"
        }
    });

    // Á≠âÂæÖMonacoÂä†ËΩΩÂÆåÊàêÂêéÊâßË°å
    require(["vs/editor/editor.main"], function () {
        const { useState, useEffect, useRef, useCallback } = React;

        // ËØ≠Ë®ÄÈÖçÁΩÆ
        const LANGUAGE_CONFIG = {
            go: {
                name: "Golang",
                icon: "üîµ",
                fileExt: "go",
                monacoLang: "go"
            },
            java: {
                name: "Java",
                icon: "‚òï",
                fileExt: "java",
                monacoLang: "java"
            },
            typescript: {
                name: "TypeScript",
                icon: "üìò",
                fileExt: "ts",
                monacoLang: "typescript"
            },
            python: {
                name: "Python",
                icon: "üêç",
                fileExt: "py",
                monacoLang: "python"
            },
            kotlin: {
                name: "Kotlin",
                icon: "‚ö°",
                fileExt: "kt",
                monacoLang: "kotlin"
            },
            rust: {
                name: "Rust",
                icon: "ü¶Ä",
                fileExt: "rs",
                monacoLang: "rust"
            }
        };

        // Êó∂Èó¥Ê†ºÂºèÊ≠£ÂàôË°®ËææÂºè
        const TIME_PATTERNS = [
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})?$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,
            /^\d{4}-\d{2}-\d{2}$/,
            /^\d{13}$/,
            /^\d{10}$/,
            /(time|date|timestamp|created|updated|start|end|at)$/i
        ];

        // ÈªòËÆ§JSONÔºàÂåÖÂê´Ê≥®ÈáäÂíåURLÊµãËØïÔºâ
        const DEFAULT_JSON = `{
  // Áî®Êà∑ID
  "user_id": 12345,
  // Áî®Êà∑Âêç
  "username": "john_doe",
  // ÈÇÆÁÆ±Âú∞ÂùÄ
  "email": "john@example.com",
  // Âπ¥ÈæÑ
  "age": 30,
  // ÊòØÂê¶ÊøÄÊ¥ª
  "is_active": true,
  // ÂàõÂª∫Êó∂Èó¥
  "created_at": "2023-10-01T12:00:00Z",
  // Êõ¥Êñ∞Êó∂Èó¥
  "updated_at": "2023-12-15T08:30:00Z",
  // Âá∫ÁîüÊó•Êúü
  "birth_date": "1993-05-15",
  // ÊúÄÂêéÁôªÂΩïÊó∂Èó¥
  "last_login": "2023-12-15T08:30:00.123Z",
  // ÂÖÉÊï∞ÊçÆ
  "metadata": {
    // Êó∂Èó¥Êà≥
    "timestamp": 1702643400000,
    // ËøáÊúüÊó∂Èó¥
    "expires_at": "2024-12-31 23:59:59"
  },
  // Áî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
  "preferences": {
    "theme": "dark",
    "language": "en"
  },
  // È°πÁõÆÂàóË°®
  "projects": [
    {
      "id": 1,
      "name": "API Gateway",
      "start_date": "2023-01-01",
      "end_date": "2023-12-31"
    }
  ]
}`;

        // ÊµãËØïJSONÔºöÂ§öÁª¥Êï∞ÁªÑ‰∏ãÂµåÂ•ó‰∏çÂêåÁªìÊûÑ‰ΩìÁöÑÂêàÂπ∂ÈÄªËæë
        const COMPLEX_JSON = `{
  "Âú∞ÂùÄ": "",
  "doc_url": "http://localhost",
  "docUrl": "http://localhost",
  "int1": 1,
  "int2": 3000000000,
  "float": 1.15,
  "a": [
    [
      {
        "a1": {
          "a2": [
            {"a3": "123"},
            {"b3": ""}
          ]
        }
      },
      {
        "a1": {
          "a2": [
            {"a3": 123},
            {"c3": ""}
          ],
          "b2": ""
        },
        "b1": {
          "b2": ""
        }
      }
    ]
  ]
}`;

        // ÂëΩÂêçÊ†ºÂºèÈÖçÁΩÆ
        const CASE_FORMATS = {
            pascal: {
                name: "Â§ßÈ©ºÂ≥∞ (PascalCase)",
                fn: (str) => str.split(/[_\s-]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('')
            },
            camel: {
                name: "Â∞èÈ©ºÂ≥∞ (camelCase)",
                fn: (str) => {
                    const words = str.split(/[_\s-]+/);
                    return words[0].toLowerCase() + words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');
                }
            },
            snake: {
                name: "‰∏ãÂàíÁ∫ø (snake_case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/-/g, '_')
            },
            kebab: {
                name: "ËøûÂ≠óÁ¨¶ (kebab-case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '').replace(/_/g, '-')
            }
        };

        function App() {
            const [lang, setLang] = useState("go");
            const [goTags, setGoTags] = useState({
                json: true,
                mapstructure: false,
                gorm: false,
                yaml: false,
                xml: false,
                validate: false,
                omitempty: true
            });

            const [structName, setStructName] = useState("Response");
            const [inlineStruct, setInlineStruct] = useState(false); // ÈªòËÆ§Êîπ‰∏∫ÊãÜÂàÜÊ®°ÂºèÔºå‰æø‰∫éÊü•Áúã
            const [detectTime, setDetectTime] = useState(true);
            const [includeComments, setIncludeComments] = useState(true);
            const [mergeArrayFields, setMergeArrayFields] = useState(true); // ÈªòËÆ§ÂºÄÂêØÂêàÂπ∂
            const [caseFormat, setCaseFormat] = useState("pascal");
            const [isCodeGenMode, setIsCodeGenMode] = useState(true);
            const [jsonText, setJsonText] = useState(DEFAULT_JSON); // ‰ΩøÁî®DEFAULT_JSON
            const [generatedCode, setGeneratedCode] = useState("");
            const [error, setError] = useState("");
            const [isGenerating, setIsGenerating] = useState(false);
            const [jsonStats, setJsonStats] = useState({ lines: 0, chars: 0, commentLines: 0 });
            const [codeStats, setCodeStats] = useState({ lines: 0, chars: 0 });
            const [timeFieldsDetected, setTimeFieldsDetected] = useState(0);
            const [generationInfo, setGenerationInfo] = useState(null);

            const jsonEditorRef = useRef(null);
            const jsonEditorInstance = useRef(null);
            const codeEditorRef = useRef(null);
            const codeEditorInstance = useRef(null);

            // ‰øÆÂ§çÁöÑÊï∞ÁªÑÂêàÂπ∂Â∑•ÂÖ∑ÂáΩÊï∞ÔºàÊîØÊåÅÂ§öÁª¥Êï∞ÁªÑÈÄíÂΩíÂêàÂπ∂Ôºâ
            const mergeArrayItems = useCallback((array) => {
                if (!array || array.length <= 1) return array;

                const firstItem = array[0];

                // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑÔºöÈÄíÂΩíÂ§ÑÁêÜÂ≠êÊï∞ÁªÑ
                if (Array.isArray(firstItem)) {
                    return array.map(subArray => mergeArrayItems(subArray));
                }

                // Â§ÑÁêÜÂØπË±°Êï∞ÁªÑ
                if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {
                    // Ê£ÄÊü•ÁªìÊûÑÊòØÂê¶Áõ∏Âêå
                    const checkStructure = (item) => {
                        if (!item || typeof item !== 'object' || Array.isArray(item)) {
                            return null;
                        }
                        return Object.keys(item).sort();
                    };

                    const firstKeys = checkStructure(firstItem);
                    if (!firstKeys) return array;

                    // Ê£ÄÊü•ÊâÄÊúâÂØπË±°ÊòØÂê¶ÁªìÊûÑÁõ∏Âêå
                    let allSameStructure = true;
                    for (let i = 1; i < array.length; i++) {
                        const currentKeys = checkStructure(array[i]);
                        if (!currentKeys || JSON.stringify(currentKeys) !== JSON.stringify(firstKeys)) {
                            allSameStructure = false;
                            break;
                        }
                    }

                    if (allSameStructure) return array;

                    // ÂêàÂπ∂ÊâÄÊúâÂ≠óÊÆµ
                    const allFields = new Set();
                    array.forEach(item => {
                        if (item && typeof item === 'object' && !Array.isArray(item)) {
                            Object.keys(item).forEach(key => allFields.add(key));
                        }
                    });

                    return array.map(item => {
                        if (!item || typeof item !== 'object' || Array.isArray(item)) {
                            return item;
                        }

                        const mergedItem = {};
                        allFields.forEach(field => {
                            if (item && item.hasOwnProperty(field)) {
                                // ÈÄíÂΩíÂ§ÑÁêÜÂµåÂ•óÁöÑÊï∞ÁªÑ
                                if (Array.isArray(item[field])) {
                                    mergedItem[field] = mergeArrayItems(item[field]);
                                } else if (item[field] && typeof item[field] === 'object') {
                                    // ÂØπ‰∫éÂµåÂ•óÂØπË±°ÔºåÂ¶ÇÊûú‰πüÊòØÊï∞ÁªÑÁªìÊûÑÂàôÈÄíÂΩíÂêàÂπ∂
                                    mergedItem[field] = item[field];
                                } else {
                                    mergedItem[field] = item[field];
                                }
                            } else {
                                mergedItem[field] = '';
                            }
                        });
                        return mergedItem;
                    });
                }

                return array;
            }, []);

            // Â§ÑÁêÜÂØπË±°ÂáΩÊï∞
            const processObject = useCallback((data) => {
                if (!mergeArrayFields) return data;

                const process = (item) => {
                    if (Array.isArray(item)) {
                        if (item.length > 0) {
                            const firstItem = item[0];
                            if (firstItem && typeof firstItem === 'object') {
                                // ÈÄíÂΩíÂ§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                                const processedArray = mergeArrayItems(item).map(process);
                                return processedArray;
                            } else if (Array.isArray(firstItem)) {
                                // Â§öÁª¥Êï∞ÁªÑ
                                return item.map(subArray => {
                                    if (Array.isArray(subArray) && subArray.length > 0) {
                                        const subFirstItem = subArray[0];
                                        if (subFirstItem && typeof subFirstItem === 'object') {
                                            return mergeArrayItems(subArray).map(process);
                                        }
                                    }
                                    return subArray.map(process);
                                });
                            }
                        }
                        return item;
                    } else if (item && typeof item === 'object') {
                        const result = {};
                        Object.entries(item).forEach(([key, value]) => {
                            if (Array.isArray(value)) {
                                result[key] = process(value);
                            } else if (value && typeof value === 'object') {
                                result[key] = process(value);
                            } else {
                                result[key] = value;
                            }
                        });
                        return result;
                    }
                    return item;
                };

                return process(JSON.parse(JSON.stringify(data)));
            }, [mergeArrayFields, mergeArrayItems]);

            // ÂàùÂßãÂåñÁºñËæëÂô®
            useEffect(() => {
                if (!jsonEditorInstance.current && jsonEditorRef.current) {
                    jsonEditorInstance.current = monaco.editor.create(jsonEditorRef.current, {
                        value: DEFAULT_JSON,
                        language: "json",
                        theme: "vs-dark",
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        foldingImportsByDefault: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on",
                        glyphMargin: true,
                        lineDecorationsWidth: 20,
                        renderLineHighlight: "all",
                        formatOnPaste: true,
                        formatOnType: true,
                        wordWrap: "off",
                        renderWhitespace: "selection",
                        quickSuggestions: true,
                        suggestOnTriggerCharacters: true,
                        acceptSuggestionOnEnter: "on",
                        tabCompletion: "on",
                        wordBasedSuggestions: true
                    });

                    // ÁõëÂê¨ÂÜÖÂÆπÂèòÂåñ
                    jsonEditorInstance.current.onDidChangeModelContent(() => {
                        const value = jsonEditorInstance.current.getValue();
                        setJsonText(value);

                        const lines = value.split('\n').length;
                        const chars = value.length;
                        const commentLines = (value.match(/\/\/.*$/g) || []).length;
                        setJsonStats({ lines, chars, commentLines });
                    });
                }

                // ‰øÆÂ§çÔºöÂßãÁªàÂàùÂßãÂåñ‰ª£Á†ÅÁºñËæëÂô®Ôºå‰∏ç‰æùËµñ isCodeGenMode
                if (!codeEditorInstance.current && codeEditorRef.current) {
                    codeEditorInstance.current = monaco.editor.create(codeEditorRef.current, {
                        value: "// ËØ∑ÂÖàÁîüÊàê‰ª£Á†Å\n// ÁÇπÂáª\"ÁîüÊàê‰ª£Á†Å\"ÊåâÈíÆÂºÄÂßã",
                        language: "go",
                        theme: "vs-dark",
                        readOnly: false,
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on"
                    });
                }

                return () => {
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }
                };
            }, []); // Á©∫‰æùËµñÊï∞ÁªÑÔºåÂè™Âú®ÁªÑ‰ª∂ÊåÇËΩΩ/Âç∏ËΩΩÊó∂ÊâßË°å

            // Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®ËØ≠Ë®Ä
            useEffect(() => {
                if (codeEditorInstance.current) {
                    const model = codeEditorInstance.current.getModel();
                    if (model) {
                        monaco.editor.setModelLanguage(model, LANGUAGE_CONFIG[lang].monacoLang);
                    }
                }
            }, [lang]);

            // ÊîπËøõÁöÑJSONÊ≥®ÈáäËß£ÊûêÂáΩÊï∞
            const parseJsonWithComments = useCallback((jsonString) => {
                try {
                    const removeComments = (str) => {
                        const lines = str.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const withoutComments = removeComments(jsonString);
                    const parsed = JSON.parse(withoutComments);

                    const comments = { fieldComments: {} };
                    const lines = jsonString.split('\n');
                    let currentField = '';

                    lines.forEach((line) => {
                        let inString = false;
                        let escaped = false;
                        let commentStart = -1;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            const nextChar = i + 1 < line.length ? line[i + 1] : '';

                            if (!escaped && char === '\\') {
                                escaped = true;
                            } else if (!escaped && char === '"') {
                                inString = !inString;
                            } else if (!inString && char === '/' && nextChar === '/') {
                                commentStart = i;
                                break;
                            } else {
                                escaped = false;
                            }
                        }

                        if (commentStart !== -1) {
                            const comment = line.substring(commentStart + 2).trim();
                            if (currentField && comment) {
                                comments.fieldComments[currentField] = comment;
                            }

                            const beforeComment = line.substring(0, commentStart);
                            const fieldMatch = beforeComment.match(/"([^"]+)":\s*$/);
                            if (fieldMatch) {
                                currentField = fieldMatch[1];
                            }
                        }

                        const fieldMatch = line.match(/"([^"]+)":/);
                        if (fieldMatch) {
                            currentField = fieldMatch[1];
                        }
                    });

                    return { parsed, comments };
                } catch (err) {
                    try {
                        const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                        const parsed = JSON.parse(withoutComments);
                        return { parsed, comments: { fieldComments: {} } };
                    } catch (err2) {
                        throw new Error(`JSONËß£ÊûêÂ§±Ë¥•: ${err2.message}`);
                    }
                }
            }, []);

            // Ê∏ÖÁêÜJSONÔºöÁßªÈô§Ê≥®ÈáäÂπ∂Ê†ºÂºèÂåñ
            const cleanJson = useCallback((jsonString) => {
                try {
                    const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                    const parsed = JSON.parse(withoutComments);
                    return JSON.stringify(parsed, null, 2);
                } catch (err) {
                    throw new Error(`JSONÊ∏ÖÁêÜÂ§±Ë¥•: ${err.message}`);
                }
            }, []);

            // Ê£ÄÊµãÊó∂Èó¥Â≠óÊÆµ
            const detectTimeFields = useCallback((obj) => {
                let count = 0;

                const traverse = (data) => {
                    if (Array.isArray(data)) {
                        data.forEach(item => {
                            if (item && typeof item === 'object') {
                                traverse(item);
                            }
                        });
                    } else if (data && typeof data === 'object') {
                        Object.entries(data).forEach(([key, value]) => {
                            if (typeof value === 'string' && isTimeString(value)) {
                                count++;
                            }
                            else if (isTimeFieldName(key)) {
                                count++;
                            }
                            if (value && typeof value === 'object') {
                                traverse(value);
                            }
                        });
                    }
                };

                traverse(obj);
                return count;
            }, []);

            // Êî∂ÈõÜÁîüÊàê‰ø°ÊÅØ
            const collectGenerationInfo = useCallback((obj, lang, detectTime, mergeArrayFields) => {
                const info = {
                    totalFields: 0,
                    nestedObjects: 0,
                    arrays: 0,
                    timeFields: 0,
                    maxDepth: 0,
                    mergedArrays: 0,
                    warnings: []
                };

                const traverse = (data, depth = 0) => {
                    info.maxDepth = Math.max(info.maxDepth, depth);

                    if (Array.isArray(data)) {
                        info.arrays++;

                        if (mergeArrayFields && data.length > 1 &&
                            data.every(item => item && typeof item === 'object' && !Array.isArray(item))) {

                            const firstKeys = Object.keys(data[0] || {});
                            let allSameStructure = true;

                            for (let i = 1; i < data.length; i++) {
                                const currentKeys = Object.keys(data[i] || {});
                                if (currentKeys.length !== firstKeys.length ||
                                    !currentKeys.every(key => firstKeys.includes(key))) {
                                    allSameStructure = false;
                                    break;
                                }
                            }

                            if (!allSameStructure) {
                                info.mergedArrays++;
                            }
                        }

                        if (data.length > 0) {
                            const firstItem = data[0];
                            if (firstItem && typeof firstItem === 'object') {
                                data.forEach(item => traverse(item, depth + 1));
                            }
                        }
                    } else if (data && typeof data === 'object') {
                        info.nestedObjects++;
                        Object.entries(data).forEach(([key, value]) => {
                            info.totalFields++;

                            if (detectTime && isTimeField(key, value)) {
                                info.timeFields++;
                            }

                            if (value && typeof value === 'object') {
                                traverse(value, depth + 1);
                            }
                        });
                    }
                };

                traverse(obj);

                if (info.maxDepth > 5) {
                    info.warnings.push(`JSONÂµåÂ•óÊ∑±Â∫¶ËæÉÊ∑± (${info.maxDepth} Â±Ç)ÔºåÂèØËÉΩÂØºËá¥ÁîüÊàêÁöÑÁªìÊûÑ‰ΩìÂ§çÊùÇ`);
                }
                if (info.arrays > 10) {
                    info.warnings.push(`Êï∞ÁªÑÊï∞ÈáèËæÉÂ§ö (${info.arrays} ‰∏™)ÔºåÂèØËÉΩÂΩ±ÂìçÊÄßËÉΩ`);
                }
                if (info.mergedArrays > 0) {
                    info.warnings.push(`Â∑≤ÂêàÂπ∂ ${info.mergedArrays} ‰∏™Êï∞ÁªÑÁöÑ‰∏çÂêåÁªìÊûÑÂ≠óÊÆµ`);
                }

                return info;
            }, []);

            // ÁîüÊàê‰ª£Á†ÅÂáΩÊï∞
            const generateCode = useCallback(() => {
                setIsGenerating(true);
                setError("");
                setGenerationInfo(null);

                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj, comments } = parseJsonWithComments(jsonValue);

                    const timeFieldsCount = detectTime ? detectTimeFields(obj) : 0;
                    setTimeFieldsDetected(timeFieldsCount);

                    const genInfo = collectGenerationInfo(obj, lang, detectTime, mergeArrayFields);
                    setGenerationInfo(genInfo);

                    const processedObj = processObject(obj);
                    const code = generateCodeFromObject(
                        processedObj,
                        lang,
                        structName,
                        goTags,
                        inlineStruct,
                        detectTime,
                        includeComments ? comments : null,
                        caseFormat
                    );

                    setGeneratedCode(code);

                    // Âº∫Âà∂Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®ÔºåÊó†ËÆ∫ÊòØÂê¶ÂèØËßÅ
                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(code);

                            // Á´ãÂç≥ÊâßË°åÂ∏ÉÂ±ÄÊõ¥Êñ∞
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }

                    const lines = code.split('\n').length;
                    const chars = code.length;
                    setCodeStats({ lines, chars });

                } catch (err) {
                    const errorMsg = `JSONËß£ÊûêÈîôËØØ: ${err.message}`;
                    setError(errorMsg);

                    const errorCode = `// ${errorMsg}\n// ËØ∑Ê£ÄÊü•JSONÊ†ºÂºèÊòØÂê¶Ê≠£Á°Æ`;
                    setGeneratedCode(errorCode);

                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(errorCode);
                        }
                    }

                    setCodeStats({ lines: 2, chars: errorCode.length });
                    setTimeFieldsDetected(0);
                    setGenerationInfo(null);
                } finally {
                    setIsGenerating(false);
                }
            }, [lang, goTags, structName, inlineStruct, detectTime, jsonText, mergeArrayFields, detectTimeFields, includeComments, caseFormat, parseJsonWithComments, collectGenerationInfo, processObject]);

            // JSONÊ†ºÂºèÂåñÂáΩÊï∞
            const formatJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj } = parseJsonWithComments(jsonValue);
                    const formatted = JSON.stringify(obj, null, 2);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(formatted);
                    }
                    setJsonText(formatted);
                    setError("");
                    setGenerationInfo(null);
                } catch (err) {
                    setError(`Ê†ºÂºèÂåñÈîôËØØ: ${err.message}`);
                }
            };

            const minifyJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj } = parseJsonWithComments(jsonValue);
                    const minified = JSON.stringify(obj);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(minified);
                    }
                    setJsonText(minified);
                    setError("");
                    setGenerationInfo(null);
                } catch (err) {
                    setError(`ÂéãÁº©ÈîôËØØ: ${err.message}`);
                }
            };

            const escapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const escaped = JSON.stringify(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(escaped);
                    }
                    setJsonText(escaped);
                    setError("");
                    setGenerationInfo(null);
                } catch (err) {
                    setError(`ËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            const unescapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const unescaped = JSON.parse(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(unescaped);
                    }
                    setJsonText(unescaped);
                    setError("");
                    setGenerationInfo(null);
                } catch (err) {
                    setError(`ÂéªËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            // ÊîπËøõÁöÑÁßªÈô§Ê≥®ÈáäÂáΩÊï∞
            const removeComments = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;

                    const removeJsonComments = (jsonString) => {
                        const lines = jsonString.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const cleaned = removeJsonComments(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(cleaned);
                    }
                    setJsonText(cleaned);
                    setError("");
                    setGenerationInfo(null);
                } catch (err) {
                    setError(`ÁßªÈô§Ê≥®ÈáäÈîôËØØ: ${err.message}`);
                }
            };

            const resetJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(DEFAULT_JSON);
                }
                setJsonText(DEFAULT_JSON);
                setError("");
                setGenerationInfo(null);
            };

            const loadComplexJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(COMPLEX_JSON);
                }
                setJsonText(COMPLEX_JSON);
                setError("");
                setGenerationInfo(null);
            };

            // Â§çÂà∂‰ª£Á†ÅÂà∞Ââ™Ë¥¥Êùø
            const copyCode = () => {
                if (generatedCode) {
                    navigator.clipboard.writeText(generatedCode)
                        .then(() => {
                            console.log("‰ª£Á†ÅÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø");
                        })
                        .catch(err => {
                            console.error("Â§çÂà∂Â§±Ë¥•:", err);
                        });
                }
            };

            // ‰∏ãËΩΩ‰ª£Á†Å
            const downloadCode = () => {
                if (!generatedCode) return;

                const blob = new Blob([generatedCode], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${structName}.${LANGUAGE_CONFIG[lang].fileExt}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // Â§ÑÁêÜGoÊ†áÁ≠æÊõ¥Êñ∞
            const updateGoTag = (tag, checked) => {
                setGoTags(prev => ({
                    ...prev,
                    [tag]: checked
                }));
            };

            // ‰øÆÂ§çÁöÑtoggleCodeGenModeÂáΩÊï∞
            const toggleCodeGenMode = () => {
                const newMode = !isCodeGenMode;
                setIsCodeGenMode(newMode);

                // ÂΩìÈáçÊñ∞ÊâìÂºÄ‰ª£Á†ÅÁîüÊàêÊ®°ÂºèÊó∂ÔºåÁ°Æ‰øù‰ª£Á†ÅÁºñËæëÂô®ÂÜÖÂÆπÊòØÊúÄÊñ∞ÁöÑ
                if (newMode && generatedCode && codeEditorInstance.current) {
                    // ÁªôDOM‰∏Ä‰∫õÊó∂Èó¥Êù•Ê∏≤Êüì
                    setTimeout(() => {
                        const model = codeEditorInstance.current.getModel();
                        if (model && model.getValue() !== generatedCode) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(generatedCode);

                            // Âº∫Âà∂ÈáçÊñ∞Â∏ÉÂ±Ä
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }, 50);
                }
            };

            // ÁõëÂê¨ generatedCode ÂèòÂåñÔºåÁ°Æ‰øù‰ª£Á†ÅÁºñËæëÂô®ÂêåÊ≠•Êõ¥Êñ∞
            useEffect(() => {
                if (codeEditorInstance.current && generatedCode && isCodeGenMode) {
                    const model = codeEditorInstance.current.getModel();
                    if (model && model.getValue() !== generatedCode) {
                        codeEditorInstance.current.pushUndoStop();
                        model.setValue(generatedCode);

                        // Âª∂ËøüÂ∏ÉÂ±ÄÊõ¥Êñ∞ÔºåÁ°Æ‰øùDOMÂ∑≤Ê∏≤Êüì
                        setTimeout(() => {
                            if (codeEditorInstance.current) {
                                codeEditorInstance.current.layout();
                            }
                        }, 10);
                    }
                }
            }, [generatedCode, isCodeGenMode]);

            return React.createElement("div", { className: "app-container" },
                React.createElement("div", { className: "header" },
                    React.createElement("h1", null,
                        React.createElement("i", { className: "fas fa-code" }),
                        "JSON ‚Üí Â§öËØ≠Ë®ÄÁªìÊûÑ‰ΩìÁîüÊàêÂô®"
                    ),
                    React.createElement("div", { className: "subtitle" },
                        "ÊîØÊåÅ Golang, Java, TypeScript, Python, Kotlin, Rust"
                    )
                ),

                React.createElement("div", { className: "config-panel" },
                    React.createElement("div", { className: "config-content" },
                        React.createElement("div", { className: "action-buttons compact-actions" },
                            React.createElement("div", { className: "mode-switch-inline" },
                                React.createElement("label", { className: "switch" },
                                    React.createElement("input", {
                                        type: "checkbox",
                                        checked: isCodeGenMode,
                                        onChange: toggleCodeGenMode
                                    }),
                                    React.createElement("span", { className: "slider" })
                                ),
                                React.createElement("span", { className: "switch-label" },
                                    "‰ª£Á†ÅÁîüÊàê"
                                )
                            ),

                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: formatJson,
                                    title: "Ê†ºÂºèÂåñJSONÔºà‰øùÁïôÊ≥®ÈáäÔºâ"
                                },
                                React.createElement("i", { className: "fas fa-indent" }),
                                "Ê†ºÂºèÂåñ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: removeComments,
                                    title: "ÁßªÈô§Ê≥®Èáä"
                                },
                                React.createElement("i", { className: "fas fa-comment-slash" }),
                                "ÂéªÊ≥®Èáä"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: minifyJson,
                                    title: "ÂéãÁº©JSON"
                                },
                                React.createElement("i", { className: "fas fa-compress" }),
                                "ÂéãÁº©"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: escapeJson,
                                    title: "ËΩ¨‰πâJSON"
                                },
                                React.createElement("i", { className: "fas fa-code" }),
                                "ËΩ¨‰πâ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: unescapeJson,
                                    title: "ÂéªËΩ¨‰πâJSON"
                                },
                                React.createElement("i", { className: "fas fa-code" }),
                                "ÂéªËΩ¨‰πâ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: resetJson,
                                    title: "ÈáçÁΩÆ‰∏∫ÈªòËÆ§JSON"
                                },
                                React.createElement("i", { className: "fas fa-redo" }),
                                "ÈáçÁΩÆ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary btn-compact",
                                    onClick: loadComplexJson,
                                    title: "Âä†ËΩΩÂ§çÊùÇJSONÁ§∫‰æã"
                                },
                                React.createElement("i", { className: "fas fa-cogs" }),
                                "Â§çÊùÇÁ§∫‰æã"
                            ),
                            isCodeGenMode && React.createElement("button", {
                                    className: "btn btn-primary btn-compact",
                                    onClick: generateCode,
                                    disabled: isGenerating,
                                    title: "ÁîüÊàê‰ª£Á†Å"
                                },
                                isGenerating
                                    ? React.createElement(React.Fragment, null,
                                        React.createElement("i", { className: "fas fa-spinner fa-spin" }),
                                        "ÁîüÊàê‰∏≠..."
                                    )
                                    : React.createElement(React.Fragment, null,
                                        React.createElement("i", { className: "fas fa-bolt" }),
                                        "ÁîüÊàê‰ª£Á†Å"
                                    )
                            )
                        ),

                        isCodeGenMode && React.createElement("div", { className: "config-row code-gen-config" },
                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "language-select" }, "ÁõÆÊ†áËØ≠Ë®Ä"),
                                React.createElement("div", { className: "language-select" },
                                    React.createElement("select", {
                                            id: "language-select",
                                            value: lang,
                                            onChange: (e) => setLang(e.target.value),
                                            className: "compact-select"
                                        },
                                        Object.entries(LANGUAGE_CONFIG).map(([value, config]) =>
                                            React.createElement("option", { key: value, value: value },
                                                `${config.icon} ${config.name}`
                                            )
                                        )
                                    )
                                )
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "struct-name" }, "ÁªìÊûÑ‰ΩìÂêç"),
                                React.createElement("input", {
                                    id: "struct-name",
                                    type: "text",
                                    value: structName,
                                    onChange: (e) => setStructName(e.target.value),
                                    className: "compact-input"
                                })
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "case-format" }, "ÂëΩÂêçÊ†ºÂºè"),
                                React.createElement("select", {
                                        id: "case-format",
                                        className: "format-select case-format-select compact-select",
                                        value: caseFormat,
                                        onChange: (e) => setCaseFormat(e.target.value)
                                    },
                                    Object.entries(CASE_FORMATS).map(([value, config]) =>
                                        React.createElement("option", { key: value, value: value },
                                            config.name
                                        )
                                    )
                                )
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "ÈÄâÈ°π"),
                                React.createElement("div", { className: "checkbox-options compact-options" },
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "inline-struct",
                                            checked: inlineStruct,
                                            onChange: (e) => setInlineStruct(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "inline-struct",
                                            title: "ÂÜÖËÅîÁªìÊûÑ‰Ωì"
                                        }, "ÂÜÖËÅî")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "detect-time",
                                            checked: detectTime,
                                            onChange: (e) => setDetectTime(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "detect-time",
                                            title: "Ê£ÄÊµãÊó∂Èó¥Á±ªÂûã"
                                        }, "Êó∂Èó¥")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "include-comments",
                                            checked: includeComments,
                                            onChange: (e) => setIncludeComments(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "include-comments",
                                            title: "ÂåÖÂê´Ê≥®Èáä"
                                        }, "Ê≥®Èáä")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "merge-array-fields",
                                            checked: mergeArrayFields,
                                            onChange: (e) => setMergeArrayFields(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "merge-array-fields",
                                            title: "ÂêàÂπ∂Êï∞ÁªÑÂ≠óÊÆµ"
                                        }, "ÂêàÂπ∂Êï∞ÁªÑ")
                                    )
                                )
                            ),

                            lang === "go" && React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "GoÊ†áÁ≠æ"),
                                React.createElement("div", { className: "go-tags-container compact-tags" },
                                    Object.entries(goTags).map(([tag, checked]) =>
                                        React.createElement("div", { className: "tag-checkbox compact-tag", key: tag },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                id: `tag-${tag}`,
                                                checked: checked,
                                                onChange: (e) => updateGoTag(tag, e.target.checked)
                                            }),
                                            React.createElement("label", {
                                                htmlFor: `tag-${tag}`,
                                                title: tag
                                            }, tag === "omitempty" ? "omit" : tag)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    error && React.createElement("div", { className: "error-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        error
                    ),

                    isCodeGenMode && generationInfo && React.createElement("div", { className: "generation-info" },
                        React.createElement("div", { className: "generation-info-compact" },
                            React.createElement("div", { className: "generation-info-group" },
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Â≠óÊÆµ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.totalFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂµåÂ•ó: "),
                                    React.createElement("span", { className: "value" }, generationInfo.nestedObjects)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êï∞ÁªÑ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.arrays)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êó∂Èó¥: "),
                                    React.createElement("span", { className: "value" }, generationInfo.timeFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Ê∑±Â∫¶: "),
                                    React.createElement("span", { className: "value" }, generationInfo.maxDepth)
                                ),
                                generationInfo.mergedArrays > 0 && React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂêàÂπ∂: "),
                                    React.createElement("span", { className: "value warning" }, generationInfo.mergedArrays)
                                )
                            )
                        )
                    ),

                    isCodeGenMode && generationInfo && generationInfo.warnings.length > 0 &&
                    React.createElement("div", { className: "warning-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        React.createElement("div", null,
                            generationInfo.warnings.map((warning, index) =>
                                React.createElement("div", { key: index }, warning)
                            )
                        )
                    )
                ),

                React.createElement("div", { className: "editor-panels" },
                    React.createElement("div", {
                            className: `panel ${isCodeGenMode ? 'json-panel partial-width' : 'json-panel full-width'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-code" }),
                                "JSON ËæìÂÖ•"
                            ),
                            jsonStats.commentLines > 0 && React.createElement("div", { className: "comment-indicator" },
                                React.createElement("i", { className: "fas fa-comment" }),
                                `${jsonStats.commentLines} Êù°Ê≥®Èáä`
                            ),
                            React.createElement("div", { className: "json-tools" },
                                React.createElement("div", { className: "panel-stats" },
                                    `${jsonStats.lines} Ë°å, ${jsonStats.chars} Â≠óÁ¨¶`
                                )
                            )
                        ),
                        React.createElement("div", {
                            ref: jsonEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // ‰øÆÂ§çÔºöÂßãÁªàÊ∏≤Êüì‰ª£Á†ÅÈù¢ÊùøÔºåÁî®CSSÊéßÂà∂ÊòæÁ§∫
                    React.createElement("div", {
                            className: `panel code-panel ${isCodeGenMode ? '' : 'hidden'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-file-code" }),
                                `${LANGUAGE_CONFIG[lang].name} ‰ª£Á†Å`
                            ),
                            React.createElement("div", { className: "panel-stats" },
                                generatedCode && isCodeGenMode
                                    ? `${codeStats.lines} Ë°å, ${codeStats.chars} Â≠óÁ¨¶`
                                    : "Á≠âÂæÖÁîüÊàê‰ª£Á†Å"
                            )
                        ),
                        React.createElement("div", {
                            ref: codeEditorRef,
                            className: "panel-content"
                        })
                    )
                ),

                isCodeGenMode && React.createElement("div", { className: "status-bar" },
                    React.createElement("div", { className: "status-item" },
                        React.createElement("div", { className: "language-badge" },
                            React.createElement("i", { className: "fas fa-code" }),
                            LANGUAGE_CONFIG[lang].name
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: inlineStruct ? "#86efac" : "#fbbf24"
                                }
                            },
                            inlineStruct ? "ÂÜÖËÅîÊ®°Âºè" : "ÊãÜÂàÜÊ®°Âºè"
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: includeComments ? "#86efac" : "#94a3b8"
                                }
                            },
                            includeComments ? "Âê´Ê≥®Èáä" : "Êó†Ê≥®Èáä"
                        ),
                        detectTime && timeFieldsDetected > 0 &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#60a5fa"
                                }
                            },
                            `Êó∂Èó¥Â≠óÊÆµ: ${timeFieldsDetected}`
                        ),
                        mergeArrayFields &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#fbbf24"
                                }
                            },
                            "ÂêàÂπ∂Êï∞ÁªÑ"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("i", { className: "fas fa-info-circle info-icon" }),
                        React.createElement("span", null,
                            CASE_FORMATS[caseFormat]?.name || "Â§ßÈ©ºÂ≥∞ (PascalCase)"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: copyCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-copy" }),
                            "Â§çÂà∂"
                        ),
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: downloadCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-download" }),
                            "‰∏ãËΩΩ"
                        )
                    )
                )
            );
        }

        // ============= ‰øÆÂ§çÁöÑËæÖÂä©ÂáΩÊï∞ =============

        function isTimeString(value) {
            return TIME_PATTERNS.some(pattern => pattern.test(value));
        }

        function isTimeFieldName(fieldName) {
            return /(time|date|timestamp|created|updated|start|end|at)$/i.test(fieldName);
        }

        function isTimeField(key, value) {
            if (typeof value === 'string' && isTimeString(value)) {
                return true;
            }
            if (isTimeFieldName(key)) {
                return true;
            }
            return false;
        }

        function getTimeType(lang) {
            switch(lang) {
                case 'go': return 'time.Time';
                case 'java': return 'java.time.LocalDateTime';
                case 'typescript': return 'Date';
                case 'python': return 'datetime.datetime';
                case 'kotlin': return 'java.time.LocalDateTime';
                case 'rust': return 'chrono::DateTime<chrono::Utc>';
                default: return 'string';
            }
        }

        // ‰øÆÂ§çÁöÑÂ≠óÊÆµÂêçÊ†ºÂºèÂåñÂáΩÊï∞Ôºà‰øùÁïô‰∏≠ÊñáÔºâ
        function formatFieldName(name, format, lang, isStructName = false) {
            if (!name || name.trim() === '') return name;

            // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÊñáÂ≠óÊÆµ
            const hasChinese = /[\u4e00-\u9fa5]/.test(name);

            let cleaned = name;

            // Â¶ÇÊûú‰∏çÊòØ‰∏≠ÊñáÔºåËøõË°åÊ†ºÂºèËΩ¨Êç¢
            if (!hasChinese && CASE_FORMATS[format]) {
                cleaned = CASE_FORMATS[format].fn(cleaned);
            }

            // GoËØ≠Ë®ÄÁöÑÁªìÊûÑ‰ΩìÂêçÈúÄË¶ÅÈ¶ñÂ≠óÊØçÂ§ßÂÜô
            if (lang === 'go' && isStructName) {
                if (hasChinese) {
                    cleaned = cleaned;
                } else {
                    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
                }
            }

            // Â¶ÇÊûúÂºÄÂ§¥ÊòØÊï∞Â≠óÔºåÊ∑ªÂä†ÂâçÁºÄ
            if (/^\d/.test(cleaned)) {
                cleaned = 'field' + cleaned;
            }

            return cleaned;
        }

        function generateCodeFromObject(obj, lang, structName, goTags, inlineStruct, detectTime, comments, caseFormat) {
            const formatName = (name, isStructName = false) =>
                formatFieldName(name, caseFormat, lang, isStructName);

            if (lang === "go") return genGo(obj, formatName(structName, true), goTags, inlineStruct, detectTime, comments, formatName);
            if (lang === "typescript") return genTypeScript(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "java") return genJava(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "python") return genPython(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "kotlin") return genKotlin(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "rust") return genRust(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            return `// ‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä: ${lang}`;
        }

        // ‰øÆÂ§çÁöÑinferTypeÂáΩÊï∞ÔºåÊîØÊåÅÂ§öÁª¥Êï∞ÁªÑ
        function inferType(value, lang, key = '', detectTime = false, parentPath = '') {
            if (detectTime && isTimeField(key, value)) {
                return getTimeType(lang);
            }

            if (value === null) {
                if (lang === "typescript") return "null";
                if (lang === "java") return "Object";
                if (lang === "kotlin") return "Any?";
                if (lang === "rust") return "Option<serde_json::Value>";
                return "any";
            }

            if (Array.isArray(value)) {
                if (value.length === 0) {
                    if (lang === "go") return "[]interface{}";
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                const firstItem = value[0];

                // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                if (Array.isArray(firstItem)) {
                    // ÈÄíÂΩíÊé®Êñ≠ÂÜÖÈÉ®Êï∞ÁªÑÁ±ªÂûã
                    const innerType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                    const baseType = innerType
                        .replace('[]', '')
                        .replace('List<', '')
                        .replace('>', '')
                        .replace('Vec<', '')
                        .replace('List[', '')
                        .replace(']', '');

                    if (lang === "go") return `[][]${baseType}`;
                    if (lang === "typescript") return `${baseType}[][]`;
                    if (lang === "java") return `List<List<${baseType}>>`;
                    if (lang === "kotlin") return `List<List<${baseType}>>`;
                    if (lang === "rust") return `Vec<Vec<${baseType}>>`;
                    if (lang === "python") return `List[List[${baseType}]]`;
                }

                // Ê£ÄÊü•Êï∞ÁªÑÂÖÉÁ¥†ÊòØÂê¶ÈÉΩÊòØÂØπË±°
                const allObjects = value.every(item => item && typeof item === 'object' && !Array.isArray(item));

                if (allObjects) {
                    // ÂØπ‰∫éGoËØ≠Ë®ÄÔºåËøîÂõûÂç†‰ΩçÁ¨¶ÔºåÁî±‰∏äÂ±ÇÂáΩÊï∞Â§ÑÁêÜ
                    if (lang === "go") return "[]struct{}";
                    // ÂÖ∂‰ªñËØ≠Ë®ÄËøîÂõûÈÄöÁî®Á±ªÂûã
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                const itemType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                if (lang === "go") return `[]${itemType}`;
                if (lang === "typescript") return `${itemType}[]`;
                if (lang === "java") return `List<${itemType}>`;
                if (lang === "kotlin") return `List<${itemType}>`;
                if (lang === "rust") return `Vec<${itemType}>`;
                if (lang === "python") return `List[${itemType}]`;
            }

            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                if (Object.keys(value).length === 0) {
                    if (lang === "go") return "map[string]interface{}";
                    if (lang === "typescript") return "Record<string, any>";
                    if (lang === "java") return "Map<String, Object>";
                    if (lang === "kotlin") return "Map<String, Any?>";
                    if (lang === "rust") return "HashMap<String, serde_json::Value>";
                    if (lang === "python") return "Dict[str, Any]";
                } else {
                    if (lang === "go") return "struct";
                    if (lang === "typescript") return "any";
                    if (lang === "java") return "Object";
                    if (lang === "kotlin") return "Any?";
                    if (lang === "rust") return "serde_json::Value";
                    if (lang === "python") return "dict";
                }
            }

            switch (typeof value) {
                case "number":
                    if (Number.isInteger(value)) {
                        if (value > 2147483647 || value < -2147483648) {
                            if (lang === "go") return "int64";
                            if (lang === "java") return "Long";
                            if (lang === "kotlin") return "Long";
                            if (lang === "rust") return "i64";
                        } else {
                            if (lang === "go") return "int";
                            if (lang === "typescript") return "number";
                            if (lang === "java") return "Integer";
                            if (lang === "kotlin") return "Int";
                            if (lang === "rust") return "i32";
                            if (lang === "python") return "int";
                        }
                    } else {
                        if (lang === "go") return "float64";
                        if (lang === "typescript") return "number";
                        if (lang === "java") return "Double";
                        if (lang === "kotlin") return "Double";
                        if (lang === "rust") return "f64";
                        if (lang === "python") return "float";
                    }
                    break;
                case "string":
                    if (lang === "go") return "string";
                    if (lang === "typescript") return "string";
                    if (lang === "java") return "String";
                    if (lang === "kotlin") return "String";
                    if (lang === "rust") return "String";
                    if (lang === "python") return "str";
                    break;
                case "boolean":
                    if (lang === "go") return "bool";
                    if (lang === "typescript") return "boolean";
                    if (lang === "java") return "Boolean";
                    if (lang === "kotlin") return "Boolean";
                    if (lang === "rust") return "bool";
                    if (lang === "python") return "bool";
                    break;
            }

            return "any";
        }

        // ÁîüÊàêGo‰ª£Á†Å
        function genGo(obj, name, tags, inlineStruct, detectTime, comments, formatName) {
            let allStructs = {};
            let mainStructCode = "";

            mainStructCode = genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs, 0, comments, formatName);

            let code = "";

            if (comments && comments.fieldComments[name]) {
                code += `// ${comments.fieldComments[name]}\n`;
            }

            let hasTimeField = false;
            const checkTimeField = (obj) => {
                for (const [key, value] of Object.entries(obj)) {
                    if (detectTime && isTimeField(key, value)) {
                        return true;
                    }
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        if (checkTimeField(value)) return true;
                    } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        if (checkTimeField(value[0])) return true;
                    }
                }
                return false;
            };
            hasTimeField = checkTimeField(obj);

            if (hasTimeField) {
                code = "import \"time\"\n\n" + code;
            }

            if (!inlineStruct) {
                for (const [structName, structCode] of Object.entries(allStructs)) {
                    if (structName !== name) {
                        code += structCode + "\n\n";
                    }
                }
            }

            code += mainStructCode;

            return code;
        }

        // ‰øÆÂ§çÁöÑgenGoStructÂáΩÊï∞ÔºåÊ≠£Á°ÆÂ§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
        function genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs = {}, depth = 0, comments, formatName, path = '') {
            if (depth > 20) {
                return `type ${name} struct {\n  // ÂµåÂ•óÊ∑±Â∫¶ËøáÂ§ßÔºåÂª∫ËÆÆÁÆÄÂåñJSONÁªìÊûÑ\n  Data map[string]interface{} \`json:"data"\`\n}`;
            }

            let code = `type ${name} struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);

                const comment = comments ? comments.fieldComments[key] : null;
                if (comment) {
                    code += `  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }
                if (tags.gorm) {
                    tagParts.push(`gorm:"column:${key}"`);
                }
                if (tags.yaml) {
                    tagParts.push(`yaml:"${key}"`);
                }
                if (tags.xml) {
                    tagParts.push(`xml:"${key}"`);
                }
                if (tags.validate) {
                    const validateRules = [];
                    if (typeof value === "string") {
                        if (value.includes("@")) validateRules.push("email");
                        if (key.toLowerCase().includes("url")) validateRules.push("url");
                    }
                    if (typeof value === "number") validateRules.push("numeric");
                    if (validateRules.length > 0) {
                        tagParts.push(`validate:"${validateRules.join(",")}"`);
                    }
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null) {
                    if (Array.isArray(value)) {
                        // Â§ÑÁêÜÊï∞ÁªÑÁ±ªÂûã
                        if (value.length === 0) {
                            code += `  ${fieldName} []interface{}${tagStr}\n`;
                        } else {
                            const firstItem = value[0];

                            // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                            if (Array.isArray(firstItem)) {
                                // Â§öÁª¥Êï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÂèØËÉΩÊòØÂØπË±°
                                const nestedItem = firstItem[0] || {};
                                if (typeof nestedItem === 'object' && nestedItem !== null && Object.keys(nestedItem).length > 0) {
                                    const itemTypeName = formatName(key, true) + 'Item';
                                    if (!allStructs[itemTypeName]) {
                                        // ÈÄíÂΩíÁîüÊàêÂµåÂ•óÁªìÊûÑ‰Ωì
                                        allStructs[itemTypeName] = genGoStruct(nestedItem, itemTypeName, tags, false, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                    code += `  ${fieldName} [][]${itemTypeName}${tagStr}\n`;
                                } else {
                                    // Â§öÁª¥Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                                    const itemType = inferType(nestedItem, "go", key, detectTime, currentPath);
                                    code += `  ${fieldName} [][]${itemType}${tagStr}\n`;
                                }
                            } else if (typeof firstItem === "object" && firstItem !== null) {
                                // ÂØπË±°Êï∞ÁªÑ
                                const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);

                                if (inlineStruct) {
                                    code += `  ${fieldName} []${genGoInlineStruct(firstItem, itemTypeName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                                } else {
                                    code += `  ${fieldName} []${itemTypeName}${tagStr}\n`;

                                    if (!allStructs[itemTypeName]) {
                                        allStructs[itemTypeName] = genGoStruct(firstItem, itemTypeName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                }
                            } else {
                                // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                                const itemType = inferType(firstItem, "go", key, detectTime, currentPath);
                                code += `  ${fieldName} []${itemType}${tagStr}\n`;
                            }
                        }
                    } else {
                        // ÂØπË±°Á±ªÂûã
                        const nestedStructName = formatName(key, true);

                        if (Object.keys(value).length === 0) {
                            code += `  ${fieldName} map[string]interface{}${tagStr}\n`;
                        } else if (inlineStruct) {
                            code += `  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                        } else {
                            code += `  ${fieldName} ${nestedStructName}${tagStr}\n`;

                            if (!allStructs[nestedStructName]) {
                                allStructs[nestedStructName] = genGoStruct(value, nestedStructName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                            }
                        }
                    }
                } else {
                    // Âü∫Êú¨Á±ªÂûã
                    code += `  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += "}";

            if (!allStructs[name]) {
                allStructs[name] = code;
            }

            return code;
        }

        function genGoInlineStruct(obj, name, tags, detectTime, depth, comments, formatName, path) {
            let indent = "  ".repeat(depth);
            let code = `${indent}struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    code += `${indent}  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                    const nestedStructName = formatName(key, true);
                    code += `${indent}  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object") {
                    const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);
                    code += `${indent}  ${fieldName} []${itemTypeName}${tagStr}\n`;
                } else {
                    code += `${indent}  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += `${indent}}`;
            return code;
        }

        function genTypeScript(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "typescript", inlineStruct, detectTime, comments, formatName);
        }

        function genJava(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "java", inlineStruct, detectTime, comments, formatName);
        }

        function genPython(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "python", inlineStruct, detectTime, comments, formatName);
        }

        function genKotlin(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "kotlin", inlineStruct, detectTime, comments, formatName);
        }

        function genRust(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "rust", inlineStruct, detectTime, comments, formatName);
        }

        function generateGenericCode(obj, name, lang, inlineStruct, detectTime, comments, formatName, depth = 0, path = '') {
            if (depth > 10) {
                return `// ÁªìÊûÑÂµåÂ•óËøáÊ∑±ÔºåÂª∫ËÆÆÁÆÄÂåñJSON\n// ${name} Á±ªÂûãÂÆö‰πâ`;
            }

            let code = '';

            switch(lang) {
                case 'typescript':
                    code = `interface ${name} {\n`;
                    break;
                case 'java':
                    code = `public class ${name} {\n`;
                    break;
                case 'python':
                    code = `class ${name}:\n`;
                    break;
                case 'kotlin':
                    code = `data class ${name}(\n`;
                    break;
                case 'rust':
                    code = `pub struct ${name} {\n`;
                    break;
            }

            const indent = lang === 'python' ? '    ' : '  ';

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                const fieldType = inferType(value, lang, key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    switch(lang) {
                        case 'typescript':
                        case 'java':
                        case 'kotlin':
                        case 'rust':
                            code += `${indent}// ${comment}\n`;
                            break;
                        case 'python':
                            code += `${indent}# ${comment}\n`;
                            break;
                    }
                }

                switch(lang) {
                    case 'typescript':
                        code += `${indent}${fieldName}: ${fieldType};\n`;
                        break;
                    case 'java':
                        code += `${indent}private ${fieldType} ${fieldName};\n`;
                        break;
                    case 'python':
                        code += `${indent}${fieldName}: ${fieldType}\n`;
                        break;
                    case 'kotlin':
                        code += `${indent}val ${fieldName}: ${fieldType},\n`;
                        break;
                    case 'rust':
                        code += `${indent}pub ${fieldName}: ${fieldType},\n`;
                        break;
                }
            }

            switch(lang) {
                case 'typescript':
                    code += '}';
                    break;
                case 'java':
                    code += '}';
                    break;
                case 'python':
                    break;
                case 'kotlin':
                    code = code.slice(0, -2) + '\n)';
                    break;
                case 'rust':
                    code = code.slice(0, -2) + '\n}';
                    break;
            }

            return code;
        }

        // Ê∏≤ÊüìÂ∫îÁî®
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    });
</script>
</body>
</html>
