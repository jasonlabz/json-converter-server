<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title>JSON ‚Üí Â§öËØ≠Ë®ÄÁªìÊûÑ‰ΩìÁîüÊàêÂô®</title>

    <!-- ÂõæÊ†áÂ∫ì -->
    <link rel="stylesheet" href="./libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            gap: 16px;
        }

        .header {
            text-align: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .header .subtitle {
            font-size: 14px;
            color: #94a3b8;
            margin-top: 4px;
        }

        .config-panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            padding: 18px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .config-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-group label {
            font-size: 13px;
            font-weight: 500;
            color: #cbd5e1;
            white-space: nowrap;
        }

        .language-select {
            position: relative;
        }

        .language-select select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            min-width: 180px;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
            padding-right: 40px;
        }

        .language-select select:hover {
            border-color: #60a5fa;
            background: #1e293b;
        }

        .language-select select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .language-select::after {
            content: "‚ñº";
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 12px;
            pointer-events: none;
        }

        .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 13px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .go-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            max-width: 400px;
        }

        .tag-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tag-checkbox input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid #475569;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .tag-checkbox input[type="checkbox"]:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .tag-checkbox input[type="checkbox"]:checked::after {
            content: "‚úì";
            position: absolute;
            color: white;
            font-size: 12px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .tag-checkbox label {
            font-size: 13px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(90deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 13px;
        }

        .editor-panels {
            display: flex;
            flex: 1;
            gap: 16px;
            min-height: 0;
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .panel-title i {
            color: #60a5fa;
        }

        .panel-stats {
            font-size: 13px;
            color: #94a3b8;
        }

        .panel-content {
            flex: 1;
            position: relative;
            min-height: 0;
        }

        .json-panel {
            flex: 1;
        }

        .code-panel {
            flex: 1;
            opacity: 1;
            transform: translateX(0);
        }

        .code-panel.hidden {
            display: none;
        }

        .json-panel.full-width {
            flex: 1;
        }

        .json-panel.partial-width {
            flex: 1;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 18px;
            background: rgba(30, 41, 59, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 13px;
            color: #94a3b8;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .language-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .info-icon {
            color: #60a5fa;
            font-size: 14px;
        }

        @media (max-width: 1200px) {
            .config-content {
                flex-direction: column;
                align-items: flex-start;
                gap: 16px;
            }

            .action-buttons {
                margin-left: 0;
                width: 100%;
                justify-content: flex-end;
            }

            .go-tags-container {
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .editor-panels {
                flex-direction: column;
            }

            .panel {
                min-height: 300px;
            }

            .action-buttons {
                gap: 6px;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 13px;
            }
        }

        .error-message {
            color: #f87171;
            font-size: 13px;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .config-row {
            display: flex;
            gap: 24px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .time-type-hint {
            font-size: 11px;
            color: #86efac;
            margin-top: 2px;
            display: inline-block;
        }

        /* JSONÂ∑•ÂÖ∑ÊåâÈíÆÁªÑ */
        .json-tools {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .format-select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-select:hover {
            border-color: #60a5fa;
        }

        .format-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .case-format-select {
            min-width: 120px;
        }

        /* Ê≥®ÈáäÊ†∑Âºè */
        .comment-indicator {
            position: absolute;
            right: 10px;
            top: 10px;
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        /* ÂºÄÂÖ≥Ê†∑Âºè */
        .switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .switch-label {
            font-size: 13px;
            color: #cbd5e1;
            user-select: none;
        }

        .generation-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 12px;
            font-size: 13px;
        }

        .generation-info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .generation-info-item:last-child {
            margin-bottom: 0;
        }

        .generation-info-label {
            color: #94a3b8;
        }

        .generation-info-value {
            color: #60a5fa;
            font-weight: 500;
        }

        .generation-info-compact {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 8px;
        }

        .generation-info-group {
            display: flex;
            gap: 16px;
        }

        .generation-info-stat {
            font-size: 13px;
        }

        .generation-info-stat .label {
            color: #94a3b8;
        }

        .generation-info-stat .value {
            color: #60a5fa;
            font-weight: 500;
            margin-left: 4px;
        }

        .generation-info-stat .value.warning {
            color: #fbbf24;
        }

        .warning-message {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin-top: 12px;
            font-size: 13px;
            color: #fbbf24;
            display: flex;
            align-items: center;
            gap: 8px;
        }
    </style>
</head>
<body>

<div id="root"></div>

<!-- React & ReactDOM -->
<script src="./libs/react/react.development.js"></script>
<script src="./libs/react-dom/react-dom.development.js"></script>

<!-- Monaco Editor -->
<script src="./libs/monaco-editor/min/vs/loader.js"></script>

<script>
    // ÈÖçÁΩÆMonaco EditorË∑ØÂæÑ
    require.config({
        paths: {
            vs: "./libs/monaco-editor/min/vs"
        }
    });

    // Á≠âÂæÖMonacoÂä†ËΩΩÂÆåÊàêÂêéÊâßË°å
    require(["vs/editor/editor.main"], function () {
        const { useState, useEffect, useRef, useCallback } = React;

        // ËØ≠Ë®ÄÈÖçÁΩÆ
        const LANGUAGE_CONFIG = {
            go: {
                name: "Golang",
                icon: "üîµ",
                fileExt: "go",
                monacoLang: "go"
            },
            java: {
                name: "Java",
                icon: "‚òï",
                fileExt: "java",
                monacoLang: "java"
            },
            typescript: {
                name: "TypeScript",
                icon: "üìò",
                fileExt: "ts",
                monacoLang: "typescript"
            },
            python: {
                name: "Python",
                icon: "üêç",
                fileExt: "py",
                monacoLang: "python"
            },
            kotlin: {
                name: "Kotlin",
                icon: "‚ö°",
                fileExt: "kt",
                monacoLang: "kotlin"
            },
            rust: {
                name: "Rust",
                icon: "ü¶Ä",
                fileExt: "rs",
                monacoLang: "rust"
            }
        };

        // Êó∂Èó¥Ê†ºÂºèÊ≠£ÂàôË°®ËææÂºè
        const TIME_PATTERNS = [
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})?$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,
            /^\d{4}-\d{2}-\d{2}$/,
            /^\d{13}$/,
            /^\d{10}$/,
            /(time|date|timestamp|created|updated|start|end|at)$/i
        ];

        // ÈªòËÆ§JSONÔºàÂåÖÂê´Ê≥®ÈáäÔºâ
        const DEFAULT_JSON = `{
  // Áî®Êà∑ID
  "user_id": 12345,
  // Áî®Êà∑Âêç
  "username": "john_doe",
  // ÈÇÆÁÆ±Âú∞ÂùÄ
  "email": "john@example.com",
  // Âπ¥ÈæÑ
  "age": 30,
  // ÊòØÂê¶ÊøÄÊ¥ª
  "is_active": true,
  // ÂàõÂª∫Êó∂Èó¥
  "created_at": "2023-10-01T12:00:00Z",
  // Êõ¥Êñ∞Êó∂Èó¥
  "updated_at": "2023-12-15T08:30:00Z",
  // Âá∫ÁîüÊó•Êúü
  "birth_date": "1993-05-15",
  // ÊúÄÂêéÁôªÂΩïÊó∂Èó¥
  "last_login": "2023-12-15T08:30:00.123Z",
  // ÂÖÉÊï∞ÊçÆ
  "metadata": {
    // Êó∂Èó¥Êà≥
    "timestamp": 1702643400000,
    // ËøáÊúüÊó∂Èó¥
    "expires_at": "2024-12-31 23:59:59"
  },
  // Áî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
  "preferences": {
    "theme": "dark",
    "language": "en"
  },
  // È°πÁõÆÂàóË°®
  "projects": [
    {
      "id": 1,
      "name": "API Gateway",
      "start_date": "2023-01-01",
      "end_date": "2023-12-31"
    }
  ]
}`;

        // Â§çÊùÇJSONÁ§∫‰æã - ÂåÖÂê´‰∏çÂêåÁªìÊûÑÁöÑÊï∞ÁªÑ
        const COMPLEX_JSON = `{
  "Âú∞ÂùÄ": "",
  "doc_url": "http://localhost",
  "docUrl": "http://localhost",
  "int1": 1,
  "int2": 3000000000,
  "float": 1.15,
  "mixed_array": [
    {
      "a3": "123"
    },
    {
      "b3": "",
      "c3": "extra"
    },
    {
      "a3": "456",
      "d3": "test"
    }
  ],
  "a": [
    [
      {
        "a1": {
          "a2": [
            {
              "a3": "123"
            },
            {
              "b3": ""
            }
          ]
        }
      },
      {
        "a1": {
          "a2": [
            {
              "a3": 123
            },
            {
              "c3": ""
            }
          ],
          "b2": ""
        },
        "b1": {
          "b2": ""
        }
      }
    ]
  ]
}`;

        // ÂëΩÂêçÊ†ºÂºèÈÖçÁΩÆ
        const CASE_FORMATS = {
            pascal: {
                name: "Â§ßÈ©ºÂ≥∞ (PascalCase)",
                fn: (str) => str.split(/[_\s-]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('')
            },
            camel: {
                name: "Â∞èÈ©ºÂ≥∞ (camelCase)",
                fn: (str) => {
                    const words = str.split(/[_\s-]+/);
                    return words[0].toLowerCase() + words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');
                }
            },
            snake: {
                name: "‰∏ãÂàíÁ∫ø (snake_case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/-/g, '_')
            },
            kebab: {
                name: "ËøûÂ≠óÁ¨¶ (kebab-case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '').replace(/_/g, '-')
            }
        };

        function App() {
            const [lang, setLang] = useState("go");
            const [goTags, setGoTags] = useState({
                json: true,
                mapstructure: false,
                gorm: false,
                yaml: false,
                xml: false,
                validate: false,
                omitempty: true
            });

            const [structName, setStructName] = useState("Response");
            const [inlineStruct, setInlineStruct] = useState(true);
            const [detectTime, setDetectTime] = useState(true);
            const [includeComments, setIncludeComments] = useState(true);
            const [mergeArrayFields, setMergeArrayFields] = useState(false);
            const [caseFormat, setCaseFormat] = useState("pascal");
            const [isCodeGenMode, setIsCodeGenMode] = useState(true);
            const [jsonText, setJsonText] = useState(DEFAULT_JSON);
            const [generatedCode, setGeneratedCode] = useState("");
            const [error, setError] = useState("");
            const [isGenerating, setIsGenerating] = useState(false);
            const [jsonStats, setJsonStats] = useState({ lines: 0, chars: 0, commentLines: 0 });
            const [codeStats, setCodeStats] = useState({ lines: 0, chars: 0 });
            const [timeFieldsDetected, setTimeFieldsDetected] = useState(0);
            const [generationInfo, setGenerationInfo] = useState(null);

            const jsonEditorRef = useRef(null);
            const jsonEditorInstance = useRef(null);
            const codeEditorRef = useRef(null);
            const codeEditorInstance = useRef(null);

            // Êï∞ÁªÑÂêàÂπ∂Â∑•ÂÖ∑ÂáΩÊï∞
            const mergeArrayItems = useCallback((array) => {
                if (!array || array.length <= 1) return array;
                
                // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÂØπË±°ÈÉΩÊúâÁõ∏ÂêåÁöÑÁªìÊûÑ
                const firstKeys = Object.keys(array[0] || {});
                let allSameStructure = true;
                
                for (let i = 1; i < array.length; i++) {
                    const currentKeys = Object.keys(array[i] || {});
                    if (currentKeys.length !== firstKeys.length || 
                        !currentKeys.every(key => firstKeys.includes(key))) {
                        allSameStructure = false;
                        break;
                    }
                }
                
                if (allSameStructure) return array;
                
                // Êî∂ÈõÜÊâÄÊúâÂèØËÉΩÁöÑÂ≠óÊÆµ
                const allFields = new Set();
                array.forEach(item => {
                    if (item && typeof item === 'object') {
                        Object.keys(item).forEach(key => allFields.add(key));
                    }
                });
                
                // ÂàõÂª∫Êñ∞ÁöÑÊï∞ÁªÑÔºåÁ°Æ‰øùÊØè‰∏™ÂØπË±°ÈÉΩÊúâÊâÄÊúâÂ≠óÊÆµ
                return array.map(item => {
                    const mergedItem = {};
                    allFields.forEach(field => {
                        mergedItem[field] = item && item.hasOwnProperty(field) ? item[field] : '';
                    });
                    return mergedItem;
                });
            }, []);

            // ÂàùÂßãÂåñÁºñËæëÂô®
            useEffect(() => {
                if (!jsonEditorInstance.current && jsonEditorRef.current) {
                    jsonEditorInstance.current = monaco.editor.create(jsonEditorRef.current, {
                        value: DEFAULT_JSON,
                        language: "json",
                        theme: "vs-dark",
                        automaticLayout: true,
                        folding: true,
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 14,
                        lineNumbers: "on",
                        glyphMargin: true,
                        formatOnPaste: true,
                        formatOnType: true,
                        wordWrap: "on"
                    });

                    // ÁõëÂê¨ÂÜÖÂÆπÂèòÂåñ
                    jsonEditorInstance.current.onDidChangeModelContent(() => {
                        const value = jsonEditorInstance.current.getValue();
                        setJsonText(value);

                        // ËÆ°ÁÆóÁªüËÆ°‰ø°ÊÅØ
                        const lines = value.split('\n').length;
                        const chars = value.length;
                        const commentLines = (value.match(/\/\/.*/g) || []).length;
                        setJsonStats({ lines, chars, commentLines });
                    });
                }

                if (!codeEditorInstance.current && codeEditorRef.current) {
                    codeEditorInstance.current = monaco.editor.create(codeEditorRef.current, {
                        value: "// ËØ∑ÂÖàÁîüÊàê‰ª£Á†Å\n// ÁÇπÂáª\"ÁîüÊàê‰ª£Á†Å\"ÊåâÈíÆÂºÄÂßã",
                        language: "go",
                        theme: "vs-dark",
                        readOnly: false,
                        automaticLayout: true,
                        folding: true,
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 14,
                        lineNumbers: "on"
                    });
                }

                return () => {
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }
                };
            }, []);

            // Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®ËØ≠Ë®Ä
            useEffect(() => {
                if (codeEditorInstance.current) {
                    const model = codeEditorInstance.current.getModel();
                    if (model) {
                        monaco.editor.setModelLanguage(model, LANGUAGE_CONFIG[lang].monacoLang);
                    }
                }
            }, [lang]);

            // Â§ÑÁêÜJSONÊ≥®Èáä
            const parseJsonWithComments = useCallback((jsonString) => {
                try {
                    // È¶ñÂÖàÂ∞ùËØï‰ΩøÁî®ÂéüÁîüJSON.parseÔºàÂ§ÑÁêÜÊ≤°ÊúâÊ≥®ÈáäÁöÑÊÉÖÂÜµÔºâ
                    const parsed = JSON.parse(jsonString);
                    return { parsed, comments: { fieldComments: {} } };
                } catch (e) {
                    // Â¶ÇÊûúÂ§±Ë¥•ÔºåÂ∞ùËØïÁßªÈô§Ê≥®ÈáäÂêéËß£Êûê
                    try {
                        // ÁßªÈô§ÂçïË°åÊ≥®Èáä
                        const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                        const parsed = JSON.parse(withoutComments);
                        
                        // ÊèêÂèñÊ≥®Èáä
                        const comments = { fieldComments: {} };
                        const lines = jsonString.split('\n');
                        let currentField = '';
                        
                        lines.forEach((line, index) => {
                            const singleLineCommentMatch = line.match(/\/\/(.*)$/);
                            if (singleLineCommentMatch) {
                                const comment = singleLineCommentMatch[1].trim();
                                if (currentField) {
                                    comments.fieldComments[currentField] = comment;
                                }
                            }
                            
                            // Êü•ÊâæÂ≠óÊÆµÂÆö‰πâ
                            const fieldMatch = line.match(/"([^"]+)":/);
                            if (fieldMatch) {
                                currentField = fieldMatch[1];
                            }
                        });
                        
                        return { parsed, comments };
                    } catch (err) {
                        throw new Error(`JSONËß£ÊûêÂ§±Ë¥•: ${err.message}`);
                    }
                }
            }, []);

            // Ê∏ÖÁêÜJSONÔºöÁßªÈô§Ê≥®ÈáäÂπ∂Ê†ºÂºèÂåñ
            const cleanJson = useCallback((jsonString) => {
                try {
                    // ÁßªÈô§Ê≥®Èáä
                    const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                    // Ëß£ÊûêÂπ∂ÈáçÊñ∞Ê†ºÂºèÂåñ
                    const parsed = JSON.parse(withoutComments);
                    return JSON.stringify(parsed, null, 2);
                } catch (err) {
                    throw new Error(`JSONÊ∏ÖÁêÜÂ§±Ë¥•: ${err.message}`);
                }
            }, []);

            // Ê£ÄÊµãÊó∂Èó¥Â≠óÊÆµ
            const detectTimeFields = useCallback((obj) => {
                let count = 0;

                const traverse = (data) => {
                    if (Array.isArray(data)) {
                        data.forEach(item => {
                            if (item && typeof item === 'object') {
                                traverse(item);
                            }
                        });
                    } else if (data && typeof data === 'object') {
                        Object.entries(data).forEach(([key, value]) => {
                            if (typeof value === 'string' && isTimeString(value)) {
                                count++;
                            }
                            else if (isTimeFieldName(key)) {
                                count++;
                            }
                            if (value && typeof value === 'object') {
                                traverse(value);
                            }
                        });
                    }
                };

                traverse(obj);
                return count;
            }, []);

            // Êî∂ÈõÜÁîüÊàê‰ø°ÊÅØ
            const collectGenerationInfo = useCallback((obj, lang, detectTime, mergeArrayFields) => {
                const info = {
                    totalFields: 0,
                    nestedObjects: 0,
                    arrays: 0,
                    timeFields: 0,
                    maxDepth: 0,
                    mergedArrays: 0,
                    warnings: []
                };

                const traverse = (data, depth = 0) => {
                    info.maxDepth = Math.max(info.maxDepth, depth);
                    
                    if (Array.isArray(data)) {
                        info.arrays++;
                        
                        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂêàÂπ∂
                        if (mergeArrayFields && data.length > 1 && 
                            data.every(item => item && typeof item === 'object')) {
                            
                            // Ê£ÄÊü•Êï∞ÁªÑÂÖÉÁ¥†ÁªìÊûÑÊòØÂê¶‰∏ÄËá¥
                            const firstKeys = Object.keys(data[0] || {});
                            let allSameStructure = true;
                            
                            for (let i = 1; i < data.length; i++) {
                                const currentKeys = Object.keys(data[i] || {});
                                if (currentKeys.length !== firstKeys.length || 
                                    !currentKeys.every(key => firstKeys.includes(key))) {
                                    allSameStructure = false;
                                    break;
                                }
                            }
                            
                            if (!allSameStructure) {
                                info.mergedArrays++;
                            }
                        }
                        
                        if (data.length > 0 && typeof data[0] === 'object') {
                            data.forEach(item => traverse(item, depth + 1));
                        }
                    } else if (data && typeof data === 'object') {
                        info.nestedObjects++;
                        Object.entries(data).forEach(([key, value]) => {
                            info.totalFields++;
                            
                            if (detectTime && isTimeField(key, value)) {
                                info.timeFields++;
                            }
                            
                            if (value && typeof value === 'object') {
                                traverse(value, depth + 1);
                            }
                        });
                    }
                };

                traverse(obj);
                
                // Ê∑ªÂä†Ë≠¶Âëä
                if (info.maxDepth > 5) {
                    info.warnings.push(`JSONÂµåÂ•óÊ∑±Â∫¶ËæÉÊ∑± (${info.maxDepth} Â±Ç)ÔºåÂèØËÉΩÂØºËá¥ÁîüÊàêÁöÑÁªìÊûÑ‰ΩìÂ§çÊùÇ`);
                }
                if (info.arrays > 10) {
                    info.warnings.push(`Êï∞ÁªÑÊï∞ÈáèËæÉÂ§ö (${info.arrays} ‰∏™)ÔºåÂèØËÉΩÂΩ±ÂìçÊÄßËÉΩ`);
                }
                if (info.mergedArrays > 0) {
                    info.warnings.push(`Â∑≤ÂêàÂπ∂ ${info.mergedArrays} ‰∏™Êï∞ÁªÑÁöÑ‰∏çÂêåÁªìÊûÑÂ≠óÊÆµ`);
                }
                
                return info;
            }, []);

            // ÁîüÊàê‰ª£Á†Å
            const generateCode = useCallback(() => {
                setIsGenerating(true);
                setError("");
                setGenerationInfo(null);

                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj, comments } = parseJsonWithComments(jsonValue);

                    // Ê£ÄÊµãÊó∂Èó¥Â≠óÊÆµ
                    const timeFieldsCount = detectTime ? detectTimeFields(obj) : 0;
                    setTimeFieldsDetected(timeFieldsCount);

                    // Êî∂ÈõÜÁîüÊàê‰ø°ÊÅØ
                    const genInfo = collectGenerationInfo(obj, lang, detectTime, mergeArrayFields);
                    setGenerationInfo(genInfo);

                    // Â¶ÇÊûúÈúÄË¶ÅÂêàÂπ∂Êï∞ÁªÑÂ≠óÊÆµÔºåÂÖàÂ§ÑÁêÜÂØπË±°
                    const processObject = (data) => {
                        if (!mergeArrayFields) return data;
                        
                        const process = (item) => {
                            if (Array.isArray(item)) {
                                if (item.length > 0 && typeof item[0] === 'object') {
                                    return mergeArrayItems(item).map(process);
                                }
                                return item;
                            } else if (item && typeof item === 'object') {
                                const result = {};
                                Object.entries(item).forEach(([key, value]) => {
                                    if (Array.isArray(value)) {
                                        result[key] = process(value);
                                    } else if (value && typeof value === 'object') {
                                        result[key] = process(value);
                                    } else {
                                        result[key] = value;
                                    }
                                });
                                return result;
                            }
                            return item;
                        };
                        
                        return process(JSON.parse(JSON.stringify(obj)));
                    };

                    const processedObj = processObject(obj);
                    const code = generateCodeFromObject(
                        processedObj, 
                        lang, 
                        structName, 
                        goTags, 
                        inlineStruct, 
                        detectTime,
                        includeComments ? comments : null,
                        caseFormat
                    );
                    
                    setGeneratedCode(code);

                    // Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®
                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(code);
                        }
                    }

                    // ËÆ°ÁÆóÁªüËÆ°‰ø°ÊÅØ
                    const lines = code.split('\n').length;
                    const chars = code.length;
                    setCodeStats({ lines, chars });

                } catch (err) {
                    const errorMsg = `JSONËß£ÊûêÈîôËØØ: ${err.message}`;
                    setError(errorMsg);

                    const errorCode = `// ${errorMsg}\n// ËØ∑Ê£ÄÊü•JSONÊ†ºÂºèÊòØÂê¶Ê≠£Á°Æ`;
                    setGeneratedCode(errorCode);

                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.setValue(errorCode);
                    }

                    setCodeStats({ lines: 2, chars: errorCode.length });
                    setTimeFieldsDetected(0);
                    setGenerationInfo(null);
                } finally {
                    setIsGenerating(false);
                }
            }, [lang, goTags, structName, inlineStruct, detectTime, jsonText, mergeArrayFields, detectTimeFields, includeComments, caseFormat, parseJsonWithComments, collectGenerationInfo, mergeArrayItems]);

            // JSONÂ∑•ÂÖ∑ÂáΩÊï∞
            const formatJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const formatted = cleanJson(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(formatted);
                    }
                    setJsonText(formatted);
                    setError("");
                    setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
                } catch (err) {
                    setError(`Ê†ºÂºèÂåñÈîôËØØ: ${err.message}`);
                }
            };

            const minifyJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj } = parseJsonWithComments(jsonValue);
                    const minified = JSON.stringify(obj);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(minified);
                    }
                    setJsonText(minified);
                    setError("");
                    setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
                } catch (err) {
                    setError(`ÂéãÁº©ÈîôËØØ: ${err.message}`);
                }
            };

            const escapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const escaped = JSON.stringify(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(escaped);
                    }
                    setJsonText(escaped);
                    setError("");
                    setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
                } catch (err) {
                    setError(`ËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            const unescapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const unescaped = JSON.parse(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(unescaped);
                    }
                    setJsonText(unescaped);
                    setError("");
                    setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
                } catch (err) {
                    setError(`ÂéªËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            const removeComments = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const cleaned = cleanJson(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(cleaned);
                    }
                    setJsonText(cleaned);
                    setError("");
                    setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
                } catch (err) {
                    setError(`ÁßªÈô§Ê≥®ÈáäÈîôËØØ: ${err.message}`);
                }
            };

            const resetJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(DEFAULT_JSON);
                }
                setJsonText(DEFAULT_JSON);
                setError("");
                setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
            };

            const loadComplexJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(COMPLEX_JSON);
                }
                setJsonText(COMPLEX_JSON);
                setError("");
                setGenerationInfo(null); // ÈáçÁΩÆÊó∂‰∏çÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
            };

            // Â§çÂà∂‰ª£Á†ÅÂà∞Ââ™Ë¥¥Êùø
            const copyCode = () => {
                if (generatedCode) {
                    navigator.clipboard.writeText(generatedCode)
                        .then(() => {
                            console.log("‰ª£Á†ÅÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø");
                        })
                        .catch(err => {
                            console.error("Â§çÂà∂Â§±Ë¥•:", err);
                        });
                }
            };

            // ‰∏ãËΩΩ‰ª£Á†Å
            const downloadCode = () => {
                if (!generatedCode) return;

                const blob = new Blob([generatedCode], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${structName}.${LANGUAGE_CONFIG[lang].fileExt}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // Â§ÑÁêÜGoÊ†áÁ≠æÊõ¥Êñ∞
            const updateGoTag = (tag, checked) => {
                setGoTags(prev => ({
                    ...prev,
                    [tag]: checked
                }));
            };

            // ÂàáÊç¢‰ª£Á†ÅÁîüÊàêÊ®°Âºè
            const toggleCodeGenMode = () => {
                setIsCodeGenMode(!isCodeGenMode);
            };

            return React.createElement("div", { className: "app-container" },
                // Â§¥ÈÉ®
                React.createElement("div", { className: "header" },
                    React.createElement("h1", null,
                        React.createElement("i", { className: "fas fa-code" }),
                        "JSON ‚Üí Â§öËØ≠Ë®ÄÁªìÊûÑ‰ΩìÁîüÊàêÂô®"
                    ),
                    React.createElement("div", { className: "subtitle" },
                        "ÊîØÊåÅ Golang, Java, TypeScript, Python, Kotlin, Rust"
                    )
                ),

                // ÈÖçÁΩÆÈù¢Êùø
                React.createElement("div", { className: "config-panel" },
                    React.createElement("div", { className: "config-content" },
                        // Á¨¨‰∏ÄË°åÈÖçÁΩÆ
                        React.createElement("div", { className: "config-row" },
                            // ‰ª£Á†ÅÁîüÊàêÂºÄÂÖ≥
                            React.createElement("div", { className: "config-group" },
                                React.createElement("label", null, "‰ª£Á†ÅÁîüÊàêÊ®°Âºè"),
                                React.createElement("div", { className: "switch-container" },
                                    React.createElement("label", { className: "switch" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            checked: isCodeGenMode,
                                            onChange: toggleCodeGenMode
                                        }),
                                        React.createElement("span", { className: "slider" })
                                    ),
                                    React.createElement("span", { className: "switch-label" },
                                        isCodeGenMode ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"
                                    )
                                )
                            ),

                            // ËØ≠Ë®ÄÈÄâÊã©
                            isCodeGenMode && React.createElement("div", { className: "config-group" },
                                React.createElement("label", { htmlFor: "language-select" }, "ÁõÆÊ†áËØ≠Ë®Ä"),
                                React.createElement("div", { className: "language-select" },
                                    React.createElement("select", {
                                            id: "language-select",
                                            value: lang,
                                            onChange: (e) => setLang(e.target.value)
                                        },
                                        Object.entries(LANGUAGE_CONFIG).map(([value, config]) =>
                                            React.createElement("option", { key: value, value: value },
                                                `${config.icon} ${config.name}`
                                            )
                                        )
                                    )
                                )
                            ),

                            // ÁªìÊûÑ‰ΩìÂêçÁß∞
                            isCodeGenMode && React.createElement("div", { className: "config-group" },
                                React.createElement("label", { htmlFor: "struct-name" }, "ÁªìÊûÑ‰ΩìÂêçÁß∞"),
                                React.createElement("input", {
                                    id: "struct-name",
                                    type: "text",
                                    value: structName,
                                    onChange: (e) => setStructName(e.target.value),
                                    style: {
                                        background: "#1e293b",
                                        color: "#f1f5f9",
                                        border: "1px solid #475569",
                                        padding: "10px 12px",
                                        borderRadius: "8px",
                                        fontSize: "14px",
                                        width: "140px"
                                    }
                                })
                            ),

                            // ÂëΩÂêçÊ†ºÂºè
                            isCodeGenMode && React.createElement("div", { className: "config-group" },
                                React.createElement("label", { htmlFor: "case-format" }, "ÂëΩÂêçÊ†ºÂºè"),
                                React.createElement("select", {
                                        id: "case-format",
                                        className: "format-select case-format-select",
                                        value: caseFormat,
                                        onChange: (e) => setCaseFormat(e.target.value)
                                    },
                                    Object.entries(CASE_FORMATS).map(([value, config]) =>
                                        React.createElement("option", { key: value, value: value },
                                            config.name
                                        )
                                    )
                                )
                            ),

                            // ÈÄöÁî®ÈÄâÈ°π
                            isCodeGenMode && React.createElement("div", { className: "config-group" },
                                React.createElement("label", null, "ÈÄâÈ°π"),
                                React.createElement("div", { className: "checkbox-options" },
                                    React.createElement("div", { className: "checkbox-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "inline-struct",
                                            checked: inlineStruct,
                                            onChange: (e) => setInlineStruct(e.target.checked)
                                        }),
                                        React.createElement("label", { htmlFor: "inline-struct" }, "ÂÜÖËÅîÁªìÊûÑ‰Ωì")
                                    ),
                                    React.createElement("div", { className: "checkbox-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "detect-time",
                                            checked: detectTime,
                                            onChange: (e) => setDetectTime(e.target.checked)
                                        }),
                                        React.createElement("label", { htmlFor: "detect-time" },
                                            "Ê£ÄÊµãÊó∂Èó¥Á±ªÂûã",
                                            detectTime && timeFieldsDetected > 0 &&
                                            React.createElement("span", { className: "time-type-hint" },
                                                `Ê£ÄÊµãÂà∞ ${timeFieldsDetected} ‰∏™Êó∂Èó¥Â≠óÊÆµ`
                                            )
                                        )
                                    ),
                                    React.createElement("div", { className: "checkbox-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "include-comments",
                                            checked: includeComments,
                                            onChange: (e) => setIncludeComments(e.target.checked)
                                        }),
                                        React.createElement("label", { htmlFor: "include-comments" }, "ÂåÖÂê´Ê≥®Èáä")
                                    ),
                                    React.createElement("div", { className: "checkbox-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "merge-array-fields",
                                            checked: mergeArrayFields,
                                            onChange: (e) => setMergeArrayFields(e.target.checked)
                                        }),
                                        React.createElement("label", { htmlFor: "merge-array-fields" }, "ÂêàÂπ∂Êï∞ÁªÑÂ≠óÊÆµ")
                                    )
                                )
                            ),

                            // GoÊ†áÁ≠æÈÄâÈ°π
                            isCodeGenMode && lang === "go" && React.createElement("div", { className: "config-group" },
                                React.createElement("label", null, "GoÊ†áÁ≠æ"),
                                React.createElement("div", { className: "go-tags-container" },
                                    Object.entries(goTags).map(([tag, checked]) =>
                                        React.createElement("div", { className: "tag-checkbox", key: tag },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                id: `tag-${tag}`,
                                                checked: checked,
                                                onChange: (e) => updateGoTag(tag, e.target.checked)
                                            }),
                                            React.createElement("label", { htmlFor: `tag-${tag}` }, tag)
                                        )
                                    )
                                )
                            )
                        ),

                        // Êìç‰ΩúÊåâÈíÆ
                        React.createElement("div", { className: "action-buttons" },
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: formatJson
                                },
                                React.createElement("i", { className: "fas fa-indent" }),
                                "Ê†ºÂºèÂåñ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: removeComments
                                },
                                React.createElement("i", { className: "fas fa-comment-slash" }),
                                "ÂéªÊ≥®Èáä"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: minifyJson
                                },
                                React.createElement("i", { className: "fas fa-compress" }),
                                "ÂéãÁº©"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: escapeJson
                                },
                                React.createElement("i", { className: "fas fa-code" }),
                                "ËΩ¨‰πâ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: unescapeJson
                                },
                                React.createElement("i", { className: "fas fa-code" }),
                                "ÂéªËΩ¨‰πâ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: resetJson
                                },
                                React.createElement("i", { className: "fas fa-redo" }),
                                "ÈáçÁΩÆ"
                            ),
                            React.createElement("button", {
                                    className: "btn btn-secondary",
                                    onClick: loadComplexJson
                                },
                                React.createElement("i", { className: "fas fa-cogs" }),
                                "Â§çÊùÇÁ§∫‰æã"
                            ),
                            isCodeGenMode && React.createElement("button", {
                                    className: "btn btn-primary",
                                    onClick: generateCode,
                                    disabled: isGenerating
                                },
                                isGenerating
                                    ? React.createElement(React.Fragment, null,
                                        React.createElement("i", { className: "fas fa-spinner fa-spin" }),
                                        "ÁîüÊàê‰∏≠..."
                                    )
                                    : React.createElement(React.Fragment, null,
                                        React.createElement("i", { className: "fas fa-bolt" }),
                                        "ÁîüÊàê‰ª£Á†Å"
                                    )
                            )
                        )
                    ),

                    // ÈîôËØØ‰ø°ÊÅØ
                    error && React.createElement("div", { className: "error-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        error
                    ),

                    // ÁîüÊàê‰ø°ÊÅØÔºàÂè™Âú®ÁîüÊàê‰ª£Á†ÅÂêéÊòæÁ§∫Ôºâ
                    generationInfo && React.createElement("div", { className: "generation-info" },
                        React.createElement("div", { className: "generation-info-compact" },
                            React.createElement("div", { className: "generation-info-group" },
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Â≠óÊÆµ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.totalFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂµåÂ•ó: "),
                                    React.createElement("span", { className: "value" }, generationInfo.nestedObjects)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êï∞ÁªÑ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.arrays)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êó∂Èó¥: "),
                                    React.createElement("span", { className: "value" }, generationInfo.timeFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Ê∑±Â∫¶: "),
                                    React.createElement("span", { className: "value" }, generationInfo.maxDepth)
                                ),
                                generationInfo.mergedArrays > 0 && React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂêàÂπ∂: "),
                                    React.createElement("span", { className: "value warning" }, generationInfo.mergedArrays)
                                )
                            )
                        )
                    ),

                    // Ë≠¶Âëä‰ø°ÊÅØ
                    generationInfo && generationInfo.warnings.length > 0 &&
                    React.createElement("div", { className: "warning-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        React.createElement("div", null,
                            generationInfo.warnings.map((warning, index) =>
                                React.createElement("div", { key: index }, warning)
                            )
                        )
                    )
                ),

                // ÁºñËæëÂô®Èù¢Êùø
                React.createElement("div", { className: "editor-panels" },
                    // JSONÁºñËæëÂô®
                    React.createElement("div", { 
                        className: `panel ${isCodeGenMode ? 'json-panel partial-width' : 'json-panel full-width'}` 
                    },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-code" }),
                                "JSON ËæìÂÖ•"
                            ),
                            jsonStats.commentLines > 0 && React.createElement("div", { className: "comment-indicator" },
                                React.createElement("i", { className: "fas fa-comment" }),
                                `${jsonStats.commentLines} Êù°Ê≥®Èáä`
                            ),
                            React.createElement("div", { className: "json-tools" },
                                React.createElement("div", { className: "panel-stats" },
                                    `${jsonStats.lines} Ë°å, ${jsonStats.chars} Â≠óÁ¨¶`
                                )
                            )
                        ),
                        React.createElement("div", {
                            ref: jsonEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // ‰ª£Á†ÅËæìÂá∫
                    isCodeGenMode && React.createElement("div", { className: "panel code-panel" },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-file-code" }),
                                `${LANGUAGE_CONFIG[lang].name} ‰ª£Á†Å`
                            ),
                            React.createElement("div", { className: "panel-stats" },
                                generatedCode
                                    ? `${codeStats.lines} Ë°å, ${codeStats.chars} Â≠óÁ¨¶`
                                    : "Á≠âÂæÖÁîüÊàê‰ª£Á†Å"
                            )
                        ),
                        React.createElement("div", {
                            ref: codeEditorRef,
                            className: "panel-content"
                        })
                    )
                ),

                // Áä∂ÊÄÅÊ†è
                isCodeGenMode && React.createElement("div", { className: "status-bar" },
                    React.createElement("div", { className: "status-item" },
                        React.createElement("div", { className: "language-badge" },
                            React.createElement("i", { className: "fas fa-code" }),
                            LANGUAGE_CONFIG[lang].name
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "8px",
                                    fontSize: "12px",
                                    color: inlineStruct ? "#86efac" : "#fbbf24"
                                }
                            },
                            inlineStruct ? "ÂÜÖËÅîÊ®°Âºè" : "ÊãÜÂàÜÊ®°Âºè"
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "8px",
                                    fontSize: "12px",
                                    color: includeComments ? "#86efac" : "#94a3b8"
                                }
                            },
                            includeComments ? "Âê´Ê≥®Èáä" : "Êó†Ê≥®Èáä"
                        ),
                        detectTime && timeFieldsDetected > 0 &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "8px",
                                    fontSize: "12px",
                                    color: "#60a5fa"
                                }
                            },
                            `Êó∂Èó¥Â≠óÊÆµ: ${timeFieldsDetected}`
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("i", { className: "fas fa-info-circle info-icon" }),
                        React.createElement("span", null,
                            CASE_FORMATS[caseFormat]?.name || "Â§ßÈ©ºÂ≥∞ (PascalCase)"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: copyCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-copy" }),
                            "Â§çÂà∂"
                        ),
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: downloadCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-download" }),
                            "‰∏ãËΩΩ"
                        )
                    )
                )
            );
        }

        // Âà§Êñ≠ÊòØÂê¶‰∏∫Êó∂Èó¥Â≠óÁ¨¶‰∏≤
        function isTimeString(value) {
            return TIME_PATTERNS.some(pattern => pattern.test(value));
        }

        // Âà§Êñ≠Â≠óÊÆµÂêçÊòØÂê¶‰∏∫Êó∂Èó¥Â≠óÊÆµ
        function isTimeFieldName(fieldName) {
            return /(time|date|timestamp|created|updated|start|end|at)$/i.test(fieldName);
        }

        // Âà§Êñ≠ÊòØÂê¶‰∏∫Êó∂Èó¥Â≠óÊÆµÔºàÂÄºÂíåÂêçÁß∞ÈÉΩÊ£ÄÊü•Ôºâ
        function isTimeField(key, value) {
            if (typeof value === 'string' && isTimeString(value)) {
                return true;
            }
            if (isTimeFieldName(key)) {
                return true;
            }
            return false;
        }

        // Ëé∑ÂèñÊó∂Èó¥Á±ªÂûãÔºàÊ†πÊçÆËØ≠Ë®ÄÔºâ
        function getTimeType(lang) {
            switch(lang) {
                case 'go': return 'time.Time';
                case 'java': return 'java.time.LocalDateTime';
                case 'typescript': return 'Date';
                case 'python': return 'datetime.datetime';
                case 'kotlin': return 'java.time.LocalDateTime';
                case 'rust': return 'chrono::DateTime<chrono::Utc>';
                default: return 'string';
            }
        }

        // Ê†ºÂºèÂåñÂ≠óÊÆµÂêç
        function formatFieldName(name, format, lang, isStructName = false) {
            if (!name || name.trim() === '') return name;
            
            // ÁâπÊÆäÂ≠óÁ¨¶Â§ÑÁêÜÔºöÁßªÈô§ÁâπÊÆäÂ≠óÁ¨¶Ôºå‰øùÁïôÂ≠óÊØçÊï∞Â≠óÂíå‰∏ãÂàíÁ∫ø
            let cleaned = name.replace(/[^a-zA-Z0-9_\u4e00-\u9fa5]/g, '_');
            
            // Â§ÑÁêÜ‰∏≠ÊñáÔºöËΩ¨Êç¢‰∏∫ÊãºÈü≥Êàñ‰øùÁïô
            const hasChinese = /[\u4e00-\u9fa5]/.test(cleaned);
            if (hasChinese) {
                // ÁÆÄÂçïÁöÑ‰∏≠ÊñáÂ§ÑÁêÜÔºöÂú®‰∏≠ÊñáÂâçÂä†‰∏ãÂàíÁ∫øÊàñÁßªÈô§
                cleaned = cleaned.replace(/[\u4e00-\u9fa5]+/g, (match) => {
                    // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÊãºÈü≥ËΩ¨Êç¢ÈÄªËæë
                    return 'field';
                });
            }
            
            let formatted;
            if (CASE_FORMATS[format]) {
                formatted = CASE_FORMATS[format].fn(cleaned);
            } else {
                formatted = cleaned;
            }

            // ÂØπ‰∫éGoËØ≠Ë®ÄÁöÑÁªìÊûÑ‰ΩìÂêçÔºåÁ°Æ‰øùÈ¶ñÂ≠óÊØçÂ§ßÂÜô
            if (lang === 'go' && isStructName) {
                formatted = formatted.charAt(0).toUpperCase() + formatted.slice(1);
            }
            
            // Á°Æ‰øù‰∏ç‰ª•Êï∞Â≠óÂºÄÂ§¥
            if (/^\d/.test(formatted)) {
                formatted = 'field' + formatted;
            }

            return formatted;
        }

        // ‰ª£Á†ÅÁîüÊàêÂáΩÊï∞
        function generateCodeFromObject(obj, lang, structName, goTags, inlineStruct, detectTime, comments, caseFormat) {
            const formatName = (name, isStructName = false) => 
                formatFieldName(name, caseFormat, lang, isStructName);

            if (lang === "go") return genGo(obj, formatName(structName, true), goTags, inlineStruct, detectTime, comments, formatName);
            if (lang === "typescript") return genTypeScript(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "java") return genJava(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "python") return genPython(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "kotlin") return genKotlin(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "rust") return genRust(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            return `// ‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä: ${lang}`;
        }

        // Â¢ûÂº∫ÁöÑÁ±ªÂûãÊé®Êñ≠ËæÖÂä©ÂáΩÊï∞
        function inferType(value, lang, key = '', detectTime = false, parentPath = '') {
            // Ê£ÄÊü•ÊòØÂê¶‰∏∫Êó∂Èó¥Â≠óÊÆµ
            if (detectTime && isTimeField(key, value)) {
                return getTimeType(lang);
            }

            if (value === null) {
                if (lang === "typescript") return "null";
                if (lang === "java") return "Object";
                if (lang === "kotlin") return "Any?";
                if (lang === "rust") return "Option<serde_json::Value>";
                return "any";
            }

            if (Array.isArray(value)) {
                if (value.length === 0) {
                    // Á©∫Êï∞ÁªÑ
                    if (lang === "go") return "[]interface{}";
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                // Ê£ÄÊü•Êï∞ÁªÑÂÖÉÁ¥†Á±ªÂûãÊòØÂê¶‰∏ÄËá¥
                const firstItem = value[0];
                let allSameType = true;
                
                for (let i = 1; i < Math.min(value.length, 5); i++) {
                    if (typeof value[i] !== typeof firstItem) {
                        allSameType = false;
                        break;
                    }
                }
                
                if (allSameType) {
                    const itemType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                    if (lang === "go") return `[]${itemType}`;
                    if (lang === "typescript") return `${itemType}[]`;
                    if (lang === "java") return `List<${itemType}>`;
                    if (lang === "kotlin") return `List<${itemType}>`;
                    if (lang === "rust") return `Vec<${itemType}>`;
                    if (lang === "python") return `List[${itemType}]`;
                } else {
                    // Ê∑∑ÂêàÁ±ªÂûãÊï∞ÁªÑ
                    if (lang === "go") return "[]interface{}";
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }
            }

            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                // ÂØπË±°Á±ªÂûã
                if (Object.keys(value).length === 0) {
                    // Á©∫ÂØπË±°
                    if (lang === "go") return "map[string]interface{}";
                    if (lang === "typescript") return "Record<string, any>";
                    if (lang === "java") return "Map<String, Object>";
                    if (lang === "kotlin") return "Map<String, Any?>";
                    if (lang === "rust") return "HashMap<String, serde_json::Value>";
                    if (lang === "python") return "Dict[str, Any]";
                } else {
                    if (lang === "go") return "struct";
                    if (lang === "typescript") return "any";
                    if (lang === "java") return "Object";
                    if (lang === "kotlin") return "Any?";
                    if (lang === "rust") return "serde_json::Value";
                    if (lang === "python") return "dict";
                }
            }

            switch (typeof value) {
                case "number":
                    if (Number.isInteger(value)) {
                        // Â§ßÊï¥Êï∞Ê£ÄÊü•
                        if (value > 2147483647 || value < -2147483648) {
                            if (lang === "go") return "int64";
                            if (lang === "java") return "Long";
                            if (lang === "kotlin") return "Long";
                            if (lang === "rust") return "i64";
                        } else {
                            if (lang === "go") return "int";
                            if (lang === "typescript") return "number";
                            if (lang === "java") return "Integer";
                            if (lang === "kotlin") return "Int";
                            if (lang === "rust") return "i32";
                            if (lang === "python") return "int";
                        }
                    } else {
                        if (lang === "go") return "float64";
                        if (lang === "typescript") return "number";
                        if (lang === "java") return "Double";
                        if (lang === "kotlin") return "Double";
                        if (lang === "rust") return "f64";
                        if (lang === "python") return "float";
                    }
                    break;
                case "string":
                    if (lang === "go") return "string";
                    if (lang === "typescript") return "string";
                    if (lang === "java") return "String";
                    if (lang === "kotlin") return "String";
                    if (lang === "rust") return "String";
                    if (lang === "python") return "str";
                    break;
                case "boolean":
                    if (lang === "go") return "bool";
                    if (lang === "typescript") return "boolean";
                    if (lang === "java") return "Boolean";
                    if (lang === "kotlin") return "Boolean";
                    if (lang === "rust") return "bool";
                    if (lang === "python") return "bool";
                    break;
            }

            return "any";
        }

        // ÁîüÊàêGo‰ª£Á†Å
        function genGo(obj, name, tags, inlineStruct, detectTime, comments, formatName) {
            let allStructs = {};
            let mainStructCode = "";

            // ÁîüÊàê‰∏ªÁªìÊûÑ‰Ωì
            mainStructCode = genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs, 0, comments, formatName);

            // ÊûÑÂª∫ÂÆåÊï¥‰ª£Á†Å
            let code = "";

            // Ê∑ªÂä†Ê≥®Èáä
            if (comments && comments.fieldComments[name]) {
                code += `// ${comments.fieldComments[name]}\n`;
            }

            // Â¶ÇÊûúÈúÄË¶ÅÂØºÂÖ•timeÂåÖ
            let hasTimeField = false;
            const checkTimeField = (obj) => {
                for (const [key, value] of Object.entries(obj)) {
                    if (detectTime && isTimeField(key, value)) {
                        return true;
                    }
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        if (checkTimeField(value)) return true;
                    } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        if (checkTimeField(value[0])) return true;
                    }
                }
                return false;
            };
            hasTimeField = checkTimeField(obj);

            if (hasTimeField) {
                code = "import \"time\"\n\n" + code;
            }

            // Â¶ÇÊûú‰ΩøÁî®ÊãÜÂàÜÊ®°Âºè‰∏îÊúâÂµåÂ•óÁªìÊûÑ‰ΩìÔºåÂÖàËæìÂá∫ÂµåÂ•óÁªìÊûÑ‰Ωì
            if (!inlineStruct) {
                for (const [structName, structCode] of Object.entries(allStructs)) {
                    if (structName !== name) {
                        code += structCode + "\n\n";
                    }
                }
            }

            // Ê∑ªÂä†‰∏ªÁªìÊûÑ‰Ωì
            code += mainStructCode;

            return code;
        }

        // ÈÄíÂΩíÁîüÊàêGoÁªìÊûÑ‰Ωì - Â§ÑÁêÜÂ§çÊùÇÂµåÂ•ó
        function genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs = {}, depth = 0, comments, formatName, path = '') {
            // Èò≤Ê≠¢Êó†ÈôêÈÄíÂΩí
            if (depth > 20) {
                return `type ${name} struct {\n  // ÂµåÂ•óÊ∑±Â∫¶ËøáÂ§ßÔºåÂª∫ËÆÆÁÆÄÂåñJSONÁªìÊûÑ\n  Data map[string]interface{} \`json:"data"\`\n}`;
            }

            let code = `type ${name} struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);

                // Ê∑ªÂä†Â≠óÊÆµÊ≥®Èáä
                const comment = comments ? comments.fieldComments[key] : null;
                if (comment) {
                    code += `  // ${comment}\n`;
                }

                // ÊûÑÂª∫Ê†áÁ≠æ
                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }
                if (tags.gorm) {
                    tagParts.push(`gorm:"column:${key}"`);
                }
                if (tags.yaml) {
                    tagParts.push(`yaml:"${key}"`);
                }
                if (tags.xml) {
                    tagParts.push(`xml:"${key}"`);
                }
                if (tags.validate) {
                    const validateRules = [];
                    if (typeof value === "string") {
                        if (value.includes("@")) validateRules.push("email");
                        if (key.toLowerCase().includes("url")) validateRules.push("url");
                    }
                    if (typeof value === "number") validateRules.push("numeric");
                    if (validateRules.length > 0) {
                        tagParts.push(`validate:"${validateRules.join(",")}"`);
                    }
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                // Â§ÑÁêÜÂµåÂ•óÂØπË±°
                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                    const nestedStructName = formatName(key, true);
                    
                    if (Object.keys(value).length === 0) {
                        // Á©∫ÂØπË±°Ôºå‰ΩøÁî®map
                        code += `  ${fieldName} map[string]interface{}${tagStr}\n`;
                    } else if (inlineStruct) {
                        // ÂÜÖËÅîÊ®°ÂºèÔºöÁîüÊàêÂµåÂ•óÁªìÊûÑ‰Ωì
                        code += `  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                    } else {
                        // ÊãÜÂàÜÊ®°ÂºèÔºöÂºïÁî®Áã¨Á´ãÁªìÊûÑ‰Ωì
                        code += `  ${fieldName} ${nestedStructName}${tagStr}\n`;

                        // Â¶ÇÊûúËøòÊ≤°ÊúâÁîüÊàêËøô‰∏™ÂµåÂ•óÁªìÊûÑ‰ΩìÔºåÂÖàÁîüÊàê
                        if (!allStructs[nestedStructName]) {
                            allStructs[nestedStructName] = genGoStruct(value, nestedStructName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                        }
                    }
                }
                // Â§ÑÁêÜÊï∞ÁªÑ
                else if (Array.isArray(value)) {
                    if (value.length === 0) {
                        // Á©∫Êï∞ÁªÑ
                        code += `  ${fieldName} []interface{}${tagStr}\n`;
                    } else {
                        const firstItem = value[0];
                        
                        // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                        if (Array.isArray(firstItem)) {
                            // ‰∫åÁª¥Êï∞ÁªÑ
                            code += `  ${fieldName} [][]interface{}${tagStr}\n`;
                        } else if (typeof firstItem === "object" && firstItem !== null) {
                            // ÂØπË±°Êï∞ÁªÑ
                            const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);
                            
                            if (inlineStruct) {
                                // ÂÜÖËÅîÊ®°ÂºèÔºöÁîüÊàêÂµåÂ•óÁªìÊûÑ‰Ωì
                                code += `  ${fieldName} []${genGoInlineStruct(firstItem, itemTypeName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                            } else {
                                // ÊãÜÂàÜÊ®°ÂºèÔºöÂºïÁî®Áã¨Á´ãÁªìÊûÑ‰Ωì
                                code += `  ${fieldName} []${itemTypeName}${tagStr}\n`;

                                // Â¶ÇÊûúËøòÊ≤°ÊúâÁîüÊàêËøô‰∏™ÂµåÂ•óÁªìÊûÑ‰ΩìÔºåÂÖàÁîüÊàê
                                if (!allStructs[itemTypeName]) {
                                    allStructs[itemTypeName] = genGoStruct(firstItem, itemTypeName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                }
                            }
                        } else {
                            // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                            const itemType = inferType(firstItem, "go", key, detectTime, currentPath);
                            code += `  ${fieldName} []${itemType}${tagStr}\n`;
                        }
                    }
                } else {
                    // Âü∫Êú¨Á±ªÂûã
                    code += `  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += "}";

            // ‰øùÂ≠òÂà∞ÊâÄÊúâÁªìÊûÑ‰ΩìÈõÜÂêà‰∏≠
            if (!allStructs[name]) {
                allStructs[name] = code;
            }

            return code;
        }

        // ÁîüÊàêÂÜÖËÅîÁöÑGoÁªìÊûÑ‰ΩìÔºàÁî®‰∫éÂÜÖËÅîÊ®°ÂºèÔºâ
        function genGoInlineStruct(obj, name, tags, detectTime, depth, comments, formatName, path) {
            let indent = "  ".repeat(depth);
            let code = `${indent}struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                // Ê∑ªÂä†Â≠óÊÆµÊ≥®Èáä
                if (comment) {
                    code += `${indent}  // ${comment}\n`;
                }

                // ÊûÑÂª∫Ê†áÁ≠æ
                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                // Â§ÑÁêÜÂµåÂ•óÂØπË±°ÔºàÈÄíÂΩíÂÜÖËÅîÔºâ
                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                    const nestedStructName = formatName(key, true);
                    code += `${indent}  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object") {
                    // ÂØπË±°Êï∞ÁªÑ
                    const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);
                    code += `${indent}  ${fieldName} []${itemTypeName}${tagStr}\n`;
                } else {
                    code += `${indent}  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += `${indent}}`;
            return code;
        }

        // ÁîüÊàêÂÖ∂‰ªñËØ≠Ë®Ä‰ª£Á†ÅÁöÑÂáΩÊï∞ÔºàÂ∑≤ÁÆÄÂåñÔºåÂÆûÈôÖÈ°πÁõÆ‰∏≠ÈúÄË¶ÅÂÆåÊï¥ÂÆûÁé∞Ôºâ
        function genTypeScript(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "typescript", inlineStruct, detectTime, comments, formatName);
        }

        function genJava(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "java", inlineStruct, detectTime, comments, formatName);
        }

        function genPython(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "python", inlineStruct, detectTime, comments, formatName);
        }

        function genKotlin(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "kotlin", inlineStruct, detectTime, comments, formatName);
        }

        function genRust(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "rust", inlineStruct, detectTime, comments, formatName);
        }

        // ÈÄöÁî®‰ª£Á†ÅÁîüÊàêÂáΩÊï∞
        function generateGenericCode(obj, name, lang, inlineStruct, detectTime, comments, formatName, depth = 0, path = '') {
            if (depth > 10) {
                return `// ÁªìÊûÑÂµåÂ•óËøáÊ∑±ÔºåÂª∫ËÆÆÁÆÄÂåñJSON\n// ${name} Á±ªÂûãÂÆö‰πâ`;
            }

            let code = '';
            
            switch(lang) {
                case 'typescript':
                    code = `interface ${name} {\n`;
                    break;
                case 'java':
                    code = `public class ${name} {\n`;
                    break;
                case 'python':
                    code = `class ${name}:\n`;
                    break;
                case 'kotlin':
                    code = `data class ${name}(\n`;
                    break;
                case 'rust':
                    code = `pub struct ${name} {\n`;
                    break;
            }

            const indent = lang === 'python' ? '    ' : '  ';
            
            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                const fieldType = inferType(value, lang, key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                // Ê∑ªÂä†Ê≥®Èáä
                if (comment) {
                    switch(lang) {
                        case 'typescript':
                        case 'java':
                        case 'kotlin':
                        case 'rust':
                            code += `${indent}// ${comment}\n`;
                            break;
                        case 'python':
                            code += `${indent}# ${comment}\n`;
                            break;
                    }
                }

                // ÁîüÊàêÂ≠óÊÆµÂÆö‰πâ
                switch(lang) {
                    case 'typescript':
                        code += `${indent}${fieldName}: ${fieldType};\n`;
                        break;
                    case 'java':
                        code += `${indent}private ${fieldType} ${fieldName};\n`;
                        break;
                    case 'python':
                        code += `${indent}${fieldName}: ${fieldType}\n`;
                        break;
                    case 'kotlin':
                        code += `${indent}val ${fieldName}: ${fieldType},\n`;
                        break;
                    case 'rust':
                        code += `${indent}pub ${fieldName}: ${fieldType},\n`;
                        break;
                }
            }

            switch(lang) {
                case 'typescript':
                    code += '}';
                    break;
                case 'java':
                    code += '}';
                    break;
                case 'python':
                    // Python class ‰∏çÈúÄË¶ÅÈ¢ùÂ§ñÈó≠Âêà
                    break;
                case 'kotlin':
                    code = code.slice(0, -2) + '\n)'; // ÁßªÈô§ÊúÄÂêéÁöÑÈÄóÂè∑
                    break;
                case 'rust':
                    code = code.slice(0, -2) + '\n}'; // ÁßªÈô§ÊúÄÂêéÁöÑÈÄóÂè∑
                    break;
            }

            return code;
        }

        // Ê∏≤ÊüìÂ∫îÁî®
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    });
</script>
</body>
</html>