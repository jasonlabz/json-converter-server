<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title> JSON Â∑•ÂÖ∑</title>

    <!-- Ê∑ªÂä†ÁΩëÁ´ôÂõæÊ†á -->
    <!--    <link rel="icon" href="./libs/icon/o-json.png" type="image/x-icon">-->
    <link rel="icon" href="./libs/icon/json.png" type="image/x-icon">
    <link rel="stylesheet" href="./libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* CSSÊ†∑ÂºèÔºàÂåÖÂê´‰øÆÂ§çÔºâ */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 12px;
            gap: 12px;
        }

        .header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 4px;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .header .subtitle {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 2px;
        }

        .config-panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 10px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .config-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-row {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .code-gen-config {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .compact-group {
            margin-bottom: 0;
        }

        .compact-group label {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .language-select {
            position: relative;
        }

        .language-select select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 8px 12px;
            padding-right: 32px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            min-width: 120px;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
        }

        .compact-select {
            padding: 6px 10px;
            min-width: 100px;
            font-size: 12px;
        }

        .language-select select:hover {
            border-color: #60a5fa;
            background: #1e293b;
        }

        .language-select select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .language-select::after {
            content: "‚ñº";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 10px;
            pointer-events: none;
        }

        .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .compact-options {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .compact-item {
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 12px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-item label {
            font-size: 11px;
            min-width: 32px;
        }

        .go-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-width: 300px;
        }

        .compact-tags {
            gap: 6px;
            max-width: 280px;
        }

        .tag-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .compact-tag {
            gap: 3px;
        }

        .tag-checkbox input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .compact-tag input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        .tag-checkbox input[type="checkbox"]:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .tag-checkbox input[type="checkbox"]:checked::after {
            content: "‚úì";
            position: absolute;
            color: white;
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .tag-checkbox label {
            font-size: 11px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-tag label {
            font-size: 10px;
            padding: 1px 3px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 0;
        }

        .compact-actions {
            gap: 6px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }

        /* ÂÜÖËÅîÂºÄÂÖ≥Ê†∑Âºè */
        .mode-switch-inline {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-switch-inline .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 18px;
            margin: 0;
        }

        .mode-switch-inline .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-switch-inline .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 18px;
        }

        .mode-switch-inline .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .mode-switch-inline input:checked + .slider {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
        }

        .mode-switch-inline input:checked + .slider:before {
            transform: translateX(18px);
        }

        .mode-switch-inline .switch-label {
            font-size: 12px;
            color: #cbd5e1;
            user-select: none;
            white-space: nowrap;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 90px;
            justify-content: center;
        }

        .btn-compact {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 80px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(90deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .editor-panels {
            display: flex;
            flex: 1;
            gap: 12px;
            min-height: 0;
            height: calc(100vh - 240px);
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            height: 100%;
            transition: all 0.3s ease;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            min-height: 40px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .panel-title i {
            color: #60a5fa;
            font-size: 14px;
        }

        .panel-stats {
            font-size: 11px;
            color: #94a3b8;
        }

        .panel-content {
            flex: 1;
            position: relative;
            min-height: 300px;
            overflow: hidden;
        }

        .panel-tabs {
            display: flex;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding: 4px 8px;
        }

        .panel-tab {
            padding: 6px 12px;
            font-size: 12px;
            color: #94a3b8;
            background: none;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .panel-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #f1f5f9;
        }

        .panel-tab.active {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .panel-tab + .panel-tab {
            margin-left: 4px;
        }

        .json-panel {
            flex: 1;
        }

        .code-panel {
            flex: 1;
            opacity: 1;
            transform: translateX(0);
        }

        /* ‰øÆÂ§çÔºö‰ΩøÁî®CSSÁ±ªÊéßÂà∂ÈöêËóè */
        .code-panel.hidden {
            display: none !important;
            flex: 0;
            width: 0;
            min-width: 0;
        }

        .json-panel.full-width {
            flex: 1;
            width: 100%;
        }

        .json-panel.partial-width {
            flex: 1;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 12px;
            color: #94a3b8;
            min-height: 36px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .language-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .info-icon {
            color: #60a5fa;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            .config-row {
                gap: 12px;
            }

            .compact-group {
                min-width: 100px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 8px;
                gap: 8px;
            }

            .header h1 {
                font-size: 18px;
            }

            .editor-panels {
                flex-direction: column;
                height: auto;
            }

            .panel {
                min-height: 300px;
            }

            .config-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .mode-switch-inline {
                order: -1;
                width: 100%;
                justify-content: center;
                margin-right: 0;
                margin-bottom: 8px;
            }

            .compact-actions {
                justify-content: center;
            }

            .compact-group {
                width: 100%;
            }

            .compact-input {
                width: 100%;
            }

            .compact-select {
                width: 100%;
            }

            .compact-actions {
                flex-wrap: wrap;
                justify-content: center;
            }

            .btn-compact {
                flex: 1;
                min-width: 60px;
                padding: 5px 8px;
                font-size: 11px;
            }

            .code-gen-config {
                padding-top: 8px;
                margin-top: 8px;
            }
        }

        .error-message {
            color: #f87171;
            font-size: 12px;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .time-type-hint {
            font-size: 10px;
            color: #86efac;
            margin-top: 2px;
            display: inline-block;
        }

        /* JSONÂ∑•ÂÖ∑ÊåâÈíÆÁªÑ */
        .json-tools {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        /* HeaderÊ†èÂÜÖÂÆπÂ∏ÉÂ±Ä */
        .panel-header-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        /* HeaderÊ†èÊ†ºÂºèËΩ¨Êç¢Â∑•ÂÖ∑ */
        .header-conversion-tools {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 6px;
            padding: 4px 8px;
        }

        .header-conversion-tools .format-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 3px 6px;
            height: 24px;
        }

        .header-conversion-tools .btn-sm {
            padding: 3px 6px;
            height: 24px;
            min-width: 24px;
        }

        .format-select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-select:hover {
            border-color: #60a5fa;
        }

        .format-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .case-format-select {
            min-width: 100px;
        }

        /* Ê≥®ÈáäÊ†∑Âºè */
        .comment-indicator {
            position: absolute;
            right: 8px;
            top: 8px;
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .generation-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
        }

        .generation-info-compact {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 6px;
        }

        .generation-info-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .generation-info-stat {
            font-size: 11px;
        }

        .generation-info-stat .label {
            color: #94a3b8;
        }

        .generation-info-stat .value {
            color: #60a5fa;
            font-weight: 500;
            margin-left: 2px;
        }

        .generation-info-stat .value.warning {
            color: #fbbf24;
        }

        .warning-message {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #fbbf24;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* ËæìÂÖ•Ê°ÜÊ†∑Âºè */
        .compact-input {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 6px 8px;
            border-radius: 5px;
            font-size: 12px;
            width: 100px;
            outline: none;
            transition: all 0.2s;
        }

        .compact-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* ÊäòÂè†Âå∫ÂüüÊ†∑Âºè */
        .fold-widget {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* Á°Æ‰øùÁºñËæëÂô®ÊúâË∂≥Â§üÈ´òÂ∫¶ */
        .monaco-editor {
            height: 100% !important;
        }

        /* Êñ∞Â¢ûÔºöÈîôËØØË°åÊ†áËÆ∞ */
        .error-line {
            background-color: rgba(248, 113, 113, 0.2) !important;
        }

        .error-gutter {
            background-color: rgba(248, 113, 113, 0.4) !important;
            color: #f87171 !important;
        }

        /* Êñ∞Â¢ûÔºö‰∏≠ÊñáËΩ¨Á†ÅÁõ∏ÂÖ≥Ê†∑Âºè */
        .unicode-preview {
            font-size: 10px;
            color: #86efac;
            margin-top: 2px;
            font-family: monospace;
        }

        /* Ê†ºÂºèÂåñÈîôËØØÊèêÁ§∫ */
        .format-error-details {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid rgba(248, 113, 113, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #f87171;
        }

        .format-error-line {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px solid rgba(248, 113, 113, 0.1);
        }

        .format-error-line:last-child {
            border-bottom: none;
        }

        /* Êñ∞Â¢ûÔºöÂØπÊØîÊ®°ÂºèÊ†∑Âºè */
        .diff-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .diff-editor-container {
            flex: 1;
            display: flex;
            gap: 12px;
        }

        /* ÈúÄÊ±Ç2ÔºöÂØπÊØîÊ®°ÂºèÂ∏ÉÂ±ÄÂÆπÂô® */
        .diff-layout {
            display: flex;
            height: 100%;
            align-items: stretch;
            width: 100%;
            overflow: hidden;
        }

        .diff-side {
            flex: 1; /* ÈªòËÆ§flexÔºå‰ºöË¢´styleË¶ÜÁõñ */
            display: flex;
            flex-direction: column;
            border: 1px solid #334155;
            border-radius: 6px;
            overflow: hidden;
            background: #1e293b;
            height: 100%;
            min-width: 0; /* Èò≤Ê≠¢ÂÜÖÂÆπÊíëÂºÄ */
        }

        /* ÈúÄÊ±Ç2ÔºöÁªàÁ´ØÊ†∑ÂºèÂ∑ÆÂºÇ‰ø°ÊÅØÊ°Ü */
        .diff-info-panel {
            background: #000000;
            border: 1px solid #334155;
            border-radius: 6px;
            /* ÁßªÈô§marginÈò≤Ê≠¢Ê∫¢Âá∫ */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        .terminal-header {
            background: #1e293b;
            padding: 6px 10px;
            border-bottom: 1px solid #334155;
            font-size: 12px;
            color: #94a3b8;
            display: flex;
            align-items: center;
        }

        .terminal-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .terminal-content {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            color: #e2e8f0;
            font-size: 13px;
        }

        .diff-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
            height: 40px;
        }

        .diff-title {
            font-size: 13px;
            font-weight: 500;
            color: #f1f5f9;
        }

        .diff-content {
            flex: 1;
            position: relative;
            min-height: 300px;
        }

        /* Ê†ºÂºèÈÄâÊã©Âô®Ê†∑Âºè */
        .format-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .format-selector label {
            font-size: 11px;
            color: #94a3b8;
        }

        .format-selector select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        /* Â∑ÆÂºÇÈ´ò‰∫ÆÊ†∑Âºè */
        .diff-added {
            background-color: rgba(34, 197, 94, 0.2) !important;
        }

        .diff-removed {
            background-color: rgba(239, 68, 68, 0.2) !important;
        }

        .diff-modified {
            background-color: rgba(251, 191, 36, 0.2) !important;
        }

        .diff-result {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
            color: #60a5fa;
        }

        .diff-stat {
            display: flex;
            gap: 16px;
        }

        .diff-stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .diff-stat-added {
            color: #22c55e;
        }

        .diff-stat-removed {
            color: #ef4444;
        }

        .diff-stat-modified {
            color: #fbbf24;
        }
    </style>
</head>
<body>

<div id="root"></div>

<!-- React & ReactDOM -->
<script src="./libs/react/react.development.js"></script>
<script src="./libs/react-dom/react-dom.development.js"></script>

<!-- Monaco Editor -->
<script src="./libs/monaco-editor/min/vs/loader.js"></script>

<script>
    // ÈÖçÁΩÆMonaco EditorË∑ØÂæÑ
    require.config({
        paths: {
            vs: "./libs/monaco-editor/min/vs"
        }
    });

    // Á≠âÂæÖMonacoÂä†ËΩΩÂÆåÊàêÂêéÊâßË°å
    require(["vs/editor/editor.main"], function () {
        const { useState, useEffect, useRef, useCallback } = React;

        // ËØ≠Ë®ÄÈÖçÁΩÆ
        const LANGUAGE_CONFIG = {
            go: {
                name: "Golang",
                icon: "üîµ",
                fileExt: "go",
                monacoLang: "go"
            },
            java: {
                name: "Java",
                icon: "‚òï",
                fileExt: "java",
                monacoLang: "java"
            },
            typescript: {
                name: "TypeScript",
                icon: "üìò",
                fileExt: "ts",
                monacoLang: "typescript"
            },
            python: {
                name: "Python",
                icon: "üêç",
                fileExt: "py",
                monacoLang: "python"
            },
            kotlin: {
                name: "Kotlin",
                icon: "‚ö°",
                fileExt: "kt",
                monacoLang: "kotlin"
            },
            rust: {
                name: "Rust",
                icon: "ü¶Ä",
                fileExt: "rs",
                monacoLang: "rust"
            }
        };

        // Êó∂Èó¥Ê†ºÂºèÊ≠£ÂàôË°®ËææÂºè
        const TIME_PATTERNS = [
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})?$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,
            /^\d{4}-\d{2}-\d{2}$/,
            /^\d{13}$/,
            /^\d{10}$/,
            /(time|date|timestamp|created|updated|start|end|at)$/i
        ];

        // ÈªòËÆ§JSONÔºàÂåÖÂê´Ê≥®ÈáäÂíåURLÊµãËØïÔºâ
        const DEFAULT_JSON = `{
  // Áî®Êà∑ID
  "user_id": 12345,
  // Áî®Êà∑Âêç
  "username": "john_doe",
  // ÈÇÆÁÆ±Âú∞ÂùÄ
  "email": "john@example.com",
  // Âπ¥ÈæÑ
  "age": 30,
  // ÊòØÂê¶ÊøÄÊ¥ª
  "is_active": true,
  // ÂàõÂª∫Êó∂Èó¥
  "created_at": "2023-10-01T12:00:00Z",
  // Êõ¥Êñ∞Êó∂Èó¥
  "updated_at": "2023-12-15T08:30:00Z",
  // Âá∫ÁîüÊó•Êúü
  "birth_date": "1993-05-15",
  // ÊúÄÂêéÁôªÂΩïÊó∂Èó¥
  "last_login": "2023-12-15T08:30:00.123Z",
  // ÂÖÉÊï∞ÊçÆ
  "metadata": {
    // Êó∂Èó¥Êà≥
    "timestamp": 1702643400000,
    // ËøáÊúüÊó∂Èó¥
    "expires_at": "2024-12-31 23:59:59"
  },
  // Áî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
  "preferences": {
    "theme": "dark",
    "language": "en"
  },
  // È°πÁõÆÂàóË°®
  "projects": [
    {
      "id": 1,
      "name": "API Gateway",
      "start_date": "2023-01-01",
      "end_date": "2023-12-31"
    }
  ]
}`;

        // ÊµãËØïJSONÔºöÂ§öÁª¥Êï∞ÁªÑ‰∏ãÂµåÂ•ó‰∏çÂêåÁªìÊûÑ‰ΩìÁöÑÂêàÂπ∂ÈÄªËæë
        const COMPLEX_JSON = `{
  "Âú∞ÂùÄ": "",
  "doc_url": "http://localhost",
  "docUrl": "http://localhost",
  "int1": 1,
  "int2": 3000000000,
  "float": 1.15,
  "a": [
    [
      {
        "a1": {
          "a2": [
            {"a3": "123"},
            {"b3": ""}
          ]
        }
      },
      {
        "a1": {
          "a2": [
            {"a3": 123},
            {"c3": ""}
          ],
          "b2": ""
        },
        "b1": {
          "b2": ""
        }
      }
    ]
  ]
}`;

        const DATA_FORMATS = {
            json: { name: 'JSON', icon: 'fas fa-code', monacoLang: 'json' },
            xml: { name: 'XML', icon: 'fas fa-file-code', monacoLang: 'xml' },
            yaml: { name: 'YAML', icon: 'fas fa-file-invoice', monacoLang: 'yaml' },
            toml: { name: 'TOML', icon: 'fas fa-cog', monacoLang: 'ini' },
            ini: { name: 'INI', icon: 'fas fa-sliders-h', monacoLang: 'ini' },
            text: { name: 'Text', icon: 'fas fa-font', monacoLang: 'plaintext' }
        };

        // ÂëΩÂêçÊ†ºÂºèÈÖçÁΩÆ
        const CASE_FORMATS = {
            pascal: {
                name: "Â§ßÈ©ºÂ≥∞ (PascalCase)",
                fn: (str) => str.split(/[_\s-]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('')
            },
            camel: {
                name: "Â∞èÈ©ºÂ≥∞ (camelCase)",
                fn: (str) => {
                    const words = str.split(/[_\s-]+/);
                    return words[0].toLowerCase() + words.slice(1).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');
                }
            },
            snake: {
                name: "‰∏ãÂàíÁ∫ø (snake_case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/-/g, '_')
            },
            kebab: {
                name: "ËøûÂ≠óÁ¨¶ (kebab-case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '').replace(/_/g, '-')
            }
        };

        function App() {
            // Êñ∞Â¢ûÔºöÂΩìÂâçÊï∞ÊçÆÊ†ºÂºèÁä∂ÊÄÅ
            const [dataFormat, setDataFormat] = useState("json");
            // Êñ∞Â¢ûÔºöÂØπÊØîÊ®°ÂºèÁä∂ÊÄÅ
            const [isDiffMode, setIsDiffMode] = useState(false);
            const [diffText, setDiffText] = useState("");
            // Êñ∞Â¢ûÔºöÂ∑¶Âè≥‰∏§‰æßÁã¨Á´ãÊ†ºÂºèÈÄâÊã©
            const [leftFormat, setLeftFormat] = useState("json");
            const [rightFormat, setRightFormat] = useState("json");
            // Êñ∞Â¢ûÔºöÂØπÊØîÁªìÊûú
            const [diffAnalysis, setDiffAnalysis] = useState(null);

            const diffEditorRef = useRef(null);
            const diffEditorInstance = useRef(null);
            // ‰øÆÂ§ç Hook Êä•ÈîôÔºöÊñ∞Â¢ûÂ∑¶‰æßÁºñËæëÂô® Ref
            const diffLeftEditorRef = useRef(null);

            const [lang, setLang] = useState("go");
            const [goTags, setGoTags] = useState({
                json: true,
                mapstructure: false,
                gorm: false,
                yaml: false,
                xml: false,
                validate: false,
                omitempty: true
            });

            const [structName, setStructName] = useState("Response");
            const [inlineStruct, setInlineStruct] = useState(false); // ÈªòËÆ§Êîπ‰∏∫ÊãÜÂàÜÊ®°ÂºèÔºå‰æø‰∫éÊü•Áúã
            const [detectTime, setDetectTime] = useState(true);
            const [includeComments, setIncludeComments] = useState(true);
            const [mergeArrayFields, setMergeArrayFields] = useState(true); // ÈªòËÆ§ÂºÄÂêØÂêàÂπ∂
            const [caseFormat, setCaseFormat] = useState("pascal");
            const [isCodeGenMode, setIsCodeGenMode] = useState(false); // ÈúÄÊ±Ç1ÔºöÈªòËÆ§ÂÖ≥Èó≠‰ª£Á†ÅÁîüÊàêÊ®°Âºè
            const [jsonText, setJsonText] = useState(DEFAULT_JSON);
            const [generatedCode, setGeneratedCode] = useState("");
            const [error, setError] = useState("");
            const [isGenerating, setIsGenerating] = useState(false);
            const [jsonStats, setJsonStats] = useState({ lines: 0, chars: 0, commentLines: 0, errorLines: 0 });
            const [codeStats, setCodeStats] = useState({ lines: 0, chars: 0 });
            const [timeFieldsDetected, setTimeFieldsDetected] = useState(0);
            const [generationInfo, setGenerationInfo] = useState(null);
            const [formatErrors, setFormatErrors] = useState([]); // Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñÈîôËØØ‰ø°ÊÅØ

            const jsonEditorRef = useRef(null);
            const jsonEditorInstance = useRef(null);
            const codeEditorRef = useRef(null);
            const codeEditorInstance = useRef(null);

            // ÊîπËøõÁöÑÊï∞ÁªÑÂêàÂπ∂Â∑•ÂÖ∑ÂáΩÊï∞ÔºàÊîØÊåÅÂ§öÁª¥Êï∞ÁªÑÈÄíÂΩíÂêàÂπ∂ÂíåÊ∑±Â∫¶Â≠óÊÆµÂêàÂπ∂Ôºâ
            const mergeArrayItems = useCallback((array, path = '') => {
                if (!array || array.length <= 1) return array;

                const firstItem = array[0];

                // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑÔºöÈÄíÂΩíÂ§ÑÁêÜÂ≠êÊï∞ÁªÑ
                if (Array.isArray(firstItem)) {
                    return array.map(subArray => mergeArrayItems(subArray, path + '[]'));
                }

                // Â§ÑÁêÜÂØπË±°Êï∞ÁªÑ
                if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {
                    // Ê£ÄÊü•ÁªìÊûÑÊòØÂê¶Áõ∏Âêå
                    const checkStructure = (item) => {
                        if (!item || typeof item !== 'object' || Array.isArray(item)) {
                            return null;
                        }
                        return Object.keys(item).sort();
                    };

                    const firstKeys = checkStructure(firstItem);
                    if (!firstKeys) return array;

                    // Ê£ÄÊü•ÊâÄÊúâÂØπË±°ÊòØÂê¶ÁªìÊûÑÁõ∏Âêå
                    let allSameStructure = true;
                    for (let i = 1; i < array.length; i++) {
                        const currentKeys = checkStructure(array[i]);
                        if (!currentKeys || JSON.stringify(currentKeys) !== JSON.stringify(firstKeys)) {
                            allSameStructure = false;
                            break;
                        }
                    }

                    if (allSameStructure) return array;

                    // Êî∂ÈõÜÊâÄÊúâÂØπË±°ÁöÑÂ≠óÊÆµÔºàÈÄíÂΩíÔºâ
                    const allFields = new Map(); // ‰ΩøÁî®MapËÆ∞ÂΩïÊØè‰∏™Â≠óÊÆµÁöÑÁ±ªÂûãÂíåÂÄº

                    array.forEach(item => {
                        if (item && typeof item === 'object' && !Array.isArray(item)) {
                            const collectFields = (obj, prefix = '') => {
                                Object.keys(obj).forEach(key => {
                                    const fullPath = prefix ? `${prefix}.${key}` : key;
                                    const value = obj[key];

                                    if (Array.isArray(value)) {
                                        // ÂØπ‰∫éÊï∞ÁªÑÔºåÈÄíÂΩíÂ§ÑÁêÜ
                                        if (value.length > 0 && typeof value[0] === 'object') {
                                            // ÈÄíÂΩíÊî∂ÈõÜÊï∞ÁªÑÂÜÖÁöÑÂ≠óÊÆµ
                                            const mergedArray = mergeArrayItems(value, fullPath);
                                            allFields.set(fullPath, {
                                                type: 'array',
                                                values: [mergedArray]
                                            });
                                        } else {
                                            // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                                            if (!allFields.has(fullPath)) {
                                                allFields.set(fullPath, { type: 'array', values: [] });
                                            }
                                            allFields.get(fullPath).values.push(value);
                                        }
                                    } else if (value && typeof value === 'object') {
                                        // ÈÄíÂΩíÊî∂ÈõÜÂµåÂ•óÂØπË±°
                                        collectFields(value, fullPath);
                                    } else {
                                        // Âü∫Êú¨Á±ªÂûã
                                        if (!allFields.has(fullPath)) {
                                            allFields.set(fullPath, { type: 'primitive', values: [] });
                                        }
                                        allFields.get(fullPath).values.push(value);
                                    }
                                });
                            };
                            collectFields(item);
                        }
                    });

                    // ÂàõÂª∫ÂêàÂπ∂ÂêéÁöÑÊï∞ÁªÑ
                    return array.map(item => {
                        if (!item || typeof item !== 'object' || Array.isArray(item)) {
                            return item;
                        }

                        const createMergedObject = (fieldsMap, currentObj = {}, prefix = '') => {
                            const result = { ...currentObj };

                            fieldsMap.forEach((fieldInfo, fieldPath) => {
                                if (!fieldPath.startsWith(prefix) && prefix) {
                                    // ‰∏çÂ±û‰∫éÂΩìÂâçÂ±ÇÁ∫ßÔºåË∑≥Ëøá
                                    return;
                                }

                                const relativePath = prefix ? fieldPath.substring(prefix.length + 1) : fieldPath;
                                const pathParts = relativePath.split('.');
                                const fieldName = pathParts[0];

                                if (pathParts.length === 1) {
                                    // ÂΩìÂâçÂ±ÇÁ∫ßÁöÑÂ≠óÊÆµ
                                    if (item && item.hasOwnProperty(fieldName)) {
                                        const value = item[fieldName];
                                        if (fieldInfo.type === 'array' && Array.isArray(value)) {
                                            if (value.length > 0 && typeof value[0] === 'object') {
                                                // ÈÄíÂΩíÂêàÂπ∂ÂµåÂ•óÊï∞ÁªÑ
                                                result[fieldName] = mergeArrayItems(value, fieldPath);
                                            } else {
                                                result[fieldName] = value;
                                            }
                                        } else if (value && typeof value === 'object') {
                                            // ÂµåÂ•óÂØπË±°ÔºåÈÄíÂΩíÂ§ÑÁêÜ
                                            const nestedFields = new Map();
                                            fieldsMap.forEach((info, path) => {
                                                if (path.startsWith(fieldPath + '.')) {
                                                    nestedFields.set(path, info);
                                                }
                                            });
                                            result[fieldName] = createMergedObject(nestedFields, value, fieldPath);
                                        } else {
                                            result[fieldName] = value;
                                        }
                                    } else {
                                        // Áº∫Â§±ÁöÑÂ≠óÊÆµ
                                        if (fieldInfo.type === 'array') {
                                            result[fieldName] = [];
                                        } else {
                                            result[fieldName] = '';
                                        }
                                    }
                                }
                            });

                            return result;
                        };

                        return createMergedObject(allFields, item);
                    });
                }

                return array;
            }, []);

            // Â§ÑÁêÜÂØπË±°ÂáΩÊï∞
            const processObject = useCallback((data) => {
                if (!mergeArrayFields) return data;

                const process = (item) => {
                    if (Array.isArray(item)) {
                        if (item.length > 0) {
                            const firstItem = item[0];
                            if (firstItem && typeof firstItem === 'object') {
                                // ÈÄíÂΩíÂ§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                                const processedArray = mergeArrayItems(item).map(process);
                                return processedArray;
                            } else if (Array.isArray(firstItem)) {
                                // Â§öÁª¥Êï∞ÁªÑ
                                return item.map(subArray => {
                                    if (Array.isArray(subArray) && subArray.length > 0) {
                                        const subFirstItem = subArray[0];
                                        if (subFirstItem && typeof subFirstItem === 'object') {
                                            return mergeArrayItems(subArray).map(process);
                                        }
                                    }
                                    return subArray.map(process);
                                });
                            }
                        }
                        return item;
                    } else if (item && typeof item === 'object') {
                        const result = {};
                        Object.entries(item).forEach(([key, value]) => {
                            if (Array.isArray(value)) {
                                result[key] = process(value);
                            } else if (value && typeof value === 'object') {
                                result[key] = process(value);
                            } else {
                                result[key] = value;
                            }
                        });
                        return result;
                    }
                    return item;
                };

                return process(JSON.parse(JSON.stringify(data)));
            }, [mergeArrayFields, mergeArrayItems]);
            // ÂàùÂßãÂåñÁºñËæëÂô®
            useEffect(() => {
                // Â¶ÇÊûúÂú®ÈùûÂØπÊØîÊ®°Âºè‰∏ãÔºå‰∏îÁºñËæëÂô®ÂÆπÂô®Â≠òÂú®Ôºå‰ΩÜÂÆû‰æã‰∏çÂ≠òÂú®ÔºåÂàôÂàõÂª∫
                if (!isDiffMode && !jsonEditorInstance.current && jsonEditorRef.current) {
                    jsonEditorInstance.current = monaco.editor.create(jsonEditorRef.current, {
                        value: jsonText || DEFAULT_JSON,
                        language: "json",
                        theme: "vs-dark",
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        foldingImportsByDefault: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on",
                        glyphMargin: true,
                        lineDecorationsWidth: 20,
                        renderLineHighlight: "all",
                        formatOnPaste: true,
                        formatOnType: true,
                        wordWrap: "off",
                        renderWhitespace: "selection",
                        quickSuggestions: true,
                        suggestOnTriggerCharacters: true,
                        acceptSuggestionOnEnter: "on",
                        tabCompletion: "on",
                        wordBasedSuggestions: true
                    });

                    // ÁõëÂê¨ÂÜÖÂÆπÂèòÂåñ
                    jsonEditorInstance.current.onDidChangeModelContent(() => {
                        const value = jsonEditorInstance.current.getValue();
                        setJsonText(value);

                        const lines = value.split('\n').length;
                        const chars = value.length;
                        const commentLines = (value.match(/\/\/.*$/g) || []).length;
                        setJsonStats(prev => ({ ...prev, lines, chars, commentLines }));
                    });
                }

                // ‰øÆÂ§çÔºöÂßãÁªàÂàùÂßãÂåñ‰ª£Á†ÅÁºñËæëÂô®Ôºå‰∏ç‰æùËµñ isCodeGenMode
                if (!codeEditorInstance.current && codeEditorRef.current) {
                    codeEditorInstance.current = monaco.editor.create(codeEditorRef.current, {
                        value: "// ËØ∑ÊâìÂºÄ‰ª£Á†ÅÁîüÊàêÂºÄÂÖ≥Âπ∂ÁÇπÂáª\"ÁîüÊàê‰ª£Á†Å\"ÊåâÈíÆ",
                        language: "go",
                        theme: "vs-dark",
                        readOnly: false,
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on"
                    });
                }

                return () => {
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }
                };
            }, [isDiffMode]); // ‰æùËµñ isDiffModeÔºåÂú®ÂàáÊç¢Ê®°ÂºèÊó∂ÈáçÊñ∞ËØÑ‰º∞

            // Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®ËØ≠Ë®Ä
            useEffect(() => {
                if (codeEditorInstance.current) {
                    const model = codeEditorInstance.current.getModel();
                    if (model) {
                        monaco.editor.setModelLanguage(model, LANGUAGE_CONFIG[lang].monacoLang);
                    }
                }
            }, [lang]);

            // ÊîπËøõÁöÑJSONÊ≥®ÈáäËß£ÊûêÂáΩÊï∞
            const parseJsonWithComments = useCallback((jsonString) => {
                try {
                    const removeComments = (str) => {
                        const lines = str.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const withoutComments = removeComments(jsonString);
                    const parsed = JSON.parse(withoutComments);

                    const comments = { fieldComments: {} };
                    const lines = jsonString.split('\n');
                    let currentField = '';

                    lines.forEach((line) => {
                        let inString = false;
                        let escaped = false;
                        let commentStart = -1;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            const nextChar = i + 1 < line.length ? line[i + 1] : '';

                            if (!escaped && char === '\\') {
                                escaped = true;
                            } else if (!escaped && char === '"') {
                                inString = !inString;
                            } else if (!inString && char === '/' && nextChar === '/') {
                                commentStart = i;
                                break;
                            } else {
                                escaped = false;
                            }
                        }

                        if (commentStart !== -1) {
                            const comment = line.substring(commentStart + 2).trim();
                            if (currentField && comment) {
                                comments.fieldComments[currentField] = comment;
                            }

                            const beforeComment = line.substring(0, commentStart);
                            const fieldMatch = beforeComment.match(/"([^"]+)":\s*$/);
                            if (fieldMatch) {
                                currentField = fieldMatch[1];
                            }
                        }

                        const fieldMatch = line.match(/"([^"]+)":/);
                        if (fieldMatch) {
                            currentField = fieldMatch[1];
                        }
                    });

                    return { parsed, comments };
                } catch (err) {
                    try {
                        const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                        const parsed = JSON.parse(withoutComments);
                        return { parsed, comments: { fieldComments: {} } };
                    } catch (err2) {
                        throw new Error(`JSONËß£ÊûêÂ§±Ë¥•: ${err2.message}`);
                    }
                }
            }, []);

            // ‰∏≠ÊñáËΩ¨UnicodeÂáΩÊï∞
            const chineseToUnicode = useCallback((str) => {
                let result = '';
                for (let i = 0; i < str.length; i++) {
                    const charCode = str.charCodeAt(i);
                    if (charCode > 127) {
                        result += '\\u' + charCode.toString(16).padStart(4, '0');
                    } else {
                        result += str.charAt(i);
                    }
                }
                return result;
            }, []);

            // UnicodeËΩ¨‰∏≠ÊñáÂáΩÊï∞
            const unicodeToChinese = useCallback((str) => {
                return str.replace(/\\u[\dA-F]{4}/gi, (match) => {
                    return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
                });
            }, []);

            // ========== ÈúÄÊ±Ç1: Â§öÊ†ºÂºèËΩ¨Êç¢ÂáΩÊï∞ ==========
            // JSONËΩ¨XML - ‰øÆÂ§çÊï∞ÁªÑÂ§ÑÁêÜÂíåÊó†ÈôêÂè†Âä†rootÈóÆÈ¢ò
            const jsonToXml = useCallback((obj, rootName = 'root', indent = '') => {
                const processValue = (key, value, currentIndent, fromArray = false) => {
                    if (value === null || value === undefined) {
                        return `${currentIndent}<${key}/>\n`;
                    }
                    if (Array.isArray(value)) {
                        // ‰øÆÂ§çÔºöÊï∞ÁªÑÂ∫îËØ•Áî®Â§çÊï∞ÂΩ¢ÂºèÂåÖË£πÔºåÂÜÖÈÉ®ÂÖÉÁ¥†Áî®ÂçïÊï∞ÂΩ¢Âºè
                        const singleKey = key.endsWith('s') ? key.slice(0, -1) : key + 'Item';
                        let arrayContent = `${currentIndent}<${key}>\n`;
                        arrayContent += value.map(item => processValue(singleKey, item, currentIndent + '  ', true)).join('');
                        arrayContent += `${currentIndent}</${key}>\n`;
                        return arrayContent;
                    }
                    if (typeof value === 'object') {
                        let content = '';
                        content += `${currentIndent}<${key}>\n`;
                        for (const [k, v] of Object.entries(value)) {
                            content += processValue(k, v, currentIndent + '  ');
                        }
                        content += `${currentIndent}</${key}>\n`;
                        return content;
                    }
                    return `${currentIndent}<${key}>${String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</${key}>\n`;
                };

                let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
                // Âè™Âú®È°∂Â±ÇÊ∑ªÂä†rootÊ†áÁ≠æÔºåÈÅøÂÖçÂ§öÊ¨°ËΩ¨Êç¢Êó∂Âè†Âä†
                xml += `<${rootName}>\n`;
                for (const [key, value] of Object.entries(obj)) {
                    xml += processValue(key, value, '  ');
                }
                xml += `</${rootName}>`;
                return xml;
            }, []);

            // JSONËΩ¨YAML - ‰øÆÂ§çÊï∞ÁªÑÂ§ÑÁêÜÂíåÊó∂Èó¥Â≠óÁ¨¶‰∏≤ÈóÆÈ¢ò
            const jsonToYaml = useCallback((obj, indent = 0) => {
                const spaces = '  '.repeat(indent);
                let yaml = '';
                const processValue = (value, currentIndent) => {
                    if (value === null) return 'null';
                    if (value === undefined) return '';
                    if (typeof value === 'boolean') return value ? 'true' : 'false';
                    if (typeof value === 'number') return String(value);
                    if (typeof value === 'string') {
                        // Ê£ÄÊµãÊó∂Èó¥Â≠óÁ¨¶‰∏≤ÔºåÁ°Æ‰øùÂÆåÊï¥‰øùÁïô
                        const isTimeString = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value);
                        if (isTimeString || value.includes('\n') || value.includes(':') || value.includes('#')) {
                            return `"${value.replace(/"/g, '\\"')}"`;
                        }
                        return value;
                    }
                    return String(value);
                };

                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n`;
                        value.forEach(item => {
                            if (typeof item === 'object' && item !== null) {
                                const itemYaml = jsonToYaml(item, indent + 1).trim();
                                if (itemYaml) {
                                    yaml += `${spaces}- ${itemYaml}\n`;
                                }
                            } else {
                                yaml += `${spaces}- ${processValue(item, indent + 1)}\n`;
                            }
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        yaml += `${spaces}${key}:\n`;
                        yaml += jsonToYaml(value, indent + 1);
                    } else {
                        const processedValue = processValue(value, indent);
                        yaml += `${spaces}${key}: ${processedValue}\n`;
                    }
                }
                return yaml;
            }, []);

            // JSONËΩ¨TOML
            const jsonToToml = useCallback((obj, section = '') => {
                let toml = '';
                const simpleValues = {};
                const complexValues = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        complexValues[key] = value;
                    } else {
                        simpleValues[key] = value;
                    }
                }
                for (const [key, value] of Object.entries(simpleValues)) {
                    if (Array.isArray(value)) {
                        const items = value.map(item => {
                            if (typeof item === 'string') return `"${item}"`;
                            return String(item);
                        }).join(', ');
                        toml += `${key} = [${items}]\n`;
                    } else if (typeof value === 'string') {
                        toml += `${key} = "${value}"\n`;
                    } else if (typeof value === 'boolean') {
                        toml += `${key} = ${value}\n`;
                    } else {
                        toml += `${key} = ${value}\n`;
                    }
                }
                for (const [key, value] of Object.entries(complexValues)) {
                    const sectionName = section ? `${section}.${key}` : key;
                    toml += `\n[${sectionName}]\n`;
                    toml += jsonToToml(value, sectionName);
                }
                return toml;
            }, []);

            // JSONËΩ¨INI
            const jsonToIni = useCallback((obj) => {
                let ini = '';
                const globalValues = {};
                const sections = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        sections[key] = value;
                    } else {
                        globalValues[key] = value;
                    }
                }
                for (const [key, value] of Object.entries(globalValues)) {
                    ini += `${key}=${value}\n`;
                }
                for (const [section, values] of Object.entries(sections)) {
                    ini += `\n[${section}]\n`;
                    for (const [key, value] of Object.entries(values)) {
                        if (typeof value !== 'object') {
                            ini += `${key}=${value}\n`;
                        }
                    }
                }
                return ini;
            }, []);

            // XMLËΩ¨JSON (ÊîπËøõÂÆûÁé∞ÔºåÈÅøÂÖçÊó†ÈôêÂè†Âä†root)
            const xmlToJson = useCallback((xmlStr) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlStr, "text/xml");

                const parseNode = (node) => {
                    const obj = {};

                    // Â§ÑÁêÜÂ±ûÊÄß
                    if (node.attributes && node.attributes.length > 0) {
                        for (let j = 0; j < node.attributes.length; j++) {
                            const attribute = node.attributes.item(j);
                            obj[`@${attribute.nodeName}`] = attribute.nodeValue;
                        }
                    }

                    // Â§ÑÁêÜÂ≠êËäÇÁÇπ
                    if (node.hasChildNodes()) {
                        const childCounts = {};
                        const childValues = {};

                        for (let i = 0; i < node.childNodes.length; i++) {
                            const child = node.childNodes.item(i);

                            if (child.nodeType === 3) { // Text node
                                const text = child.nodeValue.trim();
                                if (text) {
                                    if (!obj['#text']) obj['#text'] = text;
                                    else if (Array.isArray(obj['#text'])) obj['#text'].push(text);
                                    else obj['#text'] = [obj['#text'], text];
                                }
                            } else if (child.nodeType === 1) { // Element node
                                const childName = child.nodeName;
                                const childValue = parseNode(child);

                                if (childCounts[childName]) {
                                    childCounts[childName]++;
                                    if (!Array.isArray(childValues[childName])) {
                                        childValues[childName] = [childValues[childName]];
                                    }
                                    childValues[childName].push(childValue);
                                } else {
                                    childCounts[childName] = 1;
                                    childValues[childName] = childValue;
                                }
                            }
                        }

                        // ÂêàÂπ∂Â§ÑÁêÜÂêéÁöÑÂ≠êËäÇÁÇπ
                        Object.entries(childValues).forEach(([name, value]) => {
                            obj[name] = value;
                        });
                    }

                    // Â¶ÇÊûúÂè™ÊúâÊñáÊú¨ÂÜÖÂÆπÔºåËøîÂõûÊñáÊú¨
                    if (Object.keys(obj).length === 1 && obj['#text']) {
                        return obj['#text'];
                    }
                    // Â¶ÇÊûúÊ≤°ÊúâÂÜÖÂÆπÔºåËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤
                    if (Object.keys(obj).length === 0) {
                        return "";
                    }

                    return obj;
                };

                const root = xmlDoc.documentElement;
                // Áõ¥Êé•ËøîÂõûËß£ÊûêÁªìÊûúÔºåÈÅøÂÖçÈ¢ùÂ§ñÂåÖË£Ö
                return parseNode(root);
            }, []);

            // INIËΩ¨JSON (‰øÆÂ§çÈúÄÊ±Ç3ÔºöÂéªÈô§Â≠óÁ¨¶‰∏≤ÂÄºÁöÑËΩ¨‰πâÁ¨¶Âè∑/ÂºïÂè∑)
            const iniToJson = useCallback((iniStr) => {
                const result = {};
                let currentSection = result;

                iniStr.split('\n').forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith(';') || line.startsWith('#')) return;

                    if (line.startsWith('[') && line.endsWith(']')) {
                        const sectionName = line.slice(1, -1);
                        result[sectionName] = {};
                        currentSection = result[sectionName];
                    } else if (line.includes('=')) {
                        const parts = line.split('=');
                        const key = parts[0].trim();
                        // Â§ÑÁêÜÂÄºÂåÖÂê´ = ÁöÑÊÉÖÂÜµ
                        let val = parts.slice(1).join('=').trim();

                        // ÂéªÈô§È¶ñÂ∞æÂºïÂè∑
                        if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                            val = val.slice(1, -1);
                        }

                        // Â∞ùËØïËΩ¨Êç¢Â∏ÉÂ∞îÂÄºÂíåÊï∞Â≠ó
                        if (val === 'true') val = true;
                        else if (val === 'false') val = false;
                        else if (!isNaN(val) && val !== '') val = Number(val);

                        currentSection[key] = val;
                    }
                });
                return result;
            }, []);

            // ÊîπËøõÁöÑYAMLËß£ÊûêÂô®
            const yamlToJson = useCallback((yamlStr) => {
                const lines = yamlStr.split('\n');
                const root = {};
                // ‰ΩøÁî®ÂèåÊ†àÁ≠ñÁï•Ôºö‰∏Ä‰∏™Áª¥Êä§‰∏ä‰∏ãÊñáÔºå‰∏Ä‰∏™Áª¥Êä§Êï∞ÁªÑÂºïÁî®
                const finalResult = {};
                const ptrs = [{ obj: finalResult, indent: -1 }];

                // ËæÖÂä©ÔºöËß£ÊûêÂÄº
                const parseVal = (val) => {
                    if (!val) return null;
                    val = val.trim();
                    if (val === 'true') return true;
                    if (val === 'false') return false;
                    if (val === 'null') return null;
                    // ‰øÆÂ§çÔºö‰∏çË¶ÅËΩªÊòìÊääÁúã‰ººÊï∞Â≠óÁöÑÂ≠óÁ¨¶‰∏≤ËΩ¨Êï∞Â≠óÔºåÈô§ÈùûÂÆåÂÖ®ÂåπÈÖç
                    if (!isNaN(val) && !val.includes(':') && !val.includes('-') && !val.includes('T')) return Number(val);
                    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                        return val.slice(1, -1);
                    }
                    return val;
                };

                lines.forEach(line => {
                    const rawLine = line.replace(/\s+$/, '');
                    if (!rawLine || rawLine.trim().startsWith('#')) return;

                    const indent = rawLine.search(/\S/);
                    const trimmed = rawLine.trim();

                    // ÂõûÊ∫ØÁà∂Á∫ß
                    while (ptrs.length > 1 && ptrs[ptrs.length - 1].indent >= indent) ptrs.pop();
                    const curr = ptrs[ptrs.length - 1];

                    // Â§ÑÁêÜÊï∞ÁªÑÈ°π
                    if (trimmed.startsWith('- ')) {
                        // ÂèëÁé∞Êï∞ÁªÑÈ°πÔºåÂ¶ÇÊûúÂΩìÂâçÂØπË±°ÊòØÁ©∫ÂØπË±°ÔºàÂàöÂàùÂßãÂåñÔºâÔºåËΩ¨Êç¢‰∏∫Êï∞ÁªÑ
                        if (!Array.isArray(curr.obj) && Object.keys(curr.obj).length === 0) {
                            if (curr.parent && curr.key) {
                                curr.parent[curr.key] = [];
                                curr.obj = curr.parent[curr.key]; // Êõ¥Êñ∞ÂºïÁî®
                            }
                        }

                        if (Array.isArray(curr.obj)) {
                            const content = trimmed.substring(2).trim();
                            const colIdx = content.indexOf(':');

                            // Âà§Êñ≠ÊòØÂê¶ÊòØÂØπË±°È°π (key: value)
                            if (colIdx > 0 && !content.startsWith('"') && !content.startsWith("'")) {
                                const k = content.substring(0, colIdx).trim();
                                const v = content.substring(colIdx + 1).trim();
                                const newItem = {};
                                newItem[k] = v ? parseVal(v) : {};
                                curr.obj.push(newItem);
                                if (!v) ptrs.push({ obj: newItem[k], indent, parent: newItem, key: k });
                            } else {
                                // Âü∫Êú¨ÂÄº
                                curr.obj.push(parseVal(content));
                            }
                        }
                        return;
                    }

                    // Â§ÑÁêÜÂØπË±°ÈîÆÂÄºÂØπ
                    const colIdx = trimmed.indexOf(':');
                    if (colIdx > 0) {
                        const k = trimmed.substring(0, colIdx).trim();
                        const v = trimmed.substring(colIdx + 1).trim();
                        if (!v) {
                            // ÂÄº‰∏∫Á©∫ÔºåÂèØËÉΩÊòØÂµåÂ•óÂØπË±°ÊàñÊï∞ÁªÑ
                            // ÂÖàÂàùÂßãÂåñ‰∏∫ÂØπË±°ÔºåÂ¶ÇÊûúÂêéÁª≠ÈÅáÂà∞ - ‰ºöËá™Âä®ËΩ¨‰∏∫Êï∞ÁªÑ
                            if (Array.isArray(curr.obj)) {
                                const newObj = {};
                                newObj[k] = {};
                                curr.obj.push(newObj);
                                ptrs.push({ obj: newObj[k], indent, parent: newObj, key: k });
                            } else {
                                curr.obj[k] = {};
                                ptrs.push({ obj: curr.obj[k], indent, parent: curr.obj, key: k });
                            }
                        } else {
                            if (v === '[]') {
                                curr.obj[k] = [];
                            } else {
                                curr.obj[k] = parseVal(v);
                            }
                        }
                    }
                });

                return finalResult;
            }, []);

            // Áªü‰∏ÄÁöÑÂØπË±°Ëß£ÊûêÂáΩÊï∞
            const parseCurrentContent = useCallback((content, format) => {
                try {
                    if (!content) return {};
                    if (format === 'text') return { text: content }; // ÊñáÊú¨Ê†ºÂºèÁâπÊÆäÂ§ÑÁêÜ

                    if (format === 'json') {
                        const { parsed } = parseJsonWithComments(content);
                        return parsed;
                    } else if (format === 'xml') {
                        return xmlToJson(content);
                    } else if (format === 'ini') {
                        return iniToJson(content);
                    } else if (format === 'yaml') {
                        return yamlToJson(content);
                    } else if (format === 'toml') {
                        return iniToJson(content); // ÈôçÁ∫ß
                    }
                    return {};
                } catch (e) {
                    throw new Error(`Ëß£Êûê ${format} Â§±Ë¥•: ${e.message}`);
                }
            }, [parseJsonWithComments, xmlToJson, iniToJson, yamlToJson]);

            // Ê†ºÂºèËΩ¨Êç¢ÂáΩÊï∞
            const convertFormat = useCallback((targetFormat) => {
                try {
                    const currentValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const fromFormat = dataFormat;

                    if (fromFormat === targetFormat) return;

                    const obj = parseCurrentContent(currentValue, fromFormat);

                    // 2. Â∞Ü JSON ÂØπË±°ËΩ¨Êç¢‰∏∫ÁõÆÊ†áÊ†ºÂºè
                    let result = '';
                    switch (targetFormat) {
                        case 'json':
                            result = JSON.stringify(obj, null, 2);
                            break;
                        case 'xml':
                            result = jsonToXml(obj);
                            break;
                        case 'yaml':
                            result = jsonToYaml(obj);
                            break;
                        case 'toml':
                            result = jsonToToml(obj);
                            break;
                        case 'ini':
                            result = jsonToIni(obj);
                            break;
                        default:
                            throw new Error(`‰∏çÊîØÊåÅÁöÑÁõÆÊ†áÊ†ºÂºè: ${targetFormat}`);
                    }

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(result);
                        const model = jsonEditorInstance.current.getModel();
                        if (model) {
                            monaco.editor.setModelLanguage(model, DATA_FORMATS[targetFormat].monacoLang);
                        }
                    }
                    setJsonText(result);
                    setDataFormat(targetFormat);
                    setError(""); // ÈúÄÊ±Ç1: ÊàêÂäü‰∏çÊòæÁ§∫ÊèêÁ§∫

                } catch (err) {
                    setError(`Ê†ºÂºèËΩ¨Êç¢ÈîôËØØ: ${err.message}`);
                }
            }, [dataFormat, jsonText, parseCurrentContent, jsonToXml, jsonToYaml, jsonToToml, jsonToIni]);

            // ========== ÈúÄÊ±Ç3: JSONÂØπÊØîÂäüËÉΩ ==========
            const [diffResult, setDiffResult] = useState(null);

            // ÂàùÂßãÂåñÂØπÊØîÁºñËæëÂô® (‰øÆÂ§ç Hook Êä•ÈîôÔºöÁªü‰∏ÄÂú® Effect ‰∏≠ÂàùÂßãÂåñ)
            useEffect(() => {
                if (isDiffMode) {
                    // ÂàùÂßãÂåñÂ∑¶‰æßÁºñËæëÂô® (ÂéüÂßã JSON)
                    if (diffLeftEditorRef.current && !jsonEditorInstance.current) {
                         // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨Â§çÁî® jsonEditorInstanceÔºå‰ΩÜÂú®ÂØπÊØîÊ®°Âºè‰∏ãÂÆÉÊåÇËΩΩÂú® diffLeftEditorRef
                         jsonEditorInstance.current = monaco.editor.create(diffLeftEditorRef.current, {
                            value: jsonText,
                            language: "json",
                            theme: "vs-dark",
                            automaticLayout: true,
                            minimap: { enabled: true },
                            scrollBeyondLastLine: false,
                            fontSize: 13,
                            lineNumbers: "on"
                        });
                        jsonEditorInstance.current.onDidChangeModelContent(() => {
                            const value = jsonEditorInstance.current.getValue();
                            setJsonText(value);
                        });
                    }

                    // ÂàùÂßãÂåñÂè≥‰æßÁºñËæëÂô® (ÂØπÊØî JSON)
                    if (diffEditorRef.current && !diffEditorInstance.current) {
                        diffEditorInstance.current = monaco.editor.create(diffEditorRef.current, {
                            value: diffText || '// Âú®Ê≠§ËæìÂÖ•Ë¶ÅÂØπÊØîÁöÑJSON',
                            language: "json",
                            theme: "vs-dark",
                            automaticLayout: true,
                            minimap: { enabled: true },
                            scrollBeyondLastLine: false,
                            fontSize: 13,
                            lineNumbers: "on"
                        });
                        diffEditorInstance.current.onDidChangeModelContent(() => {
                            const value = diffEditorInstance.current.getValue();
                            setDiffText(value);
                        });
                    }
                }

                // Ê∏ÖÁêÜÈÄªËæë‰∫§Áªô toggleDiffMode ÊàñÁªÑ‰ª∂Âç∏ËΩΩ
            }, [isDiffMode]); // ‰ªÖÂú®Ê®°ÂºèÂàáÊç¢Êó∂Ëß¶Âèë

            // Ê∑±Â∫¶ÂØπÊØî‰∏§‰∏™ÂØπË±°
            const deepCompare = useCallback((obj1, obj2, path = '') => {
                const differences = [];
                const allKeys = new Set([...Object.keys(obj1 || {}), ...Object.keys(obj2 || {})]);
                for (const key of allKeys) {
                    const currentPath = path ? `${path}.${key}` : key;
                    const val1 = obj1?.[key];
                    const val2 = obj2?.[key];
                    if (!(key in (obj1 || {}))) {
                        differences.push({ type: 'added', path: currentPath, value: val2 });
                    } else if (!(key in (obj2 || {}))) {
                        differences.push({ type: 'removed', path: currentPath, value: val1 });
                    } else if (typeof val1 !== typeof val2) {
                        differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                    } else if (Array.isArray(val1) && Array.isArray(val2)) {
                        if (JSON.stringify(val1) !== JSON.stringify(val2)) {
                            differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                        }
                    } else if (typeof val1 === 'object' && val1 !== null) {
                        differences.push(...deepCompare(val1, val2, currentPath));
                    } else if (val1 !== val2) {
                        differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                    }
                }
                return differences;
            }, []);

            // ÊâßË°åÂØπÊØî (ÈúÄÊ±Ç2ÔºöËØ≠‰πâÂØπÊØî)
            const performDiff = useCallback(() => {
                try {
                    const leftContent = jsonEditorInstance.current?.getValue() || jsonText;
                    const rightContent = diffEditorInstance.current?.getValue() || diffText;

                    // ÂàÜÂà´Ëß£Êûê‰∏∫ JSON ÂØπË±°
                    const leftObj = parseCurrentContent(leftContent, leftFormat);
                    const rightObj = parseCurrentContent(rightContent, rightFormat);

                    const differences = deepCompare(leftObj, rightObj);

                    const stats = {
                        added: differences.filter(d => d.type === 'added').length,
                        removed: differences.filter(d => d.type === 'removed').length,
                        modified: differences.filter(d => d.type === 'modified').length
                    };

                    setDiffAnalysis({
                        differences,
                        stats,
                        leftFormat,
                        rightFormat
                    });
                    setError("");
                } catch (err) {
                    setError(`ÂØπÊØîÈîôËØØ: ${err.message}`);
                    setDiffAnalysis(null);
                }
            }, [jsonText, diffText, leftFormat, rightFormat, parseCurrentContent, deepCompare]);

            // ËæÖÂä©ÔºöÊ†ºÂºèÂåñÁâπÂÆöÁºñËæëÂô®ÁöÑÂÜÖÂÆπ
            const formatEditorContent = useCallback((editorInstance, format, setTextFunc) => {
                if (!editorInstance || format === 'text') return; // Text ‰∏çÂÅöÊìç‰Ωú
                try {
                    const content = editorInstance.getValue();
                    const obj = parseCurrentContent(content, format);
                    let formatted = '';

                    if (format === 'json') formatted = JSON.stringify(obj, null, 2);
                    else if (format === 'xml') formatted = jsonToXml(obj);
                    else if (format === 'yaml') formatted = jsonToYaml(obj);
                    else if (format === 'ini' || format === 'toml') formatted = jsonToIni(obj);

                    editorInstance.setValue(formatted);
                    if (setTextFunc) setTextFunc(formatted);
                } catch(e) {
                    console.error("Format error", e);
                }
            }, [parseCurrentContent, jsonToXml, jsonToYaml, jsonToIni]);

            // ÂàáÊç¢ÂØπÊØîÊ®°Âºè
            const toggleDiffMode = useCallback(() => {
                setIsDiffMode(prev => {
                    const newMode = !prev;
                    // Â¶ÇÊûúÊâìÂºÄÂØπÊØîÊ®°ÂºèÔºåÂÖ≥Èó≠‰ª£Á†ÅÁîüÊàêÊ®°ÂºèÔºà‰∫íÊñ•Ôºâ
                    if (newMode && isCodeGenMode) {
                        setIsCodeGenMode(false);
                    }

                    // ÂàáÊç¢Ê®°ÂºèÊó∂ÔºåÊ∏ÖÁêÜÁºñËæëÂô®ÂÆû‰æã
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (diffEditorInstance.current) {
                        diffEditorInstance.current.dispose();
                        diffEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }

                    return newMode;
                });

                setDiffAnalysis(null);
            }, [isCodeGenMode]);

            // ÂÆπÈîôÁöÑËΩØÊ†ºÂºèÂåñÂáΩÊï∞ÔºàÁî®‰∫éÊó†Ê≥ïËß£ÊûêÁöÑ JSONÔºâ
            const softFormatJson = (text) => {
                let formatted = '';
                let indentLevel = 0;
                const indentStr = '  ';
                let inString = false;
                let isEscaped = false;

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];

                    if (inString) {
                        if (char === '\\') isEscaped = !isEscaped;
                        else if (char === '"' && !isEscaped) inString = false;
                        formatted += char;
                        continue;
                    }

                    if (char === '"') {
                        inString = true;
                        formatted += char;
                        continue;
                    }

                    if (char === '{' || char === '[') {
                        formatted += char + '\n' + indentStr.repeat(++indentLevel);
                    } else if (char === '}' || char === ']') {
                        formatted += '\n' + indentStr.repeat(--indentLevel) + char;
                    } else if (char === ',') {
                        formatted += char + '\n' + indentStr.repeat(indentLevel);
                    } else if (char === ':') {
                         formatted += ': ';
                    } else if (/\s/.test(char)) {
                        // ÂøΩÁï•ÈùûÂ≠óÁ¨¶‰∏≤ÂÜÖÁöÑÁ©∫ÁôΩÔºåÊàë‰ª¨Ëá™Â∑±ÊéßÂà∂Áº©Ëøõ
                    } else {
                        formatted += char;
                    }
                }
                return formatted;
            };

            // ÊîπËøõÁöÑÊ†ºÂºèÂåñÂáΩÊï∞ÔºöÊô∫ËÉΩ‰øÆÂ§çÂπ∂Ê†ºÂºèÂåñJSON
            const formatJsonIntelligently = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;

                    // 0. È¢ÑÂ§ÑÁêÜÔºöÊõøÊç¢‰∏≠ÊñáÊ†áÁÇπ (ÂßãÁªàÊâßË°å)
                    let fixed = jsonValue
                        .replace(/[„ÄÇÔºõ]/g, ',') // Âè•Âè∑ÂàÜÂè∑ÂèòÈÄóÂè∑
                        .replace(/Ôºå/g, ',')     // ‰∏≠ÊñáÈÄóÂè∑
                        .replace(/‚Äú|‚Äù/g, '"');   // ‰∏≠ÊñáÂºïÂè∑

                    // 1. Â∞ùËØïÁõ¥Êé• Parse
                    try {
                        const cleanedValue = fixed.replace(/\/\/.*$/gm, ''); // ÂéªÊ≥®Èáä
                        const parsed = JSON.parse(cleanedValue);
                        const formatted = JSON.stringify(parsed, null, 2);
                        if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(formatted);
                        setJsonText(formatted);
                        setError(""); // ÈúÄÊ±Ç1: ÊàêÂäü‰∏çÊòæÁ§∫ÊèêÁ§∫
                        setFormatErrors([]);
                        return;
                    } catch (e) {
                        // Parse Â§±Ë¥•
                    }

                    // 2. Â∞ùËØï‰øÆÂ§çÂèåÂÜíÂè∑ "key":"val":"val" -> "key": "val:val" (‰ªÖ‰ΩúÁåúÊµã‰øÆÂ§çÔºå‰∏ç‰øùËØÅÊ≠£Á°Æ)
                    // Áî®Êà∑Áî®‰æã: "query_type":"formula":"OC1..."
                    // ËøôÁßçÁªìÊûÑÂ¶ÇÊûú‰∏çËΩ¨‰πâÁ¨¨‰∫å‰∏™ÂÜíÂè∑ÔºåÊ†πÊú¨Êó†Ê≥ï Parse„ÄÇ
                    // Á≠ñÁï•Ôºö‰ΩøÁî®ËΩØÊ†ºÂºèÂåñÊù•Â±ïÁ§∫

                    const softFormatted = softFormatJson(fixed);
                    if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(softFormatted);
                    setJsonText(softFormatted);
                    setError("JSONÂ≠òÂú®ËØ≠Ê≥ïÈîôËØØÔºåÂ∑≤ÊâßË°åËßÜËßâÊ†ºÂºèÂåñ (Soft Format)");
                    setFormatErrors([]);

                } catch (err) {
                    setError(`Ê†ºÂºèÂåñÈîôËØØ: ${err.message}`);
                }
            }, [jsonText]);

            // ÈúÄÊ±Ç3Ôºö‰∏≠ÊñáËΩ¨UnicodeÂäüËÉΩ
            const convertChineseToUnicode = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const converted = chineseToUnicode(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(converted);
                    }
                    setJsonText(converted);
                    setError("");
                    setFormatErrors([]);
                } catch (err) {
                    setError(`‰∏≠ÊñáËΩ¨UnicodeÈîôËØØ: ${err.message}`);
                }
            }, [jsonText, chineseToUnicode]);

            // ÈúÄÊ±Ç3ÔºöUnicodeËΩ¨‰∏≠ÊñáÂäüËÉΩ
            const convertUnicodeToChinese = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const converted = unicodeToChinese(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(converted);
                    }
                    setJsonText(converted);
                    setError("");
                    setFormatErrors([]);
                } catch (err) {
                    setError(`UnicodeËΩ¨‰∏≠ÊñáÈîôËØØ: ${err.message}`);
                }
            }, [jsonText, unicodeToChinese]);

            // Ê∏ÖÁêÜJSONÔºöÁßªÈô§Ê≥®ÈáäÂπ∂Ê†ºÂºèÂåñ
            const cleanJson = useCallback((jsonString) => {
                try {
                    const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                    const parsed = JSON.parse(withoutComments);
                    return JSON.stringify(parsed, null, 2);
                } catch (err) {
                    throw new Error(`JSONÊ∏ÖÁêÜÂ§±Ë¥•: ${err.message}`);
                }
            }, []);

            // Ê£ÄÊµãÊó∂Èó¥Â≠óÊÆµ
            const detectTimeFields = useCallback((obj) => {
                let count = 0;

                const traverse = (data) => {
                    if (Array.isArray(data)) {
                        data.forEach(item => {
                            if (item && typeof item === 'object') {
                                traverse(item);
                            }
                        });
                    } else if (data && typeof data === 'object') {
                        Object.entries(data).forEach(([key, value]) => {
                            if (typeof value === 'string' && isTimeString(value)) {
                                count++;
                            }
                            else if (isTimeFieldName(key)) {
                                count++;
                            }
                            if (value && typeof value === 'object') {
                                traverse(value);
                            }
                        });
                    }
                };

                traverse(obj);
                return count;
            }, []);

            // Êî∂ÈõÜÁîüÊàê‰ø°ÊÅØ
            const collectGenerationInfo = useCallback((obj, lang, detectTime, mergeArrayFields) => {
                const info = {
                    totalFields: 0,
                    nestedObjects: 0,
                    arrays: 0,
                    timeFields: 0,
                    maxDepth: 0,
                    mergedArrays: 0,
                    warnings: []
                };

                const traverse = (data, depth = 0) => {
                    info.maxDepth = Math.max(info.maxDepth, depth);

                    if (Array.isArray(data)) {
                        info.arrays++;

                        if (mergeArrayFields && data.length > 1 &&
                            data.every(item => item && typeof item === 'object' && !Array.isArray(item))) {

                            const firstKeys = Object.keys(data[0] || {});
                            let allSameStructure = true;

                            for (let i = 1; i < data.length; i++) {
                                const currentKeys = Object.keys(data[i] || {});
                                if (currentKeys.length !== firstKeys.length ||
                                    !currentKeys.every(key => firstKeys.includes(key))) {
                                    allSameStructure = false;
                                    break;
                                }
                            }

                            if (!allSameStructure) {
                                info.mergedArrays++;
                            }
                        }

                        if (data.length > 0) {
                            const firstItem = data[0];
                            if (firstItem && typeof firstItem === 'object') {
                                data.forEach(item => traverse(item, depth + 1));
                            }
                        }
                    } else if (data && typeof data === 'object') {
                        info.nestedObjects++;
                        Object.entries(data).forEach(([key, value]) => {
                            info.totalFields++;

                            if (detectTime && isTimeField(key, value)) {
                                info.timeFields++;
                            }

                            if (value && typeof value === 'object') {
                                traverse(value, depth + 1);
                            }
                        });
                    }
                };

                traverse(obj);

                if (info.maxDepth > 5) {
                    info.warnings.push(`JSONÂµåÂ•óÊ∑±Â∫¶ËæÉÊ∑± (${info.maxDepth} Â±Ç)ÔºåÂèØËÉΩÂØºËá¥ÁîüÊàêÁöÑÁªìÊûÑ‰ΩìÂ§çÊùÇ`);
                }
                if (info.arrays > 10) {
                    info.warnings.push(`Êï∞ÁªÑÊï∞ÈáèËæÉÂ§ö (${info.arrays} ‰∏™)ÔºåÂèØËÉΩÂΩ±ÂìçÊÄßËÉΩ`);
                }
                if (info.mergedArrays > 0) {
                    info.warnings.push(`Â∑≤ÂêàÂπ∂ ${info.mergedArrays} ‰∏™Êï∞ÁªÑÁöÑ‰∏çÂêåÁªìÊûÑÂ≠óÊÆµ`);
                }

                return info;
            }, []);

            // ÁîüÊàê‰ª£Á†ÅÂáΩÊï∞
            const generateCode = useCallback(() => {
                setIsGenerating(true);
                setError("");
                setGenerationInfo(null);

                try {
                    const content = jsonEditorInstance.current?.getValue() || jsonText;
                    // Ê†πÊçÆÂΩìÂâçÊ†ºÂºèËß£Êûê‰∏∫ÂØπË±°
                    const obj = parseCurrentContent(content, dataFormat);

                    // Ê≥®ÈáäÂè™Âú® JSON Ê®°Âºè‰∏ãÂ∞ùËØïÊèêÂèñ
                    let comments = null;
                    if (dataFormat === 'json') {
                         try {
                             comments = parseJsonWithComments(content).comments;
                         } catch (e) {}
                    }

                    const timeFieldsCount = detectTime ? detectTimeFields(obj) : 0;
                    setTimeFieldsDetected(timeFieldsCount);

                    const genInfo = collectGenerationInfo(obj, lang, detectTime, mergeArrayFields);
                    setGenerationInfo(genInfo);

                    const processedObj = processObject(obj);
                    const code = generateCodeFromObject(
                        processedObj,
                        lang,
                        structName,
                        goTags,
                        inlineStruct,
                        detectTime,
                        includeComments ? comments : null,
                        caseFormat
                    );

                    setGeneratedCode(code);

                    // Âº∫Âà∂Êõ¥Êñ∞‰ª£Á†ÅÁºñËæëÂô®ÔºåÊó†ËÆ∫ÊòØÂê¶ÂèØËßÅ
                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(code);

                            // Á´ãÂç≥ÊâßË°åÂ∏ÉÂ±ÄÊõ¥Êñ∞
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }

                    const lines = code.split('\n').length;
                    const chars = code.length;
                    setCodeStats({ lines, chars });

                } catch (err) {
                    const errorMsg = `Êï∞ÊçÆËß£ÊûêÈîôËØØ: ${err.message}`;
                    setError(errorMsg);

                    const errorCode = `// ${errorMsg}\n// ËØ∑Ê£ÄÊü•ËæìÂÖ•Ê†ºÂºèÊòØÂê¶Ê≠£Á°Æ`;
                    setGeneratedCode(errorCode);

                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(errorCode);
                        }
                    }

                    setCodeStats({ lines: 2, chars: errorCode.length });
                    setTimeFieldsDetected(0);
                    setGenerationInfo(null);
                } finally {
                    setIsGenerating(false);
                }
            }, [lang, goTags, structName, inlineStruct, detectTime, jsonText, dataFormat, mergeArrayFields, detectTimeFields, includeComments, caseFormat, parseCurrentContent, collectGenerationInfo, processObject]);

            // ÈÄöÁî®Ê†ºÂºèÂåñÂáΩÊï∞
            const formatJson = () => {
                if (dataFormat === 'json') {
                    formatJsonIntelligently();
                } else {
                    // ÂÖ∂‰ªñÊ†ºÂºèÔºåÈÄöËøá parse -> stringify Âæ™ÁéØÊù•Ê†ºÂºèÂåñ
                    // ÊàñËÄÖ XML ÊúâËá™Â∑±ÁöÑÊ†ºÂºèÂåñÈÄªËæëÔºüÁõÆÂâçÂÖàÂà©Áî®ËΩ¨Êç¢ÈÄªËæë
                    try {
                        const content = jsonEditorInstance.current?.getValue() || jsonText;
                        const obj = parseCurrentContent(content, dataFormat);
                        let formatted = '';
                        if (dataFormat === 'xml') formatted = jsonToXml(obj);
                        else if (dataFormat === 'yaml') formatted = jsonToYaml(obj);
                        else if (dataFormat === 'ini' || dataFormat === 'toml') formatted = jsonToIni(obj);

                        if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(formatted);
                        setJsonText(formatted);
                        setError(""); // ÈúÄÊ±Ç1: ÊàêÂäü‰∏çÊòæÁ§∫ÊèêÁ§∫
                    } catch (e) {
                         setError(`Ê†ºÂºèÂåñÂ§±Ë¥•: ${e.message}`);
                    }
                }
            };

            const minifyJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj } = parseJsonWithComments(jsonValue);
                    const minified = JSON.stringify(obj);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(minified);
                    }
                    setJsonText(minified);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`ÂéãÁº©ÈîôËØØ: ${err.message}`);
                }
            };

            const escapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const escaped = JSON.stringify(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(escaped);
                    }
                    setJsonText(escaped);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`ËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            const unescapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const unescaped = JSON.parse(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(unescaped);
                    }
                    setJsonText(unescaped);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`ÂéªËΩ¨‰πâÈîôËØØ: ${err.message}`);
                }
            };

            // ÊîπËøõÁöÑÁßªÈô§Ê≥®ÈáäÂáΩÊï∞
            const removeComments = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;

                    const removeJsonComments = (jsonString) => {
                        const lines = jsonString.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const cleaned = removeJsonComments(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(cleaned);
                    }
                    setJsonText(cleaned);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`ÁßªÈô§Ê≥®ÈáäÈîôËØØ: ${err.message}`);
                }
            };

            // ÈúÄÊ±Ç2Âíå3ÔºöÊ∏ÖÁ©∫ÂäüËÉΩÔºåÂêåÊó∂Ê∏ÖÁ©∫JSONÊ°ÜÂíå‰ª£Á†ÅÊ°Ü
            const clearAll = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue('');
                }
                if (codeEditorInstance.current) {
                    codeEditorInstance.current.setValue('');
                }
                setJsonText('');
                setGeneratedCode('');
                setError("");
                setFormatErrors([]);
                setGenerationInfo(null);
                setJsonStats({ lines: 0, chars: 0, commentLines: 0, errorLines: 0 });
                setCodeStats({ lines: 0, chars: 0 });
                setTimeFieldsDetected(0);
            };

            const loadComplexJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(COMPLEX_JSON);
                }
                setJsonText(COMPLEX_JSON);
                setError("");
                setFormatErrors([]);
                setJsonStats(prev => ({ ...prev, errorLines: 0 }));
            };

            // Â§çÂà∂‰ª£Á†ÅÂà∞Ââ™Ë¥¥Êùø
            const copyCode = () => {
                if (generatedCode) {
                    navigator.clipboard.writeText(generatedCode)
                        .then(() => {
                            console.log("‰ª£Á†ÅÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø");
                        })
                        .catch(err => {
                            console.error("Â§çÂà∂Â§±Ë¥•:", err);
                        });
                }
            };

            // ‰∏ãËΩΩ‰ª£Á†Å
            const downloadCode = () => {
                if (!generatedCode) return;

                const blob = new Blob([generatedCode], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${structName}.${LANGUAGE_CONFIG[lang].fileExt}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // Â§ÑÁêÜGoÊ†áÁ≠æÊõ¥Êñ∞
            const updateGoTag = (tag, checked) => {
                setGoTags(prev => ({
                    ...prev,
                    [tag]: checked
                }));
            };

            // ‰øÆÂ§çÁöÑtoggleCodeGenModeÂáΩÊï∞
            const toggleCodeGenMode = () => {
                const newMode = !isCodeGenMode;
                setIsCodeGenMode(newMode);
                // ‰∫íÊñ•ÔºöÊâìÂºÄ‰ª£Á†ÅÁîüÊàêÔºåÂÖ≥Èó≠ÂØπÊØî
                if (newMode && isDiffMode) {
                    setIsDiffMode(false);
                    setDiffResult(null);
                    // Ê∏ÖÁêÜ Diff ÁºñËæëÂô®
                    if (diffEditorInstance.current) {
                        diffEditorInstance.current.dispose();
                        diffEditorInstance.current = null;
                    }
                }

                // ÂΩìÈáçÊñ∞ÊâìÂºÄ‰ª£Á†ÅÁîüÊàêÊ®°ÂºèÊó∂ÔºåÁ°Æ‰øù‰ª£Á†ÅÁºñËæëÂô®ÂÜÖÂÆπÊòØÊúÄÊñ∞ÁöÑ
                if (newMode && generatedCode && codeEditorInstance.current) {
                    // ÁªôDOM‰∏Ä‰∫õÊó∂Èó¥Êù•Ê∏≤Êüì
                    setTimeout(() => {
                        const model = codeEditorInstance.current.getModel();
                        if (model && model.getValue() !== generatedCode) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(generatedCode);

                            // Âº∫Âà∂ÈáçÊñ∞Â∏ÉÂ±Ä
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }, 50);
                }
            };

            // ÁõëÂê¨ generatedCode ÂèòÂåñÔºåÁ°Æ‰øù‰ª£Á†ÅÁºñËæëÂô®ÂêåÊ≠•Êõ¥Êñ∞
            useEffect(() => {
                if (codeEditorInstance.current && generatedCode && isCodeGenMode) {
                    const model = codeEditorInstance.current.getModel();
                    if (model && model.getValue() !== generatedCode) {
                        codeEditorInstance.current.pushUndoStop();
                        model.setValue(generatedCode);

                        // Âª∂ËøüÂ∏ÉÂ±ÄÊõ¥Êñ∞ÔºåÁ°Æ‰øùDOMÂ∑≤Ê∏≤Êüì
                        setTimeout(() => {
                            if (codeEditorInstance.current) {
                                codeEditorInstance.current.layout();
                            }
                        }, 10);
                    }
                }
            }, [generatedCode, isCodeGenMode]);

            return React.createElement("div", { className: "app-container" },
                React.createElement("div", { className: "header" },
                    React.createElement("h1", null,
                        React.createElement("i", { className: "fas fa-code" }),
                        "JSON ‚Üí Â§öËØ≠Ë®ÄÁªìÊûÑ‰ΩìÁîüÊàêÂô®"
                    ),
                    React.createElement("div", { className: "subtitle" },
                        "ÊîØÊåÅ Golang, Java, TypeScript, Python, Kotlin, Rust"
                    )
                ),

                React.createElement("div", { className: "config-panel" },
                    React.createElement("div", { className: "config-content" },
                        // ÈúÄÊ±Ç 2: ÂØπÊØîÊ®°Âºè‰∏ãÈöêËóèÂ§ßÈÉ®ÂàÜÊåâÈíÆÔºåÂè™ÁïôÂØπÊØîÂºÄÂÖ≥ (‰ª•ÂèäÂèØËÉΩÁöÑÊâßË°åÂØπÊØî)
                        // ÈúÄÊ±Ç 1: ‰∏çÂêåÊ†ºÂºèÊòæÁ§∫‰∏çÂêåÊåâÈíÆ

                        React.createElement("div", { className: "action-buttons compact-actions" },
                            // ÂØπÊØîÊ®°Âºè‰∏ãÂè™ÊòæÁ§∫ÂØπÊØîÁõ∏ÂÖ≥ÁöÑ
                            isDiffMode ? (
                                React.createElement(React.Fragment, null,
                                    React.createElement("button", {
                                            className: "btn btn-primary btn-compact",
                                            onClick: performDiff,
                                            title: "ÊâßË°åJSONÂØπÊØî"
                                        },
                                        React.createElement("i", { className: "fas fa-code-compare" }),
                                        "ÊâßË°åÂØπÊØî"
                                    )
                                )
                            ) : (
                                React.createElement(React.Fragment, null,
                                    // ‰ª£Á†ÅÁîüÊàêÂºÄÂÖ≥ (ÈùûÂØπÊØîÊ®°Âºè‰∏ãÊòæÁ§∫)
                                    React.createElement("div", { className: "mode-switch-inline" },
                                        React.createElement("label", { className: "switch" },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                checked: isCodeGenMode,
                                                onChange: toggleCodeGenMode
                                            }),
                                            React.createElement("span", { className: "slider" })
                                        ),
                                        React.createElement("span", { className: "switch-label" },
                                            "‰ª£Á†ÅÁîüÊàê"
                                        )
                                    ),

                                    // ‰ªÖÂú® JSON Ê®°Âºè‰∏ãÊòæÁ§∫ÂÆåÊï¥Â∑•ÂÖ∑Ê†è
                                    dataFormat === 'json' ? (
                                        React.createElement(React.Fragment, null,
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: formatJson,
                                                title: "Êô∫ËÉΩÊ†ºÂºèÂåñ"
                                            }, React.createElement("i", { className: "fas fa-indent" }), "Ê†ºÂºèÂåñ"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: removeComments,
                                                title: "ÁßªÈô§Ê≥®Èáä"
                                            }, React.createElement("i", { className: "fas fa-comment-slash" }), "ÂéªÊ≥®Èáä"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: minifyJson,
                                                title: "ÂéãÁº©"
                                            }, React.createElement("i", { className: "fas fa-compress" }), "ÂéãÁº©"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: escapeJson,
                                                title: "ËΩ¨‰πâ"
                                            }, React.createElement("i", { className: "fas fa-code" }), "ËΩ¨‰πâ"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: unescapeJson,
                                                title: "ÂéªËΩ¨‰πâ"
                                            }, React.createElement("i", { className: "fas fa-code" }), "ÂéªËΩ¨‰πâ"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: convertChineseToUnicode,
                                                title: "‰∏≠Êñá‚ÜíUnicode"
                                            }, React.createElement("i", { className: "fas fa-language" }), "‰∏≠Êñá‚ÜíUni"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: convertUnicodeToChinese,
                                                title: "Unicode‚Üí‰∏≠Êñá"
                                            }, React.createElement("i", { className: "fas fa-language" }), "Uni‚Üí‰∏≠Êñá"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: loadComplexJson,
                                                title: "Â§çÊùÇÁ§∫‰æã"
                                            }, React.createElement("i", { className: "fas fa-cogs" }), "Â§çÊùÇÁ§∫‰æã"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: clearAll,
                                                title: "Ê∏ÖÁ©∫"
                                            }, React.createElement("i", { className: "fas fa-trash" }), "Ê∏ÖÁ©∫")
                                        )
                                    ) : (
                                        // ÂÖ∂‰ªñÊ®°ÂºèÂè™ÊòæÁ§∫ Ê†ºÂºèÂåñ„ÄÅÊ∏ÖÁ©∫
                                        React.createElement(React.Fragment, null,
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: formatJson,
                                                title: "Ê†ºÂºèÂåñ"
                                            }, React.createElement("i", { className: "fas fa-indent" }), "Ê†ºÂºèÂåñ"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: clearAll,
                                                title: "Ê∏ÖÁ©∫"
                                            }, React.createElement("i", { className: "fas fa-trash" }), "Ê∏ÖÁ©∫")
                                        )
                                    ),

                                    // ‰ª£Á†ÅÁîüÊàêÊåâÈíÆ (Âú®ÂºÄÂêØ‰ª£Á†ÅÁîüÊàê‰∏îÈùûÂØπÊØîÊ®°Âºè‰∏ã)
                                    isCodeGenMode && React.createElement("button", {
                                            className: "btn btn-primary btn-compact",
                                            onClick: generateCode,
                                            disabled: isGenerating,
                                            title: "ÁîüÊàê‰ª£Á†Å"
                                        },
                                        isGenerating ? "ÁîüÊàê‰∏≠..." : "ÁîüÊàê‰ª£Á†Å"
                                    )
                                )
                            ),

                            // ÂØπÊØîÊ®°ÂºèÂºÄÂÖ≥ (ÂßãÁªàÊòæÁ§∫ÊàñÂú®Âè≥‰æß)
                            React.createElement("div", { className: "mode-switch-inline", style: { marginLeft: "auto" } },
                                React.createElement("label", { className: "switch" },
                                    React.createElement("input", {
                                        type: "checkbox",
                                        checked: isDiffMode,
                                        onChange: toggleDiffMode
                                    }),
                                    React.createElement("span", { className: "slider" })
                                ),
                                React.createElement("span", { className: "switch-label" },
                                    "ÂØπÊØîÊ®°Âºè"
                                )
                            )
                        ),

            isCodeGenMode && React.createElement("div", { className: "config-row code-gen-config" },
                React.createElement("div", { className: "config-group compact-group" },
                    React.createElement("label", { htmlFor: "language-select" }, "ÁõÆÊ†áËØ≠Ë®Ä"),
                    React.createElement("div", { className: "language-select" },
                        React.createElement("select", {
                                id: "language-select",
                                value: lang,
                                onChange: (e) => setLang(e.target.value),
                                className: "compact-select"
                            },
                            Object.entries(LANGUAGE_CONFIG).map(([value, config]) =>
                                React.createElement("option", { key: value, value: value },
                                    `${config.icon} ${config.name}`
                                )
                            )
                        )
                    )
                ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "struct-name" }, "ÁªìÊûÑ‰ΩìÂêç"),
                                React.createElement("input", {
                                    id: "struct-name",
                                    type: "text",
                                    value: structName,
                                    onChange: (e) => setStructName(e.target.value),
                                    className: "compact-input"
                                })
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "case-format" }, "ÂëΩÂêçÊ†ºÂºè"),
                                React.createElement("select", {
                                        id: "case-format",
                                        className: "format-select case-format-select compact-select",
                                        value: caseFormat,
                                        onChange: (e) => setCaseFormat(e.target.value)
                                    },
                                    Object.entries(CASE_FORMATS).map(([value, config]) =>
                                        React.createElement("option", { key: value, value: value },
                                            config.name
                                        )
                                    )
                                )
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "ÈÄâÈ°π"),
                                React.createElement("div", { className: "checkbox-options compact-options" },
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "inline-struct",
                                            checked: inlineStruct,
                                            onChange: (e) => setInlineStruct(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "inline-struct",
                                            title: "ÂÜÖËÅîÁªìÊûÑ‰Ωì"
                                        }, "ÂÜÖËÅî")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "detect-time",
                                            checked: detectTime,
                                            onChange: (e) => setDetectTime(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "detect-time",
                                            title: "Ê£ÄÊµãÊó∂Èó¥Á±ªÂûã"
                                        }, "Êó∂Èó¥")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "include-comments",
                                            checked: includeComments,
                                            onChange: (e) => setIncludeComments(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "include-comments",
                                            title: "ÂåÖÂê´Ê≥®Èáä"
                                        }, "Ê≥®Èáä")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "merge-array-fields",
                                            checked: mergeArrayFields,
                                            onChange: (e) => setMergeArrayFields(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "merge-array-fields",
                                            title: "ÂêàÂπ∂Êï∞ÁªÑÂ≠óÊÆµ"
                                        }, "ÂêàÂπ∂Êï∞ÁªÑ")
                                    )
                                )
                            ),

                            lang === "go" && React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "GoÊ†áÁ≠æ"),
                                React.createElement("div", { className: "go-tags-container compact-tags" },
                                    Object.entries(goTags).map(([tag, checked]) =>
                                        React.createElement("div", { className: "tag-checkbox compact-tag", key: tag },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                id: `tag-${tag}`,
                                                checked: checked,
                                                onChange: (e) => updateGoTag(tag, e.target.checked)
                                            }),
                                            React.createElement("label", {
                                                htmlFor: `tag-${tag}`,
                                                title: tag
                                            }, tag === "omitempty" ? "omit" : tag)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    error && React.createElement("div", { className: "error-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        error
                    ),

                    isCodeGenMode && generationInfo && React.createElement("div", { className: "generation-info" },
                        React.createElement("div", { className: "generation-info-compact" },
                            React.createElement("div", { className: "generation-info-group" },
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Â≠óÊÆµ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.totalFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂµåÂ•ó: "),
                                    React.createElement("span", { className: "value" }, generationInfo.nestedObjects)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êï∞ÁªÑ: "),
                                    React.createElement("span", { className: "value" }, generationInfo.arrays)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Êó∂Èó¥: "),
                                    React.createElement("span", { className: "value" }, generationInfo.timeFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "Ê∑±Â∫¶: "),
                                    React.createElement("span", { className: "value" }, generationInfo.maxDepth)
                                ),
                                generationInfo.mergedArrays > 0 && React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "ÂêàÂπ∂: "),
                                    React.createElement("span", { className: "value warning" }, generationInfo.mergedArrays)
                                )
                            )
                        )
                    ),

                    isCodeGenMode && generationInfo && generationInfo.warnings.length > 0 &&
                    React.createElement("div", { className: "warning-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        React.createElement("div", null,
                            generationInfo.warnings.map((warning, index) =>
                                React.createElement("div", { key: index }, warning)
                            )
                        )
                    ),

                    // ÊòæÁ§∫Ê†ºÂºèÂåñÈîôËØØËØ¶ÁªÜ‰ø°ÊÅØ
                    formatErrors.length > 0 && React.createElement("div", { className: "format-error-details" },
                        React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "6px", marginBottom: "6px" } },
                            React.createElement("i", { className: "fas fa-exclamation-circle" }),
                            React.createElement("strong", null, `ÂèëÁé∞ ${formatErrors.length} ‰∏™Ê†ºÂºèÈîôËØØ:`)
                        ),
                        formatErrors.slice(0, 5).map((error, index) =>
                            React.createElement("div", { key: index, className: "format-error-line" },
                                React.createElement("span", { className: "unicode-preview" },
                                    `Á¨¨ ${error.line} Ë°å: ${error.error}`
                                ),
                                index < 3 && error.index &&
                                    React.createElement("span", { style: { fontSize: "10px", color: "#94a3b8" } },
                                        `‰ΩçÁΩÆ: ${error.index}`
                                    )
                            )
                        ),
                        formatErrors.length > 5 &&
                            React.createElement("div", { className: "unicode-preview", style: { marginTop: "4px" } },
                                `... ËøòÊúâ ${formatErrors.length - 5} ‰∏™ÈîôËØØ`
                            )
                    )
                ),

                React.createElement("div", { className: "editor-panels" },
                    !isDiffMode && React.createElement("div", {
                            className: `panel ${isCodeGenMode ? 'json-panel partial-width' : 'json-panel full-width'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-header-content" },
                                React.createElement("div", { className: "panel-title" },
                                    React.createElement("i", { className: "fas fa-code" }),
                                    DATA_FORMATS[dataFormat].name + " ËæìÂÖ•"
                                ),
                                // ÈúÄÊ±Ç2ÔºöÊ†ºÂºèËΩ¨Êç¢ÂäüËÉΩÂµåÂÖ•headerÊ†è - ÈÄâÊã©ÁõÆÊ†áÊ†ºÂºèËá™Âä®ËΩ¨Êç¢
                                React.createElement("div", { className: "header-conversion-tools" },
                                    React.createElement("span", { style: { fontSize: "12px", color: "#94a3b8", marginRight: "4px" } }, "ËΩ¨Êç¢‰∏∫:"),
                                    React.createElement("select", {
                                        className: "format-select compact-select",
                                        value: dataFormat,
                                        onChange: (e) => convertFormat(e.target.value),
                                        title: "ÈÄâÊã©ÁõÆÊ†áÊ†ºÂºèËá™Âä®ËΩ¨Êç¢"
                                    },
                                        // ÈúÄÊ±Ç1ÔºöÈùûÂØπÊØîÊ®°Âºè‰∏ãËøáÊª§ text Á±ªÂûã
                                        Object.entries(DATA_FORMATS)
                                            .filter(([val]) => val !== 'text')
                                            .map(([value, config]) =>
                                                React.createElement("option", { key: value, value: value },
                                                    config.name
                                                )
                                            )
                                    )
                                )
                            ),
                            React.createElement("div", { className: "json-tools" },
                                React.createElement("div", { className: "panel-stats" },
                                    `${jsonStats.lines} Ë°å, ${jsonStats.chars} Â≠óÁ¨¶`,
                                    jsonStats.commentLines > 0 &&
                                        React.createElement("span", { style: { marginLeft: "8px", color: "#60a5fa" } },
                                            `${jsonStats.commentLines} Ê≥®Èáä`
                                        ),
                                    jsonStats.errorLines > 0 &&
                                        React.createElement("span", { style: { marginLeft: "8px", color: "#f87171" } },
                                            `${jsonStats.errorLines} ÈîôËØØ`
                                        )
                                )
                            )
                        ),
                        React.createElement("div", {
                            ref: jsonEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // ‰øÆÂ§çÔºöÂßãÁªàÊ∏≤Êüì‰ª£Á†ÅÈù¢ÊùøÔºåÁî®CSSÊéßÂà∂ÊòæÁ§∫
                    !isDiffMode && React.createElement("div", {
                            className: `panel code-panel ${isCodeGenMode ? '' : 'hidden'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-file-code" }),
                                `${LANGUAGE_CONFIG[lang].name} ‰ª£Á†Å`
                            ),
                            React.createElement("div", { className: "panel-stats" },
                                generatedCode && isCodeGenMode
                                    ? `${codeStats.lines} Ë°å, ${codeStats.chars} Â≠óÁ¨¶`
                                    : "Á≠âÂæÖÁîüÊàê‰ª£Á†Å"
                            )
                        ),
                        React.createElement("div", {
                            ref: codeEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // ÈúÄÊ±Ç2ÔºöÂØπÊØîÊ®°ÂºèÂ∏ÉÂ±Ä (Â∑¶35% - ‰∏≠30% - Âè≥35%)
                    isDiffMode && React.createElement("div", { className: "diff-layout", style: { width: '100%' } },

                        // Â∑¶‰æßÁºñËæëÂô® (35%)
                        React.createElement("div", { className: "diff-side", style: { flex: '0 0 35%', maxWidth: '35%', width: '35%' } },
                            // Â∑¶‰æß Header
                            React.createElement("div", { className: "diff-header" },
                                React.createElement("div", { className: "diff-title" },
                                    React.createElement("select", {
                                            className: "format-select compact-select",
                                            value: leftFormat,
                                            onChange: (e) => {
                                                setLeftFormat(e.target.value);
                                                if (jsonEditorInstance.current) {
                                                    const model = jsonEditorInstance.current.getModel();
                                                    if (model) monaco.editor.setModelLanguage(model, DATA_FORMATS[e.target.value].monacoLang);
                                                }
                                            },
                                            style: { marginRight: '8px' }
                                        },
                                        Object.entries(DATA_FORMATS).map(([val, conf]) =>
                                            React.createElement("option", { key: val, value: val }, conf.name)
                                        )
                                    ),
                                    "ÂéüÂßãÊñáÊú¨"
                                ),
                                React.createElement("div", { className: "header-conversion-tools" },
                                    leftFormat !== 'text' && React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => formatEditorContent(jsonEditorInstance.current, leftFormat, setJsonText),
                                        title: "Ê†ºÂºèÂåñ"
                                    }, React.createElement("i", { className: "fas fa-indent" })),
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => {
                                            if (jsonEditorInstance.current) jsonEditorInstance.current.setValue('');
                                            setJsonText('');
                                        },
                                        title: "Ê∏ÖÁ©∫"
                                    }, React.createElement("i", { className: "fas fa-trash" }))
                                )
                            ),
                            React.createElement("div", {
                                ref: diffLeftEditorRef,
                                className: "diff-content"
                            })
                        ),

                        // ‰∏≠Èó¥Â∑ÆÂºÇ‰ø°ÊÅØÊ°Ü (30%) - ÁªàÁ´ØÊ†∑Âºè
                        React.createElement("div", { className: "diff-info-panel", style: { flex: '0 0 30%', maxWidth: '30%', width: '30%' } },
                             React.createElement("div", { className: "terminal-header" },
                                React.createElement("div", { className: "terminal-dot", style: { background: '#ef4444' } }),
                                React.createElement("div", { className: "terminal-dot", style: { background: '#eab308' } }),
                                React.createElement("div", { className: "terminal-dot", style: { background: '#22c55e' } }),
                                React.createElement("span", { style: { marginLeft: '10px' } }, "Diff Analysis Terminal")
                             ),
                             React.createElement("div", { className: "terminal-content" },
                                 !diffAnalysis ?
                                    React.createElement("div", { style: { color: '#64748b' } },
                                        "> Á≠âÂæÖÊâßË°åÂØπÊØî...\n> ËØ∑ÁÇπÂáª‰∏äÊñπ 'ÊâßË°åÂØπÊØî' ÊåâÈíÆ"
                                    ) :
                                    React.createElement(React.Fragment, null,
                                        React.createElement("div", { style: { marginBottom: '10px', borderBottom: '1px dashed #334155', paddingBottom: '10px' } },
                                            React.createElement("div", null, `> ÂéüÂßãÊ†ºÂºè: ${DATA_FORMATS[diffAnalysis.leftFormat].name}`),
                                            React.createElement("div", null, `> ÁõÆÊ†áÊ†ºÂºè: ${DATA_FORMATS[diffAnalysis.rightFormat].name}`),
                                            React.createElement("div", null, `> Â∑ÆÂºÇÁªüËÆ°: +${diffAnalysis.stats.added} / -${diffAnalysis.stats.removed} / ~${diffAnalysis.stats.modified}`)
                                        ),
                                        diffAnalysis.differences.length === 0 ?
                                            React.createElement("div", { style: { color: '#22c55e' } }, "> ‚àö ‰∏§‰ªΩÊï∞ÊçÆÂú®ËØ≠‰πâ‰∏äÂÆåÂÖ®‰∏ÄËá¥") :
                                            diffAnalysis.differences.map((diff, i) =>
                                                React.createElement("div", { key: i, style: { marginBottom: '8px', fontFamily: 'monospace' } },
                                                    React.createElement("div", { style: { color: '#94a3b8' } }, `PATH: ${diff.path || '(root)'}`),
                                                    (diff.type === 'removed' || diff.type === 'modified') &&
                                                        React.createElement("div", { style: { color: '#ef4444' } }, `- ${JSON.stringify(diff.oldValue !== undefined ? diff.oldValue : diff.value)}`),
                                                    (diff.type === 'added' || diff.type === 'modified') &&
                                                        React.createElement("div", { style: { color: '#22c55e' } }, `+ ${JSON.stringify(diff.newValue !== undefined ? diff.newValue : diff.value)}`)
                                                )
                                            )
                                    )
                             )
                        ),

                        // Âè≥‰æßÁºñËæëÂô® (35%)
                        React.createElement("div", { className: "diff-side", style: { flex: '0 0 35%', maxWidth: '35%', width: '35%' } },
                            // Âè≥‰æß Header
                            React.createElement("div", { className: "diff-header" },
                                React.createElement("div", { className: "diff-title" },
                                    React.createElement("select", {
                                            className: "format-select compact-select",
                                            value: rightFormat,
                                            onChange: (e) => {
                                                setRightFormat(e.target.value);
                                                if (diffEditorInstance.current) {
                                                    const model = diffEditorInstance.current.getModel();
                                                    if (model) monaco.editor.setModelLanguage(model, DATA_FORMATS[e.target.value].monacoLang);
                                                }
                                            },
                                            style: { marginRight: '8px' }
                                        },
                                        Object.entries(DATA_FORMATS).map(([val, conf]) =>
                                            React.createElement("option", { key: val, value: val }, conf.name)
                                        )
                                    ),
                                    "ÂØπÊØîÊñáÊú¨"
                                ),
                                React.createElement("div", { className: "header-conversion-tools" },
                                    rightFormat !== 'text' && React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => formatEditorContent(diffEditorInstance.current, rightFormat, setDiffText),
                                        title: "Ê†ºÂºèÂåñ"
                                    }, React.createElement("i", { className: "fas fa-indent" })),
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => {
                                            if (diffEditorInstance.current) diffEditorInstance.current.setValue('');
                                            setDiffText('');
                                        },
                                        title: "Ê∏ÖÁ©∫"
                                    }, React.createElement("i", { className: "fas fa-trash" }))
                                )
                            ),
                            React.createElement("div", {
                                ref: diffEditorRef,
                                className: "diff-content"
                            })
                        )
                    )
                ),

                isCodeGenMode && React.createElement("div", { className: "status-bar" },
                    React.createElement("div", { className: "status-item" },
                        React.createElement("div", { className: "language-badge" },
                            // Âà§Êñ≠ÊòØ Emoji ËøòÊòØ FontAwesome Á±ªÂêç
                            LANGUAGE_CONFIG[lang].icon.startsWith('fa')
                                ? React.createElement("i", { className: LANGUAGE_CONFIG[lang].icon })
                                : React.createElement("span", { style: { marginRight: '6px' } }, LANGUAGE_CONFIG[lang].icon),
                            LANGUAGE_CONFIG[lang].name
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: inlineStruct ? "#86efac" : "#fbbf24"
                                }
                            },
                            inlineStruct ? "ÂÜÖËÅîÊ®°Âºè" : "ÊãÜÂàÜÊ®°Âºè"
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: includeComments ? "#86efac" : "#94a3b8"
                                }
                            },
                            includeComments ? "Âê´Ê≥®Èáä" : "Êó†Ê≥®Èáä"
                        ),
                        detectTime && timeFieldsDetected > 0 &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#60a5fa"
                                }
                            },
                            `Êó∂Èó¥Â≠óÊÆµ: ${timeFieldsDetected}`
                        ),
                        mergeArrayFields &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#fbbf24"
                                }
                            },
                            "ÂêàÂπ∂Êï∞ÁªÑ"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("i", { className: "fas fa-info-circle info-icon" }),
                        React.createElement("span", null,
                            CASE_FORMATS[caseFormat]?.name || "Â§ßÈ©ºÂ≥∞ (PascalCase)"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: copyCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-copy" }),
                            "Â§çÂà∂"
                        ),
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: downloadCode,
                                disabled: !generatedCode,
                            },
                            React.createElement("i", { className: "fas fa-download" }),
                            "‰∏ãËΩΩ"
                        )
                    )
                )
            )
        }

        // ============= ‰øÆÂ§çÁöÑËæÖÂä©ÂáΩÊï∞ =============

        function isTimeString(value) {
            return TIME_PATTERNS.some(pattern => pattern.test(value));
        }

        function isTimeFieldName(fieldName) {
            return /(time|date|timestamp|created|updated|start|end|at)$/i.test(fieldName);
        }

        function isTimeField(key, value) {
            if (typeof value === 'string' && isTimeString(value)) {
                return true;
            }
            if (isTimeFieldName(key)) {
                return true;
            }
            return false;
        }

        function getTimeType(lang) {
            switch(lang) {
                case 'go': return 'time.Time';
                case 'java': return 'java.time.LocalDateTime';
                case 'typescript': return 'Date';
                case 'python': return 'datetime.datetime';
                case 'kotlin': return 'java.time.LocalDateTime';
                case 'rust': return 'chrono::DateTime<chrono::Utc>';
                default: return 'string';
            }
        }

        // ‰øÆÂ§çÁöÑÂ≠óÊÆµÂêçÊ†ºÂºèÂåñÂáΩÊï∞Ôºà‰øùÁïô‰∏≠ÊñáÔºâ
        function formatFieldName(name, format, lang, isStructName = false) {
            if (!name || name.trim() === '') return name;

            // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏≠ÊñáÂ≠óÊÆµ
            const hasChinese = /[\u4e00-\u9fa5]/.test(name);

            let cleaned = name;

            // Â¶ÇÊûú‰∏çÊòØ‰∏≠ÊñáÔºåËøõË°åÊ†ºÂºèËΩ¨Êç¢
            if (!hasChinese && CASE_FORMATS[format]) {
                cleaned = CASE_FORMATS[format].fn(cleaned);
            }

            // GoËØ≠Ë®ÄÁöÑÁªìÊûÑ‰ΩìÂêçÈúÄË¶ÅÈ¶ñÂ≠óÊØçÂ§ßÂÜô
            if (lang === 'go' && isStructName) {
                if (hasChinese) {
                    cleaned = cleaned;
                } else {
                    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
                }
            }

            // Â¶ÇÊûúÂºÄÂ§¥ÊòØÊï∞Â≠óÔºåÊ∑ªÂä†ÂâçÁºÄ
            if (/^\d/.test(cleaned)) {
                cleaned = 'field' + cleaned;
            }

            return cleaned;
        }

        function generateCodeFromObject(obj, lang, structName, goTags, inlineStruct, detectTime, comments, caseFormat) {
            const formatName = (name, isStructName = false) =>
                formatFieldName(name, caseFormat, lang, isStructName);

            if (lang === "go") return genGo(obj, formatName(structName, true), goTags, inlineStruct, detectTime, comments, formatName);
            if (lang === "typescript") return genTypeScript(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "java") return genJava(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "python") return genPython(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "kotlin") return genKotlin(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "rust") return genRust(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            return `// ‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä: ${lang}`;
        }

        // ‰øÆÂ§çÁöÑinferTypeÂáΩÊï∞ÔºåÊîØÊåÅÂ§öÁª¥Êï∞ÁªÑ
        function inferType(value, lang, key = '', detectTime = false, parentPath = '') {
            if (detectTime && isTimeField(key, value)) {
                return getTimeType(lang);
            }

            if (value === null) {
                if (lang === "typescript") return "null";
                if (lang === "java") return "Object";
                if (lang === "kotlin") return "Any?";
                if (lang === "rust") return "Option<serde_json::Value>";
                return "any";
            }

            if (Array.isArray(value)) {
                if (value.length === 0) {
                    if (lang === "go") return "[]interface{}";
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                const firstItem = value[0];

                // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                if (Array.isArray(firstItem)) {
                    // ÈÄíÂΩíÊé®Êñ≠ÂÜÖÈÉ®Êï∞ÁªÑÁ±ªÂûã
                    const innerType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                    const baseType = innerType
                        .replace('[]', '')
                        .replace('List<', '')
                        .replace('>', '')
                        .replace('Vec<', '')
                        .replace('List[', '')
                        .replace(']', '');

                    if (lang === "go") return `[][]${baseType}`;
                    if (lang === "typescript") return `${baseType}[][]`;
                    if (lang === "java") return `List<List<${baseType}>>`;
                    if (lang === "kotlin") return `List<List<${baseType}>>`;
                    if (lang === "rust") return `Vec<Vec<${baseType}>>`;
                    if (lang === "python") return `List[List[${baseType}]]`;
                }

                // Ê£ÄÊü•Êï∞ÁªÑÂÖÉÁ¥†ÊòØÂê¶ÈÉΩÊòØÂØπË±°
                const allObjects = value.every(item => item && typeof item === 'object' && !Array.isArray(item));

                if (allObjects) {
                    // ÂØπ‰∫éGoËØ≠Ë®ÄÔºåËøîÂõûÂç†‰ΩçÁ¨¶ÔºåÁî±‰∏äÂ±ÇÂáΩÊï∞Â§ÑÁêÜ
                    if (lang === "go") return "[]struct{}";
                    // ÂÖ∂‰ªñËØ≠Ë®ÄËøîÂõûÈÄöÁî®Á±ªÂûã
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                const itemType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                if (lang === "go") return `[]${itemType}`;
                if (lang === "typescript") return `${itemType}[]`;
                if (lang === "java") return `List<${itemType}>`;
                if (lang === "kotlin") return `List<${itemType}>`;
                if (lang === "rust") return `Vec<${itemType}>`;
                if (lang === "python") return `List[${itemType}]`;
            }

            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                if (Object.keys(value).length === 0) {
                    if (lang === "go") return "map[string]interface{}";
                    if (lang === "typescript") return "Record<string, any>";
                    if (lang === "java") return "Map<String, Object>";
                    if (lang === "kotlin") return "Map<String, Any?>";
                    if (lang === "rust") return "HashMap<String, serde_json::Value>";
                    if (lang === "python") return "Dict[str, Any]";
                } else {
                    if (lang === "go") return "struct";
                    if (lang === "typescript") return "any";
                    if (lang === "java") return "Object";
                    if (lang === "kotlin") return "Any?";
                    if (lang === "rust") return "serde_json::Value";
                    if (lang === "python") return "dict";
                }
            }

            switch (typeof value) {
                case "number":
                    if (Number.isInteger(value)) {
                        if (value > 2147483647 || value < -2147483648) {
                            if (lang === "go") return "int64";
                            if (lang === "java") return "Long";
                            if (lang === "kotlin") return "Long";
                            if (lang === "rust") return "i64";
                        } else {
                            if (lang === "go") return "int";
                            if (lang === "typescript") return "number";
                            if (lang === "java") return "Integer";
                            if (lang === "kotlin") return "Int";
                            if (lang === "rust") return "i32";
                            if (lang === "python") return "int";
                        }
                    } else {
                        if (lang === "go") return "float64";
                        if (lang === "typescript") return "number";
                        if (lang === "java") return "Double";
                        if (lang === "kotlin") return "Double";
                        if (lang === "rust") return "f64";
                        if (lang === "python") return "float";
                    }
                    break;
                case "string":
                    if (lang === "go") return "string";
                    if (lang === "typescript") return "string";
                    if (lang === "java") return "String";
                    if (lang === "kotlin") return "String";
                    if (lang === "rust") return "String";
                    if (lang === "python") return "str";
                    break;
                case "boolean":
                    if (lang === "go") return "bool";
                    if (lang === "typescript") return "boolean";
                    if (lang === "java") return "Boolean";
                    if (lang === "kotlin") return "Boolean";
                    if (lang === "rust") return "bool";
                    if (lang === "python") return "bool";
                    break;
            }

            return "any";
        }

        // ÁîüÊàêGo‰ª£Á†Å
        function genGo(obj, name, tags, inlineStruct, detectTime, comments, formatName) {
            let allStructs = {};
            let mainStructCode = "";

            mainStructCode = genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs, 0, comments, formatName);

            let code = "";

            if (comments && comments.fieldComments[name]) {
                code += `// ${comments.fieldComments[name]}\n`;
            }

            let hasTimeField = false;
            const checkTimeField = (obj) => {
                for (const [key, value] of Object.entries(obj)) {
                    if (detectTime && isTimeField(key, value)) {
                        return true;
                    }
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        if (checkTimeField(value)) return true;
                    } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        if (checkTimeField(value[0])) return true;
                    }
                }
                return false;
            };
            hasTimeField = checkTimeField(obj);

            if (hasTimeField) {
                code = "import \"time\"\n\n" + code;
            }

            if (!inlineStruct) {
                for (const [structName, structCode] of Object.entries(allStructs)) {
                    if (structName !== name) {
                        code += structCode + "\n\n";
                    }
                }
            }

            code += mainStructCode;

            return code;
        }

        // ‰øÆÂ§çÁöÑgenGoStructÂáΩÊï∞ÔºåÊ≠£Á°ÆÂ§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑÂíåÊ∑±Â∫¶ÂêàÂπ∂
        function genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs = {}, depth = 0, comments, formatName, path = '') {
            if (depth > 20) {
                return `type ${name} struct {\n  // ÂµåÂ•óÊ∑±Â∫¶ËøáÂ§ßÔºåÂª∫ËÆÆÁÆÄÂåñJSONÁªìÊûÑ\n  Data map[string]interface{} \`json:"data"\`\n}`;
            }

            let code = `type ${name} struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);

                const comment = comments ? comments.fieldComments[key] : null;
                if (comment) {
                    code += `  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }
                if (tags.gorm) {
                    tagParts.push(`gorm:"column:${key}"`);
                }
                if (tags.yaml) {
                    tagParts.push(`yaml:"${key}"`);
                }
                if (tags.xml) {
                    tagParts.push(`xml:"${key}"`);
                }
                if (tags.validate) {
                    const validateRules = [];
                    if (typeof value === "string") {
                        if (value.includes("@")) validateRules.push("email");
                        if (key.toLowerCase().includes("url")) validateRules.push("url");
                    }
                    if (typeof value === "number") validateRules.push("numeric");
                    if (validateRules.length > 0) {
                        tagParts.push(`validate:"${validateRules.join(",")}"`);
                    }
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null) {
                    if (Array.isArray(value)) {
                        // Â§ÑÁêÜÊï∞ÁªÑÁ±ªÂûã
                        if (value.length === 0) {
                            code += `  ${fieldName} []interface{}${tagStr}\n`;
                        } else {
                            const firstItem = value[0];

                            // Â§ÑÁêÜÂ§öÁª¥Êï∞ÁªÑ
                            if (Array.isArray(firstItem)) {
                                // Â§öÁª¥Êï∞ÁªÑ‰∏≠ÁöÑÂÖÉÁ¥†ÂèØËÉΩÊòØÂØπË±°
                                const nestedItem = firstItem[0] || {};
                                if (typeof nestedItem === 'object' && nestedItem !== null && Object.keys(nestedItem).length > 0) {
                                    const itemTypeName = formatName(key, true) + 'Item';
                                    if (!allStructs[itemTypeName]) {
                                        // ÈÄíÂΩíÁîüÊàêÂµåÂ•óÁªìÊûÑ‰Ωì
                                        allStructs[itemTypeName] = genGoStruct(nestedItem, itemTypeName, tags, false, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                    code += `  ${fieldName} [][]${itemTypeName}${tagStr}\n`;
                                } else {
                                    // Â§öÁª¥Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                                    const itemType = inferType(nestedItem, "go", key, detectTime, currentPath);
                                    code += `  ${fieldName} [][]${itemType}${tagStr}\n`;
                                }
                            } else if (typeof firstItem === "object" && firstItem !== null) {
                                // ÂØπË±°Êï∞ÁªÑ
                                const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);

                                if (inlineStruct) {
                                    code += `  ${fieldName} []${genGoInlineStruct(firstItem, itemTypeName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                                } else {
                                    code += `  ${fieldName} []${itemTypeName}${tagStr}\n`;

                                    if (!allStructs[itemTypeName]) {
                                        allStructs[itemTypeName] = genGoStruct(firstItem, itemTypeName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                }
                            } else {
                                // Âü∫Êú¨Á±ªÂûãÊï∞ÁªÑ
                                const itemType = inferType(firstItem, "go", key, detectTime, currentPath);
                                code += `  ${fieldName} []${itemType}${tagStr}\n`;
                            }
                        }
                    } else {
                        // ÂØπË±°Á±ªÂûã
                        const nestedStructName = formatName(key, true);

                        if (Object.keys(value).length === 0) {
                            code += `  ${fieldName} map[string]interface{}${tagStr}\n`;
                        } else if (inlineStruct) {
                            code += `  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                        } else {
                            code += `  ${fieldName} ${nestedStructName}${tagStr}\n`;

                            if (!allStructs[nestedStructName]) {
                                allStructs[nestedStructName] = genGoStruct(value, nestedStructName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                            }
                        }
                    }
                } else {
                    // Âü∫Êú¨Á±ªÂûã
                    code += `  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += "}";

            if (!allStructs[name]) {
                allStructs[name] = code;
            }

            return code;
        }

        function genGoInlineStruct(obj, name, tags, detectTime, depth, comments, formatName, path) {
            let indent = "  ".repeat(depth);
            let code = `${indent}struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    code += `${indent}  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                    const nestedStructName = formatName(key, true);
                    code += `${indent}  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object") {
                    const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);
                    code += `${indent}  ${fieldName} []${itemTypeName}${tagStr}\n`;
                } else {
                    code += `${indent}  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += `${indent}}`;
            return code;
        }

        function genTypeScript(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "typescript", inlineStruct, detectTime, comments, formatName);
        }

        function genJava(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "java", inlineStruct, detectTime, comments, formatName);
        }

        function genPython(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "python", inlineStruct, detectTime, comments, formatName);
        }

        function genKotlin(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "kotlin", inlineStruct, detectTime, comments, formatName);
        }

        function genRust(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "rust", inlineStruct, detectTime, comments, formatName);
        }

        function generateGenericCode(obj, name, lang, inlineStruct, detectTime, comments, formatName, depth = 0, path = '') {
            if (depth > 10) {
                return `// ÁªìÊûÑÂµåÂ•óËøáÊ∑±ÔºåÂª∫ËÆÆÁÆÄÂåñJSON\n// ${name} Á±ªÂûãÂÆö‰πâ`;
            }

            let code = '';

            switch(lang) {
                case 'typescript':
                    code = `interface ${name} {\n`;
                    break;
                case 'java':
                    code = `public class ${name} {\n`;
                    break;
                case 'python':
                    code = `class ${name}:\n`;
                    break;
                case 'kotlin':
                    code = `data class ${name}(\n`;
                    break;
                case 'rust':
                    code = `pub struct ${name} {\n`;
                    break;
            }

            const indent = lang === 'python' ? '    ' : '  ';

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                const fieldType = inferType(value, lang, key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    switch(lang) {
                        case 'typescript':
                        case 'java':
                        case 'kotlin':
                        case 'rust':
                            code += `${indent}// ${comment}\n`;
                            break;
                        case 'python':
                            code += `${indent}# ${comment}\n`;
                            break;
                    }
                }

                switch(lang) {
                    case 'typescript':
                        code += `${indent}${fieldName}: ${fieldType};\n`;
                        break;
                    case 'java':
                        code += `${indent}private ${fieldType} ${fieldName};\n`;
                        break;
                    case 'python':
                        code += `${indent}${fieldName}: ${fieldType}\n`;
                        break;
                    case 'kotlin':
                        code += `${indent}val ${fieldName}: ${fieldType},\n`;
                        break;
                    case 'rust':
                        code += `${indent}pub ${fieldName}: ${fieldType},\n`;
                        break;
                }
            }

            switch(lang) {
                case 'typescript':
                    code += '}';
                    break;
                case 'java':
                    code += '}';
                    break;
                case 'python':
                    break;
                case 'kotlin':
                    code = code.slice(0, -2) + '\n)';
                    break;
                case 'rust':
                    code = code.slice(0, -2) + '\n}';
                    break;
            }

            return code;
        }

        // Ê∏≤ÊüìÂ∫îÁî®
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    });
</script>
</body>
</html>