<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <title> JSON 工具</title>

    <!-- 添加网站图标 -->
    <!--    <link rel="icon" href="./libs/icon/o-json.png" type="image/x-icon">-->
    <link rel="icon" href="./libs/icon/json.png" type="image/x-icon">
    <link rel="stylesheet" href="./libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* CSS样式（包含修复） */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            color: #e5e7eb;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 12px;
            gap: 12px;
        }

        .header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 4px;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .header .subtitle {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 2px;
        }

        .config-panel {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 10px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .config-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-row {
            display: flex;
            gap: 16px;
            align-items: flex-start;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .code-gen-config {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .config-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 100px;
        }

        .compact-group {
            margin-bottom: 0;
        }

        .compact-group label {
            font-size: 11px;
            margin-bottom: 2px;
        }

        .language-select {
            position: relative;
        }

        .language-select select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 8px 12px;
            padding-right: 32px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            min-width: 120px;
            cursor: pointer;
            transition: all 0.2s;
            appearance: none;
        }

        .compact-select {
            padding: 6px 10px;
            min-width: 100px;
            font-size: 12px;
        }

        .language-select select:hover {
            border-color: #60a5fa;
            background: #1e293b;
        }

        .language-select select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .language-select::after {
            content: "▼";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #94a3b8;
            font-size: 10px;
            pointer-events: none;
        }

        .checkbox-options {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .compact-options {
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .compact-item {
            gap: 4px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 12px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-item label {
            font-size: 11px;
            min-width: 32px;
        }

        .go-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-width: 300px;
        }

        .compact-tags {
            gap: 6px;
            max-width: 280px;
        }

        .tag-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .compact-tag {
            gap: 3px;
        }

        .tag-checkbox input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .compact-tag input[type="checkbox"] {
            width: 14px;
            height: 14px;
        }

        .tag-checkbox input[type="checkbox"]:checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
        }

        .tag-checkbox input[type="checkbox"]:checked::after {
            content: "✓";
            position: absolute;
            color: white;
            font-size: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .tag-checkbox label {
            font-size: 11px;
            color: #cbd5e1;
            cursor: pointer;
            user-select: none;
        }

        .compact-tag label {
            font-size: 10px;
            padding: 1px 3px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 0;
        }

        .compact-actions {
            gap: 6px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }

        /* 内联开关样式 */
        .mode-switch-inline {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-right: 10px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-switch-inline .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 18px;
            margin: 0;
        }

        .mode-switch-inline .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .mode-switch-inline .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 18px;
        }

        .mode-switch-inline .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .mode-switch-inline input:checked + .slider {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
        }

        .mode-switch-inline input:checked + .slider:before {
            transform: translateX(18px);
        }

        .mode-switch-inline .switch-label {
            font-size: 12px;
            color: #cbd5e1;
            user-select: none;
            white-space: nowrap;
        }

        .btn {
            padding: 8px 14px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 90px;
            justify-content: center;
        }

        .btn-compact {
            padding: 6px 10px;
            font-size: 12px;
            min-width: 80px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(90deg, #2563eb, #4f46e5);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e5e7eb;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .editor-panels {
            display: flex;
            flex: 1;
            gap: 12px;
            min-height: 0;
            /* height: calc(100vh - 240px); 移除固定计算，使用 flex 自适应 */
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            height: 100%;
            transition: all 0.3s ease;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            min-height: 40px;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .panel-title i {
            color: #60a5fa;
            font-size: 14px;
        }

        .panel-stats {
            font-size: 11px;
            color: #94a3b8;
        }

        .panel-content {
            flex: 1;
            position: relative;
            min-height: 300px;
            overflow: hidden;
        }

        .panel-tabs {
            display: flex;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            padding: 4px 8px;
        }

        .panel-tab {
            padding: 6px 12px;
            font-size: 12px;
            color: #94a3b8;
            background: none;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .panel-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #f1f5f9;
        }

        .panel-tab.active {
            background: linear-gradient(90deg, #3b82f6, #6366f1);
            color: white;
        }

        .panel-tab + .panel-tab {
            margin-left: 4px;
        }

        .json-panel {
            flex: 1;
        }

        .code-panel {
            flex: 1;
            opacity: 1;
            transform: translateX(0);
        }

        /* 修复：使用CSS类控制隐藏 */
        .code-panel.hidden {
            display: none !important;
            flex: 0;
            width: 0;
            min-width: 0;
        }

        .json-panel.full-width {
            flex: 1;
            width: 100%;
        }

        .json-panel.partial-width {
            flex: 1;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 14px;
            background: rgba(30, 41, 59, 0.9);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 12px;
            color: #94a3b8;
            min-height: 36px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .language-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }

        .info-icon {
            color: #60a5fa;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            .config-row {
                gap: 12px;
            }

            .compact-group {
                min-width: 100px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 8px;
                gap: 8px;
            }

            .header h1 {
                font-size: 18px;
            }

            .editor-panels {
                flex-direction: column;
                height: auto;
            }

            .panel {
                min-height: 300px;
            }

            .config-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }

            .mode-switch-inline {
                order: -1;
                width: 100%;
                justify-content: center;
                margin-right: 0;
                margin-bottom: 8px;
            }

            .compact-actions {
                justify-content: center;
            }

            .compact-group {
                width: 100%;
            }

            .compact-input {
                width: 100%;
            }

            .compact-select {
                width: 100%;
            }

            .compact-actions {
                flex-wrap: wrap;
                justify-content: center;
            }

            .btn-compact {
                flex: 1;
                min-width: 60px;
                padding: 5px 8px;
                font-size: 11px;
            }

            .code-gen-config {
                padding-top: 8px;
                margin-top: 8px;
            }
        }

        .error-message {
            color: #f87171;
            font-size: 12px;
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .time-type-hint {
            font-size: 10px;
            color: #86efac;
            margin-top: 2px;
            display: inline-block;
        }

        /* JSON工具按钮组 */
        .json-tools {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        /* Header栏内容布局 */
        .panel-header-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        /* Header栏格式转换工具 */
        .header-conversion-tools {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 6px;
            padding: 4px 8px;
        }

        .header-conversion-tools .format-select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 3px 6px;
            height: 24px;
        }

        /* 修复 Windows 下拉选项显示问题 */
        .header-conversion-tools .format-select option {
            background: #1e293b;
            color: #f1f5f9;
        }

        .header-conversion-tools .btn-sm {
            padding: 3px 6px;
            height: 24px;
            min-width: 24px;
        }

        .format-select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .format-select:hover {
            border-color: #60a5fa;
        }

        .format-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .case-format-select {
            min-width: 100px;
        }

        /* 注释样式 */
        .comment-indicator {
            position: absolute;
            right: 8px;
            top: 8px;
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 10;
        }

        .generation-info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
        }

        .generation-info-compact {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 6px;
        }

        .generation-info-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .generation-info-stat {
            font-size: 11px;
        }

        .generation-info-stat .label {
            color: #94a3b8;
        }

        .generation-info-stat .value {
            color: #60a5fa;
            font-weight: 500;
            margin-left: 2px;
        }

        .generation-info-stat .value.warning {
            color: #fbbf24;
        }

        .warning-message {
            background: rgba(245, 158, 11, 0.1);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #fbbf24;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* 输入框样式 */
        .compact-input {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 6px 8px;
            border-radius: 5px;
            font-size: 12px;
            width: 100px;
            outline: none;
            transition: all 0.2s;
        }

        .compact-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* 折叠区域样式 */
        .fold-widget {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* 确保编辑器有足够高度 */
        .monaco-editor {
            height: 100% !important;
        }

        /* 新增：错误行标记 */
        .error-line {
            background-color: rgba(248, 113, 113, 0.2) !important;
        }

        .error-gutter {
            background-color: rgba(248, 113, 113, 0.4) !important;
            color: #f87171 !important;
        }

        /* 新增：中文转码相关样式 */
        .unicode-preview {
            font-size: 10px;
            color: #86efac;
            margin-top: 2px;
            font-family: monospace;
        }

        /* 格式化错误提示 */
        .format-error-details {
            background: rgba(248, 113, 113, 0.1);
            border: 1px solid rgba(248, 113, 113, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #f87171;
        }

        .format-error-line {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 2px 0;
            border-bottom: 1px solid rgba(248, 113, 113, 0.1);
        }

        .format-error-line:last-child {
            border-bottom: none;
        }

        /* 新增：对比模式样式 */
        .diff-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .diff-editor-container {
            flex: 1;
            display: flex;
            gap: 12px;
        }

        /* 需求2：对比模式布局容器 */
        .diff-layout {
            display: flex;
            height: 100%;
            align-items: stretch;
            width: 100%;
            overflow: hidden;
        }

        .diff-side {
            flex: 1; /* 默认flex，会被style覆盖 */
            display: flex;
            flex-direction: column;
            border: 1px solid #334155;
            border-radius: 6px;
            overflow: hidden;
            background: #1e293b;
            height: 100%;
            min-width: 0; /* 防止内容撑开 */
        }

        /* 需求2：终端样式差异信息框 */
        .diff-info-panel {
            background: #000000;
            border: 1px solid #334155;
            border-radius: 6px;
            /* 移除margin防止溢出 */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }

        .terminal-header {
            background: #1e293b;
            padding: 6px 10px;
            border-bottom: 1px solid #334155;
            font-size: 12px;
            color: #94a3b8;
            display: flex;
            align-items: center;
        }

        .terminal-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .terminal-content {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            color: #e2e8f0;
            font-size: 13px;
        }

        .diff-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
            height: 40px;
        }

        .diff-title {
            font-size: 13px;
            font-weight: 500;
            color: #f1f5f9;
        }

        .diff-content {
            flex: 1;
            position: relative;
            min-height: 300px;
        }

        /* 格式选择器样式 */
        .format-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .format-selector label {
            font-size: 11px;
            color: #94a3b8;
        }

        .format-selector select {
            background: #1e293b;
            color: #f1f5f9;
            border: 1px solid #475569;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        /* 差异高亮样式 */
        .diff-added {
            background-color: rgba(34, 197, 94, 0.2) !important;
        }

        .diff-removed {
            background-color: rgba(239, 68, 68, 0.2) !important;
        }

        .diff-modified {
            background-color: rgba(251, 191, 36, 0.2) !important;
        }

        .diff-result {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 8px;
            margin-top: 8px;
            font-size: 12px;
            color: #60a5fa;
        }

        .diff-stat {
            display: flex;
            gap: 16px;
        }

        .diff-stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .diff-stat-added {
            color: #22c55e;
        }

        .diff-stat-removed {
            color: #ef4444;
        }

        .diff-stat-modified {
            color: #fbbf24;
        }

        /* 底部备案信息样式 */
        .footer {
            text-align: center;
            padding: 8px 0;
            font-size: 11px;
            color: #64748b;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(15, 23, 42, 0.6);
        }

        .footer a {
            color: #64748b;
            text-decoration: none;
            transition: color 0.2s;
        }

        .footer a:hover {
            color: #94a3b8;
        }
    </style>
</head>
<body>

<div id="root"></div>

<!-- React & ReactDOM -->
<script src="./libs/react/react.development.js"></script>
<script src="./libs/react-dom/react-dom.development.js"></script>

<!-- Monaco Editor -->
<script src="./libs/monaco-editor/min/vs/loader.js"></script>

<script>
    // 配置Monaco Editor路径
    require.config({
        paths: {
            vs: "./libs/monaco-editor/min/vs"
        }
    });

    // 等待Monaco加载完成后执行
    require(["vs/editor/editor.main"], function () {
        const { useState, useEffect, useRef, useCallback } = React;

        // 语言配置 (使用 FontAwesome 图标以确保跨平台兼容性)
        const LANGUAGE_CONFIG = {
            go: {
                name: "Golang",
                icon: "fab fa-golang",
                fileExt: "go",
                monacoLang: "go"
            },
            java: {
                name: "Java",
                icon: "fab fa-java",
                fileExt: "java",
                monacoLang: "java"
            },
            typescript: {
                name: "TypeScript",
                icon: "fab fa-js-square",
                fileExt: "ts",
                monacoLang: "typescript"
            },
            python: {
                name: "Python",
                icon: "fab fa-python",
                fileExt: "py",
                monacoLang: "python"
            },
            kotlin: {
                name: "Kotlin",
                icon: "fas fa-code",
                fileExt: "kt",
                monacoLang: "kotlin"
            },
            rust: {
                name: "Rust",
                icon: "fab fa-rust",
                fileExt: "rs",
                monacoLang: "rust"
            }
        };

        // 时间格式正则表达式
        const TIME_PATTERNS = [
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:?\d{2})?$/,
            /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/,
            /^\d{4}-\d{2}-\d{2}$/,
            /^\d{13}$/,
            /^\d{10}$/,
            /(time|date|timestamp|created|updated|start|end|at)$/i
        ];

        // 默认JSON（包含注释和URL测试）
        const DEFAULT_JSON = `{
  // 用户ID
  "user_id": 12345,
  // 用户名
  "username": "john_doe",
  // 邮箱地址
  "email": "john@example.com",
  // 年龄
  "age": 30,
  // 是否激活
  "is_active": true,
  // 创建时间
  "created_at": "2023-10-01T12:00:00Z",
  // 更新时间
  "updated_at": "2023-12-15T08:30:00Z",
  // 出生日期
  "birth_date": "1993-05-15",
  // 最后登录时间
  "last_login": "2023-12-15T08:30:00.123Z",
  // 元数据
  "metadata": {
    // 时间戳
    "timestamp": 1702643400000,
    // 过期时间
    "expires_at": "2024-12-31 23:59:59"
  },
  // 用户偏好设置
  "preferences": {
    "theme": "dark",
    "language": "en"
  },
  // 项目列表
  "projects": [
    {
      "id": 1,
      "name": "API Gateway",
      "start_date": "2023-01-01",
      "end_date": "2023-12-31"
    }
  ]
}`;

        // 测试JSON：多维数组下嵌套不同结构体的合并逻辑
        const COMPLEX_JSON = `{
  "地址": "",
  "doc_url": "http://localhost",
  "docUrl": "http://localhost",
  "int1": 1,
  "int2": 3000000000,
  "float": 1.15,
  "a": [
    [
      {
        "a1": {
          "a2": [
            {"a3": "123"},
            {"b3": ""}
          ]
        }
      },
      {
        "a1": {
          "a2": [
            {"a3": 123},
            {"c3": ""}
          ],
          "b2": ""
        },
        "b1": {
          "b2": ""
        }
      }
    ]
  ]
}`;

        const DATA_FORMATS = {
            json: { name: 'JSON', icon: 'fas fa-code', monacoLang: 'json' },
            xml: { name: 'XML', icon: 'fas fa-file-code', monacoLang: 'xml' },
            yaml: { name: 'YAML', icon: 'fas fa-file-invoice', monacoLang: 'yaml' },
            toml: { name: 'TOML', icon: 'fas fa-cog', monacoLang: 'ini' },
            ini: { name: 'INI', icon: 'fas fa-sliders-h', monacoLang: 'ini' },
            text: { name: 'Text', icon: 'fas fa-font', monacoLang: 'plaintext' }
        };

        // 常见缩略词列表 (Go Lint标准 + 常见Web缩略词)
        const COMMON_INITIALISMS = new Set([
            "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP",
            "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA",
            "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID",
            "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS"
        ]);

        // 命名格式配置
        const CASE_FORMATS = {
            pascal: {
                name: "大驼峰 (PascalCase)",
                fn: (str) => str.split(/[_\s-]+/).map(word => {
                    const upper = word.toUpperCase();
                    if (COMMON_INITIALISMS.has(upper)) return upper;
                    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                }).join('')
            },
            camel: {
                name: "小驼峰 (camelCase)",
                fn: (str) => {
                    const words = str.split(/[_\s-]+/);
                    return words.map((word, index) => {
                        const upper = word.toUpperCase();
                        if (index === 0) {
                            // 首单词始终小写
                            return word.toLowerCase();
                        }
                        // 后续单词，如果是缩略词则全大写 (如 UserID, ParseXML)
                        if (COMMON_INITIALISMS.has(upper)) return upper;
                        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
                    }).join('');
                }
            },
            snake: {
                name: "下划线 (snake_case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_/, '').replace(/-/g, '_')
            },
            kebab: {
                name: "连字符 (kebab-case)",
                fn: (str) => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`).replace(/^-/, '').replace(/_/g, '-')
            }
        };

        function App() {
            // 新增：当前数据格式状态
            const [dataFormat, setDataFormat] = useState("json");
            // 新增：对比模式状态
            const [isDiffMode, setIsDiffMode] = useState(false);
            const [diffText, setDiffText] = useState("");
            // 新增：左右两侧独立格式选择
            const [leftFormat, setLeftFormat] = useState("json");
            const [rightFormat, setRightFormat] = useState("json");
            // 新增：对比结果
            const [diffAnalysis, setDiffAnalysis] = useState(null);
            // 新增：对比视图模式 ('split' | 'git')
            const [diffViewMode, setDiffViewMode] = useState("split");

            const diffEditorRef = useRef(null);
            const diffEditorInstance = useRef(null);
            // 修复 Hook 报错：新增左侧编辑器 Ref
            const diffLeftEditorRef = useRef(null);
            // 新增：Git Diff 编辑器 Ref
            const gitDiffContainerRef = useRef(null);
            const gitDiffEditorInstance = useRef(null);

            // 新增：文件上传引用
            const fileInputRef = useRef(null);
            // 新增：当前上传目标 ('main' | 'diff')
            const uploadTargetRef = useRef('main');

            const [lang, setLang] = useState("go");
            const [goTags, setGoTags] = useState({
                json: true,
                mapstructure: false,
                gorm: false,
                yaml: false,
                xml: false,
                validate: false,
                omitempty: true
            });

            const [structName, setStructName] = useState("Response");
            const [inlineStruct, setInlineStruct] = useState(false); // 默认改为拆分模式，便于查看
            const [detectTime, setDetectTime] = useState(true);
            const [includeComments, setIncludeComments] = useState(true);
            const [mergeArrayFields, setMergeArrayFields] = useState(true); // 默认开启合并
            const [caseFormat, setCaseFormat] = useState("pascal");
            const [isCodeGenMode, setIsCodeGenMode] = useState(false); // 需求1：默认关闭代码生成模式
            const [jsonText, setJsonText] = useState(DEFAULT_JSON);
            const [generatedCode, setGeneratedCode] = useState("");
            const [error, setError] = useState("");
            const [isGenerating, setIsGenerating] = useState(false);
            const [jsonStats, setJsonStats] = useState({ lines: 0, chars: 0, commentLines: 0, errorLines: 0 });
            const [codeStats, setCodeStats] = useState({ lines: 0, chars: 0 });
            const [timeFieldsDetected, setTimeFieldsDetected] = useState(0);
            const [generationInfo, setGenerationInfo] = useState(null);
            const [formatErrors, setFormatErrors] = useState([]); // 新增：格式化错误信息

            const jsonEditorRef = useRef(null);
            const jsonEditorInstance = useRef(null);
            const codeEditorRef = useRef(null);
            const codeEditorInstance = useRef(null);

            // 改进的数组合并工具函数：生成包含所有字段并集的超级对象，并置于数组首位
            const mergeArrayItems = useCallback((array) => {
                if (!array || !Array.isArray(array) || array.length === 0) return array;

                // 深度合并两个对象
                const deepMerge = (target, source) => {
                    if (!source || typeof source !== 'object') return target;
                    if (!target || typeof target !== 'object') return source;

                    // 如果是数组，不进行元素合并，而是保留结构（因为我们只关心结构定义）
                    // 这里的关键是：如果 target 是空数组，source 有内容，取 source
                    if (Array.isArray(source)) {
                        if (!Array.isArray(target) || target.length === 0) return source;

                        // 递归处理数组内部元素的合并
                        // 假设数组内存储的是同构对象
                        if (source.length > 0 && typeof source[0] === 'object') {
                            const mergedChild = mergeArrayItems([...target, ...source]);
                            return mergedChild; // 返回合并后的新数组
                        }
                        return target;
                    }

                    const output = { ...target };
                    Object.keys(source).forEach(key => {
                        if (source[key] && typeof source[key] === 'object') {
                            if (!(key in target)) {
                                Object.assign(output, { [key]: source[key] });
                            } else {
                                output[key] = deepMerge(target[key], source[key]);
                            }
                        } else {
                            if (!(key in target)) {
                                Object.assign(output, { [key]: source[key] });
                            }
                            // 如果 target 已有该 key，且 source[key] 是 null/undefined，保留 target
                            // 如果 target[key] 是 null/undefined，且 source[key] 有值，更新
                            else if ((output[key] === null || output[key] === undefined || output[key] === "") &&
                                     (source[key] !== null && source[key] !== undefined && source[key] !== "")) {
                                output[key] = source[key];
                            }
                        }
                    });
                    return output;
                };

                const firstItem = array[0];

                // 1. 处理对象数组：计算所有对象的并集
                if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {
                    let superObject = {};

                    // 遍历所有元素，合并出一个超级对象
                    for (const item of array) {
                        if (item && typeof item === 'object' && !Array.isArray(item)) {
                             superObject = deepMerge(superObject, item);
                        }
                    }

                    // 递归处理超级对象中的子数组/子对象
                    const processSuperObject = (obj) => {
                        const result = { ...obj };
                        for (const [key, value] of Object.entries(result)) {
                            if (Array.isArray(value)) {
                                result[key] = mergeArrayItems(value);
                            } else if (value && typeof value === 'object') {
                                result[key] = processSuperObject(value);
                            }
                        }
                        return result;
                    };

                    const finalSuperObject = processSuperObject(superObject);

                    // 关键步骤：返回一个新的数组，只包含这个超级对象
                    // 这样代码生成器取 array[0] 时，就能得到完整的结构定义
                    return [finalSuperObject];
                }

                // 2. 处理多维数组
                if (Array.isArray(firstItem)) {
                    // 对于 [[...], [...]]，我们需要合并内部的子数组结构
                    // 将所有子数组展平合并，然后再递归调用
                    const flattened = array.flat();
                    return [mergeArrayItems(flattened)];
                }

                return array;
            }, []);

            // 处理对象函数
            const processObject = useCallback((data) => {
                if (!mergeArrayFields) return data;

                // 深拷贝一份数据，避免修改原数据
                const clonedData = JSON.parse(JSON.stringify(data));

                const process = (item) => {
                    if (Array.isArray(item)) {
                        // 如果是数组，调用合并逻辑，返回包含超级对象的单元素数组
                        return mergeArrayItems(item);
                    } else if (item && typeof item === 'object') {
                        const result = {};
                        Object.entries(item).forEach(([key, value]) => {
                            // 递归处理对象的每个字段
                            if (Array.isArray(value)) {
                                result[key] = process(value);
                            } else if (value && typeof value === 'object') {
                                result[key] = process(value);
                            } else {
                                result[key] = value;
                            }
                        });
                        return result;
                    }
                    return item;
                };

                return process(clonedData);
            }, [mergeArrayFields, mergeArrayItems]);
            // 初始化编辑器
            useEffect(() => {
                // 如果在非对比模式下，且编辑器容器存在，但实例不存在，则创建
                if (!isDiffMode && !jsonEditorInstance.current && jsonEditorRef.current) {
                    jsonEditorInstance.current = monaco.editor.create(jsonEditorRef.current, {
                        value: jsonText || DEFAULT_JSON,
                        language: "json",
                        theme: "vs-dark",
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        foldingImportsByDefault: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on",
                        glyphMargin: true,
                        lineDecorationsWidth: 20,
                        renderLineHighlight: "all",
                        formatOnPaste: true,
                        formatOnType: true,
                        wordWrap: "off",
                        renderWhitespace: "selection",
                        quickSuggestions: true,
                        suggestOnTriggerCharacters: true,
                        acceptSuggestionOnEnter: "on",
                        tabCompletion: "on",
                        wordBasedSuggestions: true
                    });

                    // 监听内容变化
                    jsonEditorInstance.current.onDidChangeModelContent(() => {
                        const value = jsonEditorInstance.current.getValue();
                        setJsonText(value);

                        const lines = value.split('\n').length;
                        const chars = value.length;
                        const commentLines = (value.match(/\/\/.*$/g) || []).length;
                        setJsonStats(prev => ({ ...prev, lines, chars, commentLines }));
                    });
                }

                // 修复：始终初始化代码编辑器，不依赖 isCodeGenMode
                if (!codeEditorInstance.current && codeEditorRef.current) {
                    codeEditorInstance.current = monaco.editor.create(codeEditorRef.current, {
                        value: "// 请打开代码生成开关并点击\"生成代码\"按钮",
                        language: "go",
                        theme: "vs-dark",
                        readOnly: false,
                        automaticLayout: true,
                        folding: true,
                        foldingStrategy: "indentation",
                        foldingHighlight: true,
                        showFoldingControls: "always",
                        minimap: { enabled: true },
                        scrollBeyondLastLine: false,
                        fontSize: 13,
                        lineNumbers: "on"
                    });
                }

                return () => {
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }
                };
            }, [isDiffMode]); // 依赖 isDiffMode，在切换模式时重新评估

            // 更新代码编辑器语言
            useEffect(() => {
                if (codeEditorInstance.current) {
                    const model = codeEditorInstance.current.getModel();
                    if (model) {
                        monaco.editor.setModelLanguage(model, LANGUAGE_CONFIG[lang].monacoLang);
                    }
                }
            }, [lang]);

            // 改进的JSON注释解析函数
            const parseJsonWithComments = useCallback((jsonString) => {
                try {
                    const removeComments = (str) => {
                        const lines = str.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const withoutComments = removeComments(jsonString);
                    const parsed = JSON.parse(withoutComments);

                    const comments = { fieldComments: {} };
                    const lines = jsonString.split('\n');
                    let currentField = '';

                    lines.forEach((line) => {
                        let inString = false;
                        let escaped = false;
                        let commentStart = -1;

                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            const nextChar = i + 1 < line.length ? line[i + 1] : '';

                            if (!escaped && char === '\\') {
                                escaped = true;
                            } else if (!escaped && char === '"') {
                                inString = !inString;
                            } else if (!inString && char === '/' && nextChar === '/') {
                                commentStart = i;
                                break;
                            } else {
                                escaped = false;
                            }
                        }

                        if (commentStart !== -1) {
                            const comment = line.substring(commentStart + 2).trim();
                            if (currentField && comment) {
                                comments.fieldComments[currentField] = comment;
                            }

                            const beforeComment = line.substring(0, commentStart);
                            const fieldMatch = beforeComment.match(/"([^"]+)":\s*$/);
                            if (fieldMatch) {
                                currentField = fieldMatch[1];
                            }
                        }

                        const fieldMatch = line.match(/"([^"]+)":/);
                        if (fieldMatch) {
                            currentField = fieldMatch[1];
                        }
                    });

                    return { parsed, comments };
                } catch (err) {
                    try {
                        const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                        const parsed = JSON.parse(withoutComments);
                        return { parsed, comments: { fieldComments: {} } };
                    } catch (err2) {
                        throw new Error(`JSON解析失败: ${err2.message}`);
                    }
                }
            }, []);

            // 中文转Unicode函数
            const chineseToUnicode = useCallback((str) => {
                let result = '';
                for (let i = 0; i < str.length; i++) {
                    const charCode = str.charCodeAt(i);
                    if (charCode > 127) {
                        result += '\\u' + charCode.toString(16).padStart(4, '0');
                    } else {
                        result += str.charAt(i);
                    }
                }
                return result;
            }, []);

            // Unicode转中文函数
            const unicodeToChinese = useCallback((str) => {
                return str.replace(/\\u[\dA-F]{4}/gi, (match) => {
                    return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
                });
            }, []);

            // ========== 需求1: 多格式转换函数 ==========
            // JSON转XML - 修复数组处理和无限叠加root问题
            const jsonToXml = useCallback((obj, rootName = 'root', indent = '') => {
                const processValue = (key, value, currentIndent, fromArray = false) => {
                    if (value === null || value === undefined) {
                        return `${currentIndent}<${key}/>\n`;
                    }
                    if (Array.isArray(value)) {
                        // 修复：数组应该用复数形式包裹，内部元素用单数形式
                        const singleKey = key.endsWith('s') ? key.slice(0, -1) : key + 'Item';
                        let arrayContent = `${currentIndent}<${key}>\n`;
                        arrayContent += value.map(item => processValue(singleKey, item, currentIndent + '  ', true)).join('');
                        arrayContent += `${currentIndent}</${key}>\n`;
                        return arrayContent;
                    }
                    if (typeof value === 'object') {
                        let content = '';
                        content += `${currentIndent}<${key}>\n`;
                        for (const [k, v] of Object.entries(value)) {
                            content += processValue(k, v, currentIndent + '  ');
                        }
                        content += `${currentIndent}</${key}>\n`;
                        return content;
                    }
                    return `${currentIndent}<${key}>${String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</${key}>\n`;
                };

                let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
                // 只在顶层添加root标签，避免多次转换时叠加
                xml += `<${rootName}>\n`;
                for (const [key, value] of Object.entries(obj)) {
                    xml += processValue(key, value, '  ');
                }
                xml += `</${rootName}>`;
                return xml;
            }, []);

            // JSON转YAML - 修复数组处理和时间字符串问题
            const jsonToYaml = useCallback((obj, indent = 0) => {
                const spaces = '  '.repeat(indent);
                let yaml = '';
                const processValue = (value, currentIndent) => {
                    if (value === null) return 'null';
                    if (value === undefined) return '';
                    if (typeof value === 'boolean') return value ? 'true' : 'false';
                    if (typeof value === 'number') return String(value);
                    if (typeof value === 'string') {
                        // 检测时间字符串，确保完整保留
                        const isTimeString = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value);
                        if (isTimeString || value.includes('\n') || value.includes(':') || value.includes('#')) {
                            return `"${value.replace(/"/g, '\\"')}"`;
                        }
                        return value;
                    }
                    return String(value);
                };

                for (const [key, value] of Object.entries(obj)) {
                    if (Array.isArray(value)) {
                        yaml += `${spaces}${key}:\n`;
                        value.forEach(item => {
                            if (typeof item === 'object' && item !== null) {
                                const itemYaml = jsonToYaml(item, indent + 1).trim();
                                if (itemYaml) {
                                    yaml += `${spaces}- ${itemYaml}\n`;
                                }
                            } else {
                                yaml += `${spaces}- ${processValue(item, indent + 1)}\n`;
                            }
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        yaml += `${spaces}${key}:\n`;
                        yaml += jsonToYaml(value, indent + 1);
                    } else {
                        const processedValue = processValue(value, indent);
                        yaml += `${spaces}${key}: ${processedValue}\n`;
                    }
                }
                return yaml;
            }, []);

            // JSON转TOML
            const jsonToToml = useCallback((obj, section = '') => {
                let toml = '';
                const simpleValues = {};
                const complexValues = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        complexValues[key] = value;
                    } else {
                        simpleValues[key] = value;
                    }
                }
                for (const [key, value] of Object.entries(simpleValues)) {
                    if (Array.isArray(value)) {
                        const items = value.map(item => {
                            if (typeof item === 'string') return `"${item}"`;
                            return String(item);
                        }).join(', ');
                        toml += `${key} = [${items}]\n`;
                    } else if (typeof value === 'string') {
                        toml += `${key} = "${value}"\n`;
                    } else if (typeof value === 'boolean') {
                        toml += `${key} = ${value}\n`;
                    } else {
                        toml += `${key} = ${value}\n`;
                    }
                }
                for (const [key, value] of Object.entries(complexValues)) {
                    const sectionName = section ? `${section}.${key}` : key;
                    toml += `\n[${sectionName}]\n`;
                    toml += jsonToToml(value, sectionName);
                }
                return toml;
            }, []);

            // JSON转INI
            const jsonToIni = useCallback((obj) => {
                let ini = '';
                const globalValues = {};
                const sections = {};
                for (const [key, value] of Object.entries(obj)) {
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        sections[key] = value;
                    } else {
                        globalValues[key] = value;
                    }
                }
                for (const [key, value] of Object.entries(globalValues)) {
                    ini += `${key}=${value}\n`;
                }
                for (const [section, values] of Object.entries(sections)) {
                    ini += `\n[${section}]\n`;
                    for (const [key, value] of Object.entries(values)) {
                        if (typeof value !== 'object') {
                            ini += `${key}=${value}\n`;
                        }
                    }
                }
                return ini;
            }, []);

            // XML转JSON (改进实现，避免无限叠加root)
            const xmlToJson = useCallback((xmlStr) => {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlStr, "text/xml");

                const parseNode = (node) => {
                    const obj = {};

                    // 处理属性
                    if (node.attributes && node.attributes.length > 0) {
                        for (let j = 0; j < node.attributes.length; j++) {
                            const attribute = node.attributes.item(j);
                            obj[`@${attribute.nodeName}`] = attribute.nodeValue;
                        }
                    }

                    // 处理子节点
                    if (node.hasChildNodes()) {
                        const childCounts = {};
                        const childValues = {};

                        for (let i = 0; i < node.childNodes.length; i++) {
                            const child = node.childNodes.item(i);

                            if (child.nodeType === 3) { // Text node
                                const text = child.nodeValue.trim();
                                if (text) {
                                    if (!obj['#text']) obj['#text'] = text;
                                    else if (Array.isArray(obj['#text'])) obj['#text'].push(text);
                                    else obj['#text'] = [obj['#text'], text];
                                }
                            } else if (child.nodeType === 1) { // Element node
                                const childName = child.nodeName;
                                const childValue = parseNode(child);

                                if (childCounts[childName]) {
                                    childCounts[childName]++;
                                    if (!Array.isArray(childValues[childName])) {
                                        childValues[childName] = [childValues[childName]];
                                    }
                                    childValues[childName].push(childValue);
                                } else {
                                    childCounts[childName] = 1;
                                    childValues[childName] = childValue;
                                }
                            }
                        }

                        // 合并处理后的子节点
                        Object.entries(childValues).forEach(([name, value]) => {
                            obj[name] = value;
                        });
                    }

                    // 如果只有文本内容，返回文本
                    if (Object.keys(obj).length === 1 && obj['#text']) {
                        return obj['#text'];
                    }
                    // 如果没有内容，返回空字符串
                    if (Object.keys(obj).length === 0) {
                        return "";
                    }

                    return obj;
                };

                const root = xmlDoc.documentElement;
                // 直接返回解析结果，避免额外包装
                return parseNode(root);
            }, []);

            // INI转JSON (修复需求3：去除字符串值的转义符号/引号)
            const iniToJson = useCallback((iniStr) => {
                const result = {};
                let currentSection = result;

                iniStr.split('\n').forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith(';') || line.startsWith('#')) return;

                    if (line.startsWith('[') && line.endsWith(']')) {
                        const sectionName = line.slice(1, -1);
                        result[sectionName] = {};
                        currentSection = result[sectionName];
                    } else if (line.includes('=')) {
                        const parts = line.split('=');
                        const key = parts[0].trim();
                        // 处理值包含 = 的情况
                        let val = parts.slice(1).join('=').trim();

                        // 去除首尾引号
                        if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                            val = val.slice(1, -1);
                        }

                        // 尝试转换布尔值和数字
                        if (val === 'true') val = true;
                        else if (val === 'false') val = false;
                        else if (!isNaN(val) && val !== '') val = Number(val);

                        currentSection[key] = val;
                    }
                });
                return result;
            }, []);

            // 改进的YAML解析器
            const yamlToJson = useCallback((yamlStr) => {
                const lines = yamlStr.split('\n');
                const root = {};
                // 使用双栈策略：一个维护上下文，一个维护数组引用
                const finalResult = {};
                const ptrs = [{ obj: finalResult, indent: -1 }];

                // 辅助：解析值
                const parseVal = (val) => {
                    if (!val) return null;
                    val = val.trim();
                    if (val === 'true') return true;
                    if (val === 'false') return false;
                    if (val === 'null') return null;
                    // 修复：不要轻易把看似数字的字符串转数字，除非完全匹配
                    if (!isNaN(val) && !val.includes(':') && !val.includes('-') && !val.includes('T')) return Number(val);
                    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
                        return val.slice(1, -1);
                    }
                    return val;
                };

                lines.forEach(line => {
                    const rawLine = line.replace(/\s+$/, '');
                    if (!rawLine || rawLine.trim().startsWith('#')) return;

                    const indent = rawLine.search(/\S/);
                    const trimmed = rawLine.trim();

                    // 回溯父级
                    while (ptrs.length > 1 && ptrs[ptrs.length - 1].indent >= indent) ptrs.pop();
                    const curr = ptrs[ptrs.length - 1];

                    // 处理数组项
                    if (trimmed.startsWith('- ')) {
                        // 发现数组项，如果当前对象是空对象（刚初始化），转换为数组
                        if (!Array.isArray(curr.obj) && Object.keys(curr.obj).length === 0) {
                            if (curr.parent && curr.key) {
                                curr.parent[curr.key] = [];
                                curr.obj = curr.parent[curr.key]; // 更新引用
                            }
                        }

                        if (Array.isArray(curr.obj)) {
                            const content = trimmed.substring(2).trim();
                            const colIdx = content.indexOf(':');

                            // 判断是否是对象项 (key: value)
                            if (colIdx > 0 && !content.startsWith('"') && !content.startsWith("'")) {
                                const k = content.substring(0, colIdx).trim();
                                const v = content.substring(colIdx + 1).trim();
                                const newItem = {};
                                newItem[k] = v ? parseVal(v) : {};
                                curr.obj.push(newItem);
                                if (!v) ptrs.push({ obj: newItem[k], indent, parent: newItem, key: k });
                            } else {
                                // 基本值
                                curr.obj.push(parseVal(content));
                            }
                        }
                        return;
                    }

                    // 处理对象键值对
                    const colIdx = trimmed.indexOf(':');
                    if (colIdx > 0) {
                        const k = trimmed.substring(0, colIdx).trim();
                        const v = trimmed.substring(colIdx + 1).trim();
                        if (!v) {
                            // 值为空，可能是嵌套对象或数组
                            // 先初始化为对象，如果后续遇到 - 会自动转为数组
                            if (Array.isArray(curr.obj)) {
                                const newObj = {};
                                newObj[k] = {};
                                curr.obj.push(newObj);
                                ptrs.push({ obj: newObj[k], indent, parent: newObj, key: k });
                            } else {
                                curr.obj[k] = {};
                                ptrs.push({ obj: curr.obj[k], indent, parent: curr.obj, key: k });
                            }
                        } else {
                            if (v === '[]') {
                                curr.obj[k] = [];
                            } else {
                                curr.obj[k] = parseVal(v);
                            }
                        }
                    }
                });

                return finalResult;
            }, []);

            // 简单的格式检测函数
            const detectContentFormat = useCallback((text) => {
                if (!text || typeof text !== 'string') return null;
                const trimmed = text.trim();
                if (trimmed.startsWith('{') || trimmed.startsWith('[')) return 'json';
                if (trimmed.startsWith('<') && trimmed.includes('>')) return 'xml';
                return null;
            }, []);

            // 统一的对象解析函数
            const parseCurrentContent = useCallback((content, format) => {
                try {
                    if (!content) return {};
                    if (format === 'text') return { text: content }; // 文本格式特殊处理

                    if (format === 'json') {
                        const { parsed } = parseJsonWithComments(content);
                        return parsed;
                    } else if (format === 'xml') {
                        return xmlToJson(content);
                    } else if (format === 'ini') {
                        return iniToJson(content);
                    } else if (format === 'yaml') {
                        return yamlToJson(content);
                    } else if (format === 'toml') {
                        return iniToJson(content); // 降级
                    }
                    return {};
                } catch (e) {
                    throw new Error(`解析 ${format} 失败: ${e.message}`);
                }
            }, [parseJsonWithComments, xmlToJson, iniToJson, yamlToJson]);

            // 智能格式切换函数 (统一处理主编辑器和Diff编辑器)
            const handleSmartFormatChange = useCallback((targetFormat, context = 'main') => {
                // context: 'main' | 'diff-left' | 'diff-right'
                let text, currentFormat, editor, setFormat, setText, handleError;

                if (context === 'main') {
                    text = jsonEditorInstance.current?.getValue() || jsonText;
                    currentFormat = dataFormat;
                    editor = jsonEditorInstance.current;
                    setFormat = setDataFormat;
                    setText = setJsonText;
                    handleError = setError;
                } else if (context === 'diff-left') {
                    text = jsonEditorInstance.current?.getValue() || jsonText;
                    currentFormat = leftFormat;
                    editor = jsonEditorInstance.current;
                    setFormat = setLeftFormat;
                    setText = setJsonText;
                    handleError = (msg) => console.log("Left Diff Error:", msg);
                } else if (context === 'diff-right') {
                    text = diffEditorInstance.current?.getValue() || diffText;
                    currentFormat = rightFormat;
                    editor = diffEditorInstance.current;
                    setFormat = setRightFormat;
                    setText = setDiffText;
                    handleError = (msg) => console.log("Right Diff Error:", msg);
                }

                if (currentFormat === targetFormat) return;

                const detected = detectContentFormat(text);
                let shouldConvert = false;

                // 决策逻辑：
                // 1. 如果检测到的格式与目标格式一致 -> 认为是纠正标签 -> 仅切换，不转换
                if (detected === targetFormat) {
                    shouldConvert = false;
                } else {
                    // 2. 尝试解析当前内容
                    try {
                        parseCurrentContent(text, currentFormat);
                        // 3. 如果能成功解析，说明当前处于一致状态，用户意图是转换 -> 执行转换
                        shouldConvert = true;
                    } catch (e) {
                        // 4. 如果解析失败，说明当前状态不一致，用户意图是纠正 -> 仅切换
                        shouldConvert = false;
                    }
                }

                if (shouldConvert) {
                    try {
                        const obj = parseCurrentContent(text, currentFormat);
                        let result = '';
                        switch (targetFormat) {
                            case 'json': result = JSON.stringify(obj, null, 2); break;
                            case 'xml': result = jsonToXml(obj); break;
                            case 'yaml': result = jsonToYaml(obj); break;
                            case 'toml': result = jsonToToml(obj); break;
                            case 'ini': result = jsonToIni(obj); break;
                        }

                        if (editor) editor.setValue(result);
                        setText(result);
                        setFormat(targetFormat);
                        if (editor) {
                            const model = editor.getModel();
                            if (model) monaco.editor.setModelLanguage(model, DATA_FORMATS[targetFormat].monacoLang);
                        }
                        if (handleError) handleError("");
                    } catch (err) {
                        if (handleError) handleError(`转换失败: ${err.message}`);
                    }
                } else {
                    // 仅切换状态
                    setFormat(targetFormat);
                    if (editor) {
                        const model = editor.getModel();
                        if (model) monaco.editor.setModelLanguage(model, DATA_FORMATS[targetFormat].monacoLang);
                    }
                    if (handleError) handleError("");
                }
            }, [dataFormat, jsonText, leftFormat, rightFormat, diffText, detectContentFormat, parseCurrentContent, jsonToXml, jsonToYaml, jsonToToml, jsonToIni]);

            // 格式转换函数 (保留用于特定按钮调用，如果有的话，但主要逻辑已移至 handleSmartFormatChange)
            const convertFormat = useCallback((targetFormat) => {
                handleSmartFormatChange(targetFormat, 'main');
            }, [handleSmartFormatChange]);

            // ========== 需求3: JSON对比功能 ==========
            const [diffResult, setDiffResult] = useState(null);

            // 初始化对比编辑器
            useEffect(() => {
                if (isDiffMode) {
                    if (diffViewMode === 'split') {
                        // === 分栏模式初始化 ===
                        // 销毁 Git 编辑器（如果存在）
                        if (gitDiffEditorInstance.current) {
                            gitDiffEditorInstance.current.dispose();
                            gitDiffEditorInstance.current = null;
                        }

                        // 初始化左侧编辑器 (原始 JSON)
                        if (diffLeftEditorRef.current && !jsonEditorInstance.current) {
                             jsonEditorInstance.current = monaco.editor.create(diffLeftEditorRef.current, {
                                value: jsonText,
                                language: DATA_FORMATS[leftFormat].monacoLang, // 使用当前选择的格式
                                theme: "vs-dark",
                                automaticLayout: true,
                                minimap: { enabled: true },
                                scrollBeyondLastLine: false,
                                fontSize: 13,
                                lineNumbers: "on"
                            });
                            jsonEditorInstance.current.onDidChangeModelContent(() => {
                                const value = jsonEditorInstance.current.getValue();
                                setJsonText(value);
                            });
                        }

                        // 初始化右侧编辑器 (对比 JSON)
                        if (diffEditorRef.current && !diffEditorInstance.current) {
                            diffEditorInstance.current = monaco.editor.create(diffEditorRef.current, {
                                value: diffText || '',
                                language: DATA_FORMATS[rightFormat].monacoLang,
                                theme: "vs-dark",
                                automaticLayout: true,
                                minimap: { enabled: true },
                                scrollBeyondLastLine: false,
                                fontSize: 13,
                                lineNumbers: "on"
                            });
                            diffEditorInstance.current.onDidChangeModelContent(() => {
                                const value = diffEditorInstance.current.getValue();
                                setDiffText(value);
                            });
                        }
                    } else {
                        // === Git 模式初始化 ===
                        // 销毁分栏编辑器
                        if (jsonEditorInstance.current) {
                            jsonEditorInstance.current.dispose();
                            jsonEditorInstance.current = null;
                        }
                        if (diffEditorInstance.current) {
                            diffEditorInstance.current.dispose();
                            diffEditorInstance.current = null;
                        }

                        if (gitDiffContainerRef.current && !gitDiffEditorInstance.current) {
                            gitDiffEditorInstance.current = monaco.editor.createDiffEditor(gitDiffContainerRef.current, {
                                theme: "vs-dark",
                                automaticLayout: true,
                                originalEditable: true, // 允许编辑左侧
                                renderSideBySide: true, // 左右并排
                                ignoreTrimWhitespace: false
                            });

                            const originalModel = monaco.editor.createModel(jsonText, DATA_FORMATS[leftFormat].monacoLang);
                            const modifiedModel = monaco.editor.createModel(diffText, DATA_FORMATS[rightFormat].monacoLang);

                            gitDiffEditorInstance.current.setModel({
                                original: originalModel,
                                modified: modifiedModel
                            });

                            // 监听内容变化同步回 state
                            originalModel.onDidChangeContent(() => {
                                setJsonText(originalModel.getValue());
                            });
                            modifiedModel.onDidChangeContent(() => {
                                setDiffText(modifiedModel.getValue());
                            });
                        }
                    }
                }

                // 修复：添加清理函数，防止实例残留和双重绑定
                return () => {
                    // 清理 split 模式的实例
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (diffEditorInstance.current) {
                        diffEditorInstance.current.dispose();
                        diffEditorInstance.current = null;
                    }
                    // 清理 git 模式的实例
                    if (gitDiffEditorInstance.current) {
                        // 清理手动创建的 Model
                        const models = gitDiffEditorInstance.current.getModel();
                        if (models) {
                            if (models.original) models.original.dispose();
                            if (models.modified) models.modified.dispose();
                        }
                        gitDiffEditorInstance.current.dispose();
                        gitDiffEditorInstance.current = null;
                    }
                };
            }, [isDiffMode, diffViewMode]); // 依赖视图模式切换

            // 监听格式变化，更新 Git Diff 的语言
            useEffect(() => {
                if (isDiffMode && diffViewMode === 'git' && gitDiffEditorInstance.current) {
                    const { original, modified } = gitDiffEditorInstance.current.getModel();
                    if (original) monaco.editor.setModelLanguage(original, DATA_FORMATS[leftFormat].monacoLang);
                    if (modified) monaco.editor.setModelLanguage(modified, DATA_FORMATS[rightFormat].monacoLang);
                }
            }, [leftFormat, rightFormat, isDiffMode, diffViewMode]);

            // 构建 path 到行号的映射
            const buildPathLineMap = useCallback((text, format) => {
                const map = {};
                try {
                    let jsonText = text;
                    // 先解析再格式化，确保格式一致
                    const obj = parseCurrentContent(text, format);
                    jsonText = JSON.stringify(obj, null, 2);
                    const lines = jsonText.split('\n');

                    // 递归函数来构建映射
                    const traverse = (node, currentPath, startLine) => {
                        if (typeof node !== 'object' || node === null) return startLine;

                        let lastLine = startLine;
                        const keys = Array.isArray(node) ? node.map((_, i) => i) : Object.keys(node);

                        for (const key of keys) {
                            const newPath = currentPath ? `${currentPath}.${key}` : String(key);
                            const keyStr = Array.isArray(node) ? `[${key}]` : `"${key}"`;

                            // 在 lines 中搜索这个 key（从 lastLine 开始）
                            for (let i = lastLine; i < lines.length; i++) {
                                const line = lines[i];
                                const hasKey = Array.isArray(node)
                                    ? (line.trim().startsWith('{') || line.trim().startsWith('[') || /^[\s]*["\d\[\{]/.test(line))
                                    : line.includes(`"${key}"`);

                                if (hasKey || (Array.isArray(node) && i > lastLine)) {
                                    if (!Array.isArray(node) && line.includes(`"${key}"`)) {
                                        map[newPath] = i + 1;
                                        lastLine = i + 1;
                                        // 递归处理子节点
                                        if (typeof node[key] === 'object' && node[key] !== null) {
                                            lastLine = traverse(node[key], newPath, lastLine);
                                        }
                                        break;
                                    } else if (Array.isArray(node)) {
                                        // 数组元素
                                        map[newPath] = i + 1;
                                        lastLine = i + 1;
                                        if (typeof node[key] === 'object' && node[key] !== null) {
                                            lastLine = traverse(node[key], newPath, lastLine);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        return lastLine;
                    };

                    traverse(obj, '', 0);
                } catch (e) {
                    console.error('构建行号映射失败:', e);
                }
                return map;
            }, [parseCurrentContent]);

            // 深度对比两个对象
            const deepCompare = useCallback((obj1, obj2, path = '') => {
                const differences = [];
                const allKeys = new Set([...Object.keys(obj1 || {}), ...Object.keys(obj2 || {})]);
                for (const key of allKeys) {
                    const currentPath = path ? `${path}.${key}` : key;
                    const val1 = obj1?.[key];
                    const val2 = obj2?.[key];
                    if (!(key in (obj1 || {}))) {
                        differences.push({ type: 'added', path: currentPath, value: val2 });
                    } else if (!(key in (obj2 || {}))) {
                        differences.push({ type: 'removed', path: currentPath, value: val1 });
                    } else if (typeof val1 !== typeof val2) {
                        differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                    } else if (Array.isArray(val1) && Array.isArray(val2)) {
                        if (JSON.stringify(val1) !== JSON.stringify(val2)) {
                            differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                        }
                    } else if (typeof val1 === 'object' && val1 !== null) {
                        differences.push(...deepCompare(val1, val2, currentPath));
                    } else if (val1 !== val2) {
                        differences.push({ type: 'modified', path: currentPath, oldValue: val1, newValue: val2 });
                    }
                }
                return differences;
            }, []);

            // 执行对比 (需求2：语义对比)
            const performDiff = useCallback(() => {
                try {
                    const leftContent = jsonEditorInstance.current?.getValue() || jsonText;
                    const rightContent = diffEditorInstance.current?.getValue() || diffText;

                    // 分别解析为 JSON 对象
                    const leftObj = parseCurrentContent(leftContent, leftFormat);
                    const rightObj = parseCurrentContent(rightContent, rightFormat);

                    const differences = deepCompare(leftObj, rightObj);

                    // 构建行号映射
                    const leftLineMap = buildPathLineMap(leftContent, leftFormat);
                    const rightLineMap = buildPathLineMap(rightContent, rightFormat);

                    // 为差异添加行号信息
                    const differencesWithLines = differences.map(diff => ({
                        ...diff,
                        leftLine: leftLineMap[diff.path] || null,
                        rightLine: rightLineMap[diff.path] || null
                    }));

                    const stats = {
                        added: differencesWithLines.filter(d => d.type === 'added').length,
                        removed: differencesWithLines.filter(d => d.type === 'removed').length,
                        modified: differencesWithLines.filter(d => d.type === 'modified').length
                    };

                    setDiffAnalysis({
                        differences: differencesWithLines,
                        stats,
                        leftFormat,
                        rightFormat
                    });
                    setError("");
                } catch (err) {
                    setError(`对比错误: ${err.message}`);
                    setDiffAnalysis(null);
                }
            }, [jsonText, diffText, leftFormat, rightFormat, parseCurrentContent, deepCompare]);

            // 辅助：格式化特定编辑器的内容
            const formatEditorContent = useCallback((editorInstance, format, setTextFunc) => {
                if (!editorInstance || format === 'text') return; // Text 不做操作
                try {
                    const content = editorInstance.getValue();
                    const obj = parseCurrentContent(content, format);
                    let formatted = '';

                    if (format === 'json') formatted = JSON.stringify(obj, null, 2);
                    else if (format === 'xml') formatted = jsonToXml(obj);
                    else if (format === 'yaml') formatted = jsonToYaml(obj);
                    else if (format === 'ini' || format === 'toml') formatted = jsonToIni(obj);

                    editorInstance.setValue(formatted);
                    if (setTextFunc) setTextFunc(formatted);
                } catch(e) {
                    console.error("Format error", e);
                }
            }, [parseCurrentContent, jsonToXml, jsonToYaml, jsonToIni]);

            // 切换对比模式
            const toggleDiffMode = useCallback(() => {
                setIsDiffMode(prev => {
                    const newMode = !prev;
                    // 如果打开对比模式，关闭代码生成模式（互斥）
                    if (newMode && isCodeGenMode) {
                        setIsCodeGenMode(false);
                    }

                    // 切换模式时，清理所有编辑器实例
                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.dispose();
                        jsonEditorInstance.current = null;
                    }
                    if (diffEditorInstance.current) {
                        diffEditorInstance.current.dispose();
                        diffEditorInstance.current = null;
                    }
                    if (codeEditorInstance.current) {
                        codeEditorInstance.current.dispose();
                        codeEditorInstance.current = null;
                    }
                    if (gitDiffEditorInstance.current) {
                        gitDiffEditorInstance.current.dispose();
                        gitDiffEditorInstance.current = null;
                    }

                    return newMode;
                });

                setDiffAnalysis(null);
            }, [isCodeGenMode]);

            // 容错的软格式化函数（用于无法解析的 JSON）
            const softFormatJson = (text) => {
                let formatted = '';
                let indentLevel = 0;
                const indentStr = '  ';
                let inString = false; // 当前是否在字符串内
                let strQuote = null;  // 记录当前字符串使用的引号类型 (" 或 ')
                let isEscaped = false;

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];

                    if (inString) {
                        if (isEscaped) {
                            isEscaped = false; // 转义只对下一个字符有效，重置
                        } else if (char === '\\') {
                            isEscaped = true;
                        } else if (char === strQuote) {
                            inString = false;
                            strQuote = null;
                        }
                        formatted += char;
                        continue;
                    }

                    if (char === '"' || char === "'") {
                        inString = true;
                        strQuote = char;
                        formatted += char;
                        continue;
                    }

                    if (char === '{' || char === '[') {
                        formatted += char + '\n' + indentStr.repeat(++indentLevel);
                    } else if (char === '}' || char === ']') {
                        formatted += '\n' + indentStr.repeat(--indentLevel) + char;
                    } else if (char === ',') {
                        formatted += char + '\n' + indentStr.repeat(indentLevel);
                    } else if (char === ':') {
                         formatted += ': ';
                    } else if (/\s/.test(char)) {
                        // 忽略非字符串内的空白，我们自己控制缩进
                    } else {
                        formatted += char;
                    }
                }
                return formatted;
            };

            // 改进的格式化函数：智能修复并格式化JSON
            const formatJsonIntelligently = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;

                    // 安全的去注释函数 (上下文感知)
                    const safeRemoveComments = (text) => {
                        const lines = text.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let strQuote = null; // " 或 '
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (inString) {
                                    if (escaped) {
                                        escaped = false;
                                    } else if (char === '\\') {
                                        escaped = true;
                                    } else if (char === strQuote) {
                                        inString = false;
                                        strQuote = null;
                                    }
                                    cleanLine += char;
                                } else {
                                    if (char === '"' || char === "'") {
                                        inString = true;
                                        strQuote = char;
                                        cleanLine += char;
                                    } else if (char === '/' && nextChar === '/') {
                                        // 发现注释，忽略该行剩余部分
                                        break;
                                    } else {
                                        cleanLine += char;
                                    }
                                }
                            }
                            resultLines.push(cleanLine);
                        });
                        return resultLines.join('\n');
                    };

                    // 1. 优先尝试直接 Parse (保留原文的中文符号，不做任何破坏性修改)
                    try {
                        // 仅去除注释 (使用安全方法)
                        const cleanedValue = safeRemoveComments(jsonValue);
                        const parsed = JSON.parse(cleanedValue);
                        const formatted = JSON.stringify(parsed, null, 2);
                        if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(formatted);
                        setJsonText(formatted);
                        setError("");
                        setFormatErrors([]);
                        return;
                    } catch (e) {
                        // Parse 失败，继续尝试修复
                    }

                    // 2. 智能预处理：只替换字符串外部的中文标点
                    // 支持双引号和单引号作为定界符
                    const smartPreprocess = (text) => {
                        let res = '';
                        let inStr = false;
                        let strQuote = null; // " 或 '
                        let escaped = false;

                        for (let i = 0; i < text.length; i++) {
                            const char = text[i];

                            if (inStr) {
                                if (escaped) {
                                    escaped = false;
                                } else if (char === '\\') {
                                    escaped = true;
                                } else if (char === strQuote) {
                                    inStr = false;
                                    strQuote = null;
                                }
                                res += char; // 字符串内保持原样
                            } else {
                                if (char === '"' || char === "'") {
                                    inStr = true;
                                    strQuote = char;
                                }

                                // 字符串外进行替换
                                if (char === '，' || char === '。' || char === '；') res += ',';
                                else if (char === '：') res += ':';
                                else if (char === '“' || char === '”') res += '"'; // 尝试修复定界符
                                else res += char;
                            }
                        }
                        return res;
                    };

                    const fixed = smartPreprocess(jsonValue);

                    // 3. 尝试 Parse 修复后的文本
                    try {
                        const cleanedValue = safeRemoveComments(fixed);
                        const parsed = JSON.parse(cleanedValue);
                        const formatted = JSON.stringify(parsed, null, 2);
                        if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(formatted);
                        setJsonText(formatted);
                        setError(""); // 修复成功
                        setFormatErrors([]);
                        return;
                    } catch (e) {
                        // 依然失败
                    }

                    // 4. 最后的手段：软格式化 (使用修复后的文本)
                    const softFormatted = softFormatJson(fixed);
                    if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(softFormatted);
                    setJsonText(softFormatted);

                    // 尝试解析 softFormatted 以发现具体的语法错误并抛出
                    try {
                        const cleanedSoft = safeRemoveComments(softFormatted);
                        JSON.parse(cleanedSoft);
                    } catch (e) {
                        throw e; // 抛出错误以触发外层的错误提示逻辑
                    }

                    // 如果软格式化后竟然解析成功了（极少见），清除错误
                    setError("JSON存在语法错误，已执行视觉格式化");
                    setFormatErrors([]);

                } catch (err) {
                    // 解析错误位置并提示
                    let errorMsg = err.message;
                    let errorLine = -1;

                    // 重新获取最新的编辑器内容（可能是软格式化后的）
                    const currentContent = jsonEditorInstance.current?.getValue() || jsonText;
                    // 为了准确计算行号，必须基于去注释后的文本
                    const cleanedContent = safeRemoveComments(currentContent);

                    // 尝试从错误信息提取位置 (Chrome/V8: "at position X", Firefox: "at line X column Y")
                    const positionMatch = errorMsg.match(/at position (\d+)/);

                    if (positionMatch) {
                        const pos = parseInt(positionMatch[1], 10);
                        // 计算行号：基于去注释的文本计算
                        const valueUpToError = cleanedContent.substring(0, pos);
                        errorLine = valueUpToError.split('\n').length;
                        errorMsg = `格式错误 (第 ${errorLine} 行): ${errorMsg}`;

                        // 在编辑器中标记错误
                        if (jsonEditorInstance.current) {
                            const model = jsonEditorInstance.current.getModel();
                            if (model) {
                                monaco.editor.setModelMarkers(model, "json-owner", [{
                                    startLineNumber: errorLine,
                                    startColumn: 1,
                                    endLineNumber: errorLine,
                                    endColumn: model.getLineContent(errorLine).length + 1,
                                    message: err.message,
                                    severity: monaco.MarkerSeverity.Error
                                }]);
                                // 滚动到错误行
                                jsonEditorInstance.current.revealLineInCenter(errorLine);
                            }
                        }

                        setFormatErrors([{ line: errorLine, error: err.message, index: pos }]);
                    } else {
                        // 尝试匹配 line/column 格式
                         const lineMatch = errorMsg.match(/line (\d+) column (\d+)/);
                         if (lineMatch) {
                             errorLine = parseInt(lineMatch[1], 10);
                             errorMsg = `格式错误 (第 ${errorLine} 行): ${errorMsg}`;
                             setFormatErrors([{ line: errorLine, error: err.message }]);
                             if (jsonEditorInstance.current) {
                                 jsonEditorInstance.current.revealLineInCenter(errorLine);
                             }
                         }
                    }

                    setError(errorMsg);
                }
            }, [jsonText]);

            // 需求3：中文转Unicode功能
            const convertChineseToUnicode = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const converted = chineseToUnicode(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(converted);
                    }
                    setJsonText(converted);
                    setError("");
                    setFormatErrors([]);
                } catch (err) {
                    setError(`中文转Unicode错误: ${err.message}`);
                }
            }, [jsonText, chineseToUnicode]);

            // 需求3：Unicode转中文功能
            const convertUnicodeToChinese = useCallback(() => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const converted = unicodeToChinese(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(converted);
                    }
                    setJsonText(converted);
                    setError("");
                    setFormatErrors([]);
                } catch (err) {
                    setError(`Unicode转中文错误: ${err.message}`);
                }
            }, [jsonText, unicodeToChinese]);

            // 清理JSON：移除注释并格式化
            const cleanJson = useCallback((jsonString) => {
                try {
                    const withoutComments = jsonString.replace(/\/\/.*$/gm, '');
                    const parsed = JSON.parse(withoutComments);
                    return JSON.stringify(parsed, null, 2);
                } catch (err) {
                    throw new Error(`JSON清理失败: ${err.message}`);
                }
            }, []);

            // 检测时间字段
            const detectTimeFields = useCallback((obj) => {
                let count = 0;

                const traverse = (data) => {
                    if (Array.isArray(data)) {
                        data.forEach(item => {
                            if (item && typeof item === 'object') {
                                traverse(item);
                            }
                        });
                    } else if (data && typeof data === 'object') {
                        Object.entries(data).forEach(([key, value]) => {
                            if (typeof value === 'string' && isTimeString(value)) {
                                count++;
                            }
                            else if (isTimeFieldName(key)) {
                                count++;
                            }
                            if (value && typeof value === 'object') {
                                traverse(value);
                            }
                        });
                    }
                };

                traverse(obj);
                return count;
            }, []);

            // 收集生成信息
            const collectGenerationInfo = useCallback((obj, lang, detectTime, mergeArrayFields) => {
                const info = {
                    totalFields: 0,
                    nestedObjects: 0,
                    arrays: 0,
                    timeFields: 0,
                    maxDepth: 0,
                    mergedArrays: 0,
                    warnings: []
                };

                const traverse = (data, depth = 0) => {
                    info.maxDepth = Math.max(info.maxDepth, depth);

                    if (Array.isArray(data)) {
                        info.arrays++;

                        if (mergeArrayFields && data.length > 1 &&
                            data.every(item => item && typeof item === 'object' && !Array.isArray(item))) {

                            const firstKeys = Object.keys(data[0] || {});
                            let allSameStructure = true;

                            for (let i = 1; i < data.length; i++) {
                                const currentKeys = Object.keys(data[i] || {});
                                if (currentKeys.length !== firstKeys.length ||
                                    !currentKeys.every(key => firstKeys.includes(key))) {
                                    allSameStructure = false;
                                    break;
                                }
                            }

                            if (!allSameStructure) {
                                info.mergedArrays++;
                            }
                        }

                        if (data.length > 0) {
                            const firstItem = data[0];
                            if (firstItem && typeof firstItem === 'object') {
                                data.forEach(item => traverse(item, depth + 1));
                            }
                        }
                    } else if (data && typeof data === 'object') {
                        info.nestedObjects++;
                        Object.entries(data).forEach(([key, value]) => {
                            info.totalFields++;

                            if (detectTime && isTimeField(key, value)) {
                                info.timeFields++;
                            }

                            if (value && typeof value === 'object') {
                                traverse(value, depth + 1);
                            }
                        });
                    }
                };

                traverse(obj);

                if (info.maxDepth > 5) {
                    info.warnings.push(`JSON嵌套深度较深 (${info.maxDepth} 层)，可能导致生成的结构体复杂`);
                }
                if (info.arrays > 10) {
                    info.warnings.push(`数组数量较多 (${info.arrays} 个)，可能影响性能`);
                }
                if (info.mergedArrays > 0) {
                    info.warnings.push(`已合并 ${info.mergedArrays} 个数组的不同结构字段`);
                }

                return info;
            }, []);

            // 生成代码函数
            const generateCode = useCallback(() => {
                setIsGenerating(true);
                setError("");
                setGenerationInfo(null);

                try {
                    const content = jsonEditorInstance.current?.getValue() || jsonText;
                    // 根据当前格式解析为对象
                    const obj = parseCurrentContent(content, dataFormat);

                    // 注释只在 JSON 模式下尝试提取
                    let comments = null;
                    if (dataFormat === 'json') {
                         try {
                             comments = parseJsonWithComments(content).comments;
                         } catch (e) {}
                    }

                    const timeFieldsCount = detectTime ? detectTimeFields(obj) : 0;
                    setTimeFieldsDetected(timeFieldsCount);

                    const genInfo = collectGenerationInfo(obj, lang, detectTime, mergeArrayFields);
                    setGenerationInfo(genInfo);

                    const processedObj = processObject(obj);
                    const code = generateCodeFromObject(
                        processedObj,
                        lang,
                        structName,
                        goTags,
                        inlineStruct,
                        detectTime,
                        includeComments ? comments : null,
                        caseFormat
                    );

                    setGeneratedCode(code);

                    // 强制更新代码编辑器，无论是否可见
                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(code);

                            // 立即执行布局更新
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }

                    const lines = code.split('\n').length;
                    const chars = code.length;
                    setCodeStats({ lines, chars });

                } catch (err) {
                    const errorMsg = `数据解析错误: ${err.message}`;
                    setError(errorMsg);

                    const errorCode = `// ${errorMsg}\n// 请检查输入格式是否正确`;
                    setGeneratedCode(errorCode);

                    if (codeEditorInstance.current) {
                        const model = codeEditorInstance.current.getModel();
                        if (model) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(errorCode);
                        }
                    }

                    setCodeStats({ lines: 2, chars: errorCode.length });
                    setTimeFieldsDetected(0);
                    setGenerationInfo(null);
                } finally {
                    setIsGenerating(false);
                }
            }, [lang, goTags, structName, inlineStruct, detectTime, jsonText, dataFormat, mergeArrayFields, detectTimeFields, includeComments, caseFormat, parseCurrentContent, collectGenerationInfo, processObject]);

            // 通用格式化函数
            const formatJson = () => {
                if (dataFormat === 'json') {
                    formatJsonIntelligently();
                } else {
                    // 其他格式，通过 parse -> stringify 循环来格式化
                    // 或者 XML 有自己的格式化逻辑？目前先利用转换逻辑
                    try {
                        const content = jsonEditorInstance.current?.getValue() || jsonText;
                        const obj = parseCurrentContent(content, dataFormat);
                        let formatted = '';
                        if (dataFormat === 'xml') formatted = jsonToXml(obj);
                        else if (dataFormat === 'yaml') formatted = jsonToYaml(obj);
                        else if (dataFormat === 'ini' || dataFormat === 'toml') formatted = jsonToIni(obj);

                        if (jsonEditorInstance.current) jsonEditorInstance.current.setValue(formatted);
                        setJsonText(formatted);
                        setError(""); // 需求1: 成功不显示提示
                    } catch (e) {
                         setError(`格式化失败: ${e.message}`);
                    }
                }
            };

            const minifyJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const { parsed: obj } = parseJsonWithComments(jsonValue);
                    const minified = JSON.stringify(obj);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(minified);
                    }
                    setJsonText(minified);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`压缩错误: ${err.message}`);
                }
            };

            const escapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const escaped = JSON.stringify(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(escaped);
                    }
                    setJsonText(escaped);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`转义错误: ${err.message}`);
                }
            };

            const unescapeJson = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;
                    const unescaped = JSON.parse(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(unescaped);
                    }
                    setJsonText(unescaped);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`去转义错误: ${err.message}`);
                }
            };

            // 改进的移除注释函数
            const removeComments = () => {
                try {
                    const jsonValue = jsonEditorInstance.current?.getValue() || jsonText;

                    const removeJsonComments = (jsonString) => {
                        const lines = jsonString.split('\n');
                        const resultLines = [];

                        lines.forEach(line => {
                            let inString = false;
                            let escaped = false;
                            let cleanLine = '';

                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                const nextChar = i + 1 < line.length ? line[i + 1] : '';

                                if (!escaped && char === '\\') {
                                    escaped = true;
                                    cleanLine += char;
                                } else if (!escaped && char === '"') {
                                    inString = !inString;
                                    cleanLine += char;
                                } else if (!inString && char === '/' && nextChar === '/') {
                                    break;
                                } else {
                                    cleanLine += char;
                                    escaped = false;
                                }
                            }

                            resultLines.push(cleanLine);
                        });

                        return resultLines.join('\n');
                    };

                    const cleaned = removeJsonComments(jsonValue);

                    if (jsonEditorInstance.current) {
                        jsonEditorInstance.current.setValue(cleaned);
                    }
                    setJsonText(cleaned);
                    setError("");
                    setFormatErrors([]);
                    setJsonStats(prev => ({ ...prev, errorLines: 0 }));
                } catch (err) {
                    setError(`移除注释错误: ${err.message}`);
                }
            };

            // 需求2和3：清空功能，同时清空JSON框和代码框
            const clearAll = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue('');
                }
                if (codeEditorInstance.current) {
                    codeEditorInstance.current.setValue('');
                }
                setJsonText('');
                setGeneratedCode('');
                setError("");
                setFormatErrors([]);
                setGenerationInfo(null);
                setJsonStats({ lines: 0, chars: 0, commentLines: 0, errorLines: 0 });
                setCodeStats({ lines: 0, chars: 0 });
                setTimeFieldsDetected(0);
            };

            const loadComplexJson = () => {
                if (jsonEditorInstance.current) {
                    jsonEditorInstance.current.setValue(COMPLEX_JSON);
                }
                setJsonText(COMPLEX_JSON);
                setError("");
                setFormatErrors([]);
                setJsonStats(prev => ({ ...prev, errorLines: 0 }));
            };

            // 处理文件上传
            const handleFileUpload = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const fileName = file.name;
                const fileExt = fileName.split('.').pop().toLowerCase();
                const target = uploadTargetRef.current;

                // 映射后缀到格式
                let targetFormat = 'text'; // 默认为文本
                if (fileExt === 'json') targetFormat = 'json';
                else if (fileExt === 'xml') targetFormat = 'xml';
                else if (['yaml', 'yml'].includes(fileExt)) targetFormat = 'yaml';
                else if (fileExt === 'toml') targetFormat = 'toml';
                else if (['ini', 'conf', 'cfg', 'properties'].includes(fileExt)) targetFormat = 'ini';

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;

                    if (target === 'main') {
                        // 更新主编辑器（或左侧对比编辑器）
                        if (!isDiffMode) {
                            setDataFormat(targetFormat);
                        } else {
                            setLeftFormat(targetFormat);
                        }

                        if (jsonEditorInstance.current) {
                            jsonEditorInstance.current.setValue(content);
                            const model = jsonEditorInstance.current.getModel();
                            if (model) {
                                monaco.editor.setModelLanguage(model, DATA_FORMATS[targetFormat].monacoLang);
                            }
                        }
                        setJsonText(content);
                    } else if (target === 'diff') {
                        // 更新右侧对比编辑器
                        setRightFormat(targetFormat);

                        if (diffEditorInstance.current) {
                            diffEditorInstance.current.setValue(content);
                            const model = diffEditorInstance.current.getModel();
                            if (model) {
                                monaco.editor.setModelLanguage(model, DATA_FORMATS[targetFormat].monacoLang);
                            }
                        }
                        setDiffText(content);
                    } else if (target === 'git-original') {
                        // Git Diff 左侧
                         setLeftFormat(targetFormat);
                         // Git Diff 模式下通常直接更新 text state，由 effect 同步 model
                         // 但这里还是手动更新 model 比较保险（如果实例存在）
                         // 注意：Git 模式下的编辑器实例是 gitDiffEditorInstance
                         // 这里的逻辑可能需要根据 git 模式做特殊处理，但目前 git 模式是基于 jsonText 和 diffText 初始化的
                         // 且 gitDiffEditorInstance.current.setModel 已经绑定了
                         setJsonText(content);
                    } else if (target === 'git-modified') {
                         // Git Diff 右侧
                         setRightFormat(targetFormat);
                         setDiffText(content);
                    }

                    setError(""); // 清除错误
                    setFormatErrors([]);

                    // 清除input值，以便允许重复上传同一文件
                    event.target.value = '';
                };
                reader.onerror = (e) => {
                    setError("文件读取失败");
                };
                reader.readAsText(file);
            };

            // 触发上传辅助函数
            const triggerUpload = (target) => {
                uploadTargetRef.current = target;
                if (fileInputRef.current) {
                    fileInputRef.current.click();
                }
            };

            // 复制代码到剪贴板
            const copyCode = () => {
                if (generatedCode) {
                    navigator.clipboard.writeText(generatedCode)
                        .then(() => {
                            console.log("代码已复制到剪贴板");
                        })
                        .catch(err => {
                            console.error("复制失败:", err);
                        });
                }
            };

            // 下载代码
            const downloadCode = () => {
                if (!generatedCode) return;

                const blob = new Blob([generatedCode], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${structName}.${LANGUAGE_CONFIG[lang].fileExt}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // 处理Go标签更新
            const updateGoTag = (tag, checked) => {
                setGoTags(prev => ({
                    ...prev,
                    [tag]: checked
                }));
            };

            // 修复的toggleCodeGenMode函数
            const toggleCodeGenMode = () => {
                const newMode = !isCodeGenMode;
                setIsCodeGenMode(newMode);
                // 互斥：打开代码生成，关闭对比
                if (newMode && isDiffMode) {
                    setIsDiffMode(false);
                    setDiffResult(null);
                    // 清理 Diff 编辑器
                    if (diffEditorInstance.current) {
                        diffEditorInstance.current.dispose();
                        diffEditorInstance.current = null;
                    }
                }

                // 当重新打开代码生成模式时，确保代码编辑器内容是最新的
                if (newMode && generatedCode && codeEditorInstance.current) {
                    // 给DOM一些时间来渲染
                    setTimeout(() => {
                        const model = codeEditorInstance.current.getModel();
                        if (model && model.getValue() !== generatedCode) {
                            codeEditorInstance.current.pushUndoStop();
                            model.setValue(generatedCode);

                            // 强制重新布局
                            requestAnimationFrame(() => {
                                if (codeEditorInstance.current) {
                                    codeEditorInstance.current.layout();
                                }
                            });
                        }
                    }, 50);
                }
            };

            // 监听 generatedCode 变化，确保代码编辑器同步更新
            useEffect(() => {
                if (codeEditorInstance.current && generatedCode && isCodeGenMode) {
                    const model = codeEditorInstance.current.getModel();
                    if (model && model.getValue() !== generatedCode) {
                        codeEditorInstance.current.pushUndoStop();
                        model.setValue(generatedCode);

                        // 延迟布局更新，确保DOM已渲染
                        setTimeout(() => {
                            if (codeEditorInstance.current) {
                                codeEditorInstance.current.layout();
                            }
                        }, 10);
                    }
                }
            }, [generatedCode, isCodeGenMode]);

            return React.createElement("div", { className: "app-container" },
                // 隐藏的文件上传输入框
                React.createElement("input", {
                    type: "file",
                    ref: fileInputRef,
                    style: { display: "none" },
                    onChange: handleFileUpload,
                    accept: ".json,.xml,.yaml,.yml,.toml,.ini,.conf,.cfg,.properties,.txt"
                }),
                React.createElement("div", { className: "header" },
                    React.createElement("h1", null,
                        React.createElement("i", { className: "fas fa-code" }),
                        "JSON → 多语言结构体生成器"
                    ),
                    React.createElement("div", { className: "subtitle" },
                        "支持 Golang, Java, TypeScript, Python, Kotlin, Rust"
                    )
                ),

                React.createElement("div", { className: "config-panel" },
                    React.createElement("div", { className: "config-content" },
                        // 需求 2: 对比模式下隐藏大部分按钮，只留对比开关 (以及可能的执行对比)
                        // 需求 1: 不同格式显示不同按钮

                        React.createElement("div", { className: "action-buttons compact-actions" },
                            // 对比模式下只显示对比相关的
                            isDiffMode ? (
                                React.createElement(React.Fragment, null,
                                    React.createElement("button", {
                                            className: "btn btn-primary btn-compact",
                                            onClick: performDiff,
                                            title: "执行JSON对比"
                                        },
                                        React.createElement("i", { className: "fas fa-code-compare" }),
                                        "执行对比"
                                    ),
                                    // 视图切换按钮
                                    React.createElement("div", { className: "mode-switch-inline", style: { marginLeft: "8px" } },
                                        React.createElement("div", {
                                            style: { display: "flex", gap: "2px", background: "rgba(0,0,0,0.2)", padding: "2px", borderRadius: "4px" }
                                        },
                                            React.createElement("button", {
                                                className: `btn-sm ${diffViewMode === 'split' ? 'btn-primary' : 'btn-secondary'}`,
                                                onClick: () => setDiffViewMode('split'),
                                                style: { border: 'none', borderRadius: '3px', padding: '2px 8px' }
                                            }, "语义视图"),
                                            React.createElement("button", {
                                                className: `btn-sm ${diffViewMode === 'git' ? 'btn-primary' : 'btn-secondary'}`,
                                                onClick: () => setDiffViewMode('git'),
                                                style: { border: 'none', borderRadius: '3px', padding: '2px 8px' }
                                            }, "Git视图")
                                        )
                                    )
                                )
                            ) : (
                                React.createElement(React.Fragment, null,
                                    // 代码生成开关 (非对比模式下显示)
                                    React.createElement("div", { className: "mode-switch-inline" },
                                        React.createElement("label", { className: "switch" },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                checked: isCodeGenMode,
                                                onChange: toggleCodeGenMode
                                            }),
                                            React.createElement("span", { className: "slider" })
                                        ),
                                        React.createElement("span", { className: "switch-label" },
                                            "代码生成"
                                        )
                                    ),

                                    // 仅在 JSON 模式下显示完整工具栏
                                    dataFormat === 'json' ? (
                                        React.createElement(React.Fragment, null,
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: formatJson,
                                                title: "智能格式化"
                                            }, React.createElement("i", { className: "fas fa-indent" }), "格式化"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: removeComments,
                                                title: "移除注释"
                                            }, React.createElement("i", { className: "fas fa-comment-slash" }), "去注释"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: minifyJson,
                                                title: "压缩"
                                            }, React.createElement("i", { className: "fas fa-compress" }), "压缩"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: escapeJson,
                                                title: "转义"
                                            }, React.createElement("i", { className: "fas fa-code" }), "转义"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: unescapeJson,
                                                title: "去转义"
                                            }, React.createElement("i", { className: "fas fa-code" }), "去转义"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: convertChineseToUnicode,
                                                title: "中文→Unicode"
                                            }, React.createElement("i", { className: "fas fa-language" }), "中文→Uni"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: convertUnicodeToChinese,
                                                title: "Unicode→中文"
                                            }, React.createElement("i", { className: "fas fa-language" }), "Uni→中文"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: loadComplexJson,
                                                title: "复杂示例"
                                            }, React.createElement("i", { className: "fas fa-cogs" }), "复杂示例"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: clearAll,
                                                title: "清空"
                                            }, React.createElement("i", { className: "fas fa-trash" }), "清空")
                                        )
                                    ) : (
                                        // 其他模式只显示 格式化、清空
                                        React.createElement(React.Fragment, null,
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: formatJson,
                                                title: "格式化"
                                            }, React.createElement("i", { className: "fas fa-indent" }), "格式化"),
                                            React.createElement("button", {
                                                className: "btn btn-secondary btn-compact",
                                                onClick: clearAll,
                                                title: "清空"
                                            }, React.createElement("i", { className: "fas fa-trash" }), "清空")
                                        )
                                    ),

                                    // 代码生成按钮 (在开启代码生成且非对比模式下)
                                    isCodeGenMode && React.createElement("button", {
                                            className: "btn btn-primary btn-compact",
                                            onClick: generateCode,
                                            disabled: isGenerating,
                                            title: "生成代码"
                                        },
                                        isGenerating ? "生成中..." : "生成代码"
                                    )
                                )
                            ),

                            // 对比模式开关 (始终显示或在右侧)
                            React.createElement("div", { className: "mode-switch-inline", style: { marginLeft: "auto" } },
                                React.createElement("label", { className: "switch" },
                                    React.createElement("input", {
                                        type: "checkbox",
                                        checked: isDiffMode,
                                        onChange: toggleDiffMode
                                    }),
                                    React.createElement("span", { className: "slider" })
                                ),
                                React.createElement("span", { className: "switch-label" },
                                    "对比模式"
                                )
                            )
                        ),

            isCodeGenMode && React.createElement("div", { className: "config-row code-gen-config" },
                React.createElement("div", { className: "config-group compact-group" },
                    React.createElement("label", { htmlFor: "language-select" }, "目标语言"),
                    React.createElement("div", { className: "language-select" },
                        React.createElement("select", {
                                id: "language-select",
                                value: lang,
                                onChange: (e) => setLang(e.target.value),
                                className: "compact-select"
                            },
                            Object.entries(LANGUAGE_CONFIG).map(([value, config]) =>
                                React.createElement("option", { key: value, value: value },
                                    config.name
                                )
                            )
                        )
                    )
                ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "struct-name" }, "结构体名"),
                                React.createElement("input", {
                                    id: "struct-name",
                                    type: "text",
                                    value: structName,
                                    onChange: (e) => setStructName(e.target.value),
                                    className: "compact-input"
                                })
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", { htmlFor: "case-format" }, "命名格式"),
                                React.createElement("select", {
                                        id: "case-format",
                                        className: "format-select case-format-select compact-select",
                                        value: caseFormat,
                                        onChange: (e) => setCaseFormat(e.target.value)
                                    },
                                    Object.entries(CASE_FORMATS).map(([value, config]) =>
                                        React.createElement("option", { key: value, value: value },
                                            config.name
                                        )
                                    )
                                )
                            ),

                            React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "选项"),
                                React.createElement("div", { className: "checkbox-options compact-options" },
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "inline-struct",
                                            checked: inlineStruct,
                                            onChange: (e) => setInlineStruct(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "inline-struct",
                                            title: "内联结构体"
                                        }, "内联")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "detect-time",
                                            checked: detectTime,
                                            onChange: (e) => setDetectTime(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "detect-time",
                                            title: "检测时间类型"
                                        }, "时间")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "include-comments",
                                            checked: includeComments,
                                            onChange: (e) => setIncludeComments(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "include-comments",
                                            title: "包含注释"
                                        }, "注释")
                                    ),
                                    React.createElement("div", { className: "checkbox-item compact-item" },
                                        React.createElement("input", {
                                            type: "checkbox",
                                            id: "merge-array-fields",
                                            checked: mergeArrayFields,
                                            onChange: (e) => setMergeArrayFields(e.target.checked)
                                        }),
                                        React.createElement("label", {
                                            htmlFor: "merge-array-fields",
                                            title: "合并数组字段"
                                        }, "合并数组")
                                    )
                                )
                            ),

                            lang === "go" && React.createElement("div", { className: "config-group compact-group" },
                                React.createElement("label", null, "Go标签"),
                                React.createElement("div", { className: "go-tags-container compact-tags" },
                                    Object.entries(goTags).map(([tag, checked]) =>
                                        React.createElement("div", { className: "tag-checkbox compact-tag", key: tag },
                                            React.createElement("input", {
                                                type: "checkbox",
                                                id: `tag-${tag}`,
                                                checked: checked,
                                                onChange: (e) => updateGoTag(tag, e.target.checked)
                                            }),
                                            React.createElement("label", {
                                                htmlFor: `tag-${tag}`,
                                                title: tag
                                            }, tag === "omitempty" ? "omit" : tag)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    error && React.createElement("div", { className: "error-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        error
                    ),

                    isCodeGenMode && generationInfo && React.createElement("div", { className: "generation-info" },
                        React.createElement("div", { className: "generation-info-compact" },
                            React.createElement("div", { className: "generation-info-group" },
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "字段: "),
                                    React.createElement("span", { className: "value" }, generationInfo.totalFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "嵌套: "),
                                    React.createElement("span", { className: "value" }, generationInfo.nestedObjects)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "数组: "),
                                    React.createElement("span", { className: "value" }, generationInfo.arrays)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "时间: "),
                                    React.createElement("span", { className: "value" }, generationInfo.timeFields)
                                ),
                                React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "深度: "),
                                    React.createElement("span", { className: "value" }, generationInfo.maxDepth)
                                ),
                                generationInfo.mergedArrays > 0 && React.createElement("div", { className: "generation-info-stat" },
                                    React.createElement("span", { className: "label" }, "合并: "),
                                    React.createElement("span", { className: "value warning" }, generationInfo.mergedArrays)
                                )
                            )
                        )
                    ),

                    isCodeGenMode && generationInfo && generationInfo.warnings.length > 0 &&
                    React.createElement("div", { className: "warning-message" },
                        React.createElement("i", { className: "fas fa-exclamation-triangle" }),
                        React.createElement("div", null,
                            generationInfo.warnings.map((warning, index) =>
                                React.createElement("div", { key: index }, warning)
                            )
                        )
                    ),

                    // 显示格式化错误详细信息
                    formatErrors.length > 0 && React.createElement("div", { className: "format-error-details" },
                        React.createElement("div", { style: { display: "flex", alignItems: "center", gap: "6px", marginBottom: "6px" } },
                            React.createElement("i", { className: "fas fa-exclamation-circle" }),
                            React.createElement("strong", null, `发现 ${formatErrors.length} 个格式错误:`)
                        ),
                        formatErrors.slice(0, 5).map((error, index) =>
                            React.createElement("div", { key: index, className: "format-error-line" },
                                React.createElement("span", { className: "unicode-preview" },
                                    `第 ${error.line} 行: ${error.error}`
                                ),
                                index < 3 && error.index &&
                                    React.createElement("span", { style: { fontSize: "10px", color: "#94a3b8" } },
                                        `位置: ${error.index}`
                                    )
                            )
                        ),
                        formatErrors.length > 5 &&
                            React.createElement("div", { className: "unicode-preview", style: { marginTop: "4px" } },
                                `... 还有 ${formatErrors.length - 5} 个错误`
                            )
                    )
                ),

                React.createElement("div", { className: "editor-panels" },
                    !isDiffMode && React.createElement("div", {
                            className: `panel ${isCodeGenMode ? 'json-panel partial-width' : 'json-panel full-width'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-header-content" },
                                React.createElement("div", { className: "panel-title" },
                                    React.createElement("i", { className: "fas fa-code" }),
                                    DATA_FORMATS[dataFormat].name + " 输入"
                                ),
                                // 需求2：格式转换功能嵌入header栏 - 选择目标格式自动转换
                                React.createElement("div", { className: "header-conversion-tools" },
                                    // 新增：上传文件按钮
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => triggerUpload('main'),
                                        title: "上传文件 (支持拖拽或大文件)",
                                        style: { marginRight: "6px", height: "24px", padding: "0 8px" }
                                    }, React.createElement("i", { className: "fas fa-upload" }), " 上传"),

                                    React.createElement("span", { style: { fontSize: "12px", color: "#94a3b8", marginRight: "4px" } }, "转换为:"),
                                    React.createElement("select", {
                                        className: "format-select compact-select",
                                        value: dataFormat,
                                        onChange: (e) => handleSmartFormatChange(e.target.value, 'main'),
                                        title: "选择格式 (智能切换/转换)"
                                    },
                                        // 需求1：非对比模式下过滤 text 类型
                                        Object.entries(DATA_FORMATS)
                                            .filter(([val]) => val !== 'text')
                                            .map(([value, config]) =>
                                                React.createElement("option", { key: value, value: value },
                                                    config.name
                                                )
                                            )
                                    )
                                )
                            ),
                            React.createElement("div", { className: "json-tools" },
                                React.createElement("div", { className: "panel-stats" },
                                    `${jsonStats.lines} 行, ${jsonStats.chars} 字符`,
                                    jsonStats.commentLines > 0 &&
                                        React.createElement("span", { style: { marginLeft: "8px", color: "#60a5fa" } },
                                            `${jsonStats.commentLines} 注释`
                                        ),
                                    jsonStats.errorLines > 0 &&
                                        React.createElement("span", { style: { marginLeft: "8px", color: "#f87171" } },
                                            `${jsonStats.errorLines} 错误`
                                        )
                                )
                            )
                        ),
                        React.createElement("div", {
                            ref: jsonEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // 修复：始终渲染代码面板，用CSS控制显示
                    !isDiffMode && React.createElement("div", {
                            className: `panel code-panel ${isCodeGenMode ? '' : 'hidden'}`
                        },
                        React.createElement("div", { className: "panel-header" },
                            React.createElement("div", { className: "panel-title" },
                                React.createElement("i", { className: "fas fa-file-code" }),
                                `${LANGUAGE_CONFIG[lang].name} 代码`
                            ),
                            React.createElement("div", { className: "panel-stats" },
                                generatedCode && isCodeGenMode
                                    ? `${codeStats.lines} 行, ${codeStats.chars} 字符`
                                    : "等待生成代码"
                            )
                        ),
                        React.createElement("div", {
                            ref: codeEditorRef,
                            className: "panel-content"
                        })
                    ),

                    // 需求2：对比模式布局
                    isDiffMode && (
                        diffViewMode === 'git' ? (
                            // === Git Diff 视图 ===
                            React.createElement("div", { className: "diff-layout", style: { width: '100%', flexDirection: 'column' } },
                                React.createElement("div", { className: "diff-header", style: { border: '1px solid #334155', borderBottom: 'none', borderRadius: '6px 6px 0 0' } },
                                    React.createElement("div", { className: "diff-title" },
                                        React.createElement("i", { className: "fas fa-git-alt", style: { marginRight: '8px', color: '#f14e32' } }),
                                        "Git Diff 模式 (左侧可编辑)"
                                    ),
                                    // 复用格式选择，控制高亮语言
                                    React.createElement("div", { className: "header-conversion-tools" },
                                        React.createElement("span", { style: { fontSize: '12px', color: '#94a3b8', marginRight: '4px'} }, "语言:"),
                                        React.createElement("select", {
                                            className: "format-select compact-select",
                                            value: leftFormat,
                                            onChange: (e) => {
                                                setLeftFormat(e.target.value);
                                                setRightFormat(e.target.value); // Git模式建议保持一致
                                            }
                                        },
                                            Object.entries(DATA_FORMATS).map(([val, conf]) =>
                                                React.createElement("option", { key: val, value: val }, conf.name)
                                            )
                                        )
                                    )
                                ),
                                React.createElement("div", {
                                    ref: gitDiffContainerRef,
                                    style: { flex: 1, border: '1px solid #334155', borderRadius: '0 0 6px 6px', overflow: 'hidden' }
                                })
                            )
                        ) : (
                            // === 原有分栏视图 ===
                            React.createElement("div", { className: "diff-layout", style: { width: '100%' } },

                                // 左侧编辑器 (35%)
                                React.createElement("div", { className: "diff-side", style: { flex: '0 0 35%', maxWidth: '35%', width: '35%' } },
                                    // 左侧 Header
                                    React.createElement("div", { className: "diff-header" },
                                React.createElement("div", { className: "diff-title" },
                                    React.createElement("select", {
                                            className: "format-select compact-select",
                                            value: leftFormat,
                                            onChange: (e) => handleSmartFormatChange(e.target.value, 'diff-left'),
                                            style: { marginRight: '8px' }
                                        },
                                        Object.entries(DATA_FORMATS).map(([val, conf]) =>
                                            React.createElement("option", { key: val, value: val }, conf.name)
                                        )
                                    ),
                                    "原始文本"
                                ),
                                React.createElement("div", { className: "header-conversion-tools" },
                                    // 左侧上传按钮
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => triggerUpload('main'),
                                        title: "上传文件",
                                        style: { marginRight: "4px" }
                                    }, React.createElement("i", { className: "fas fa-upload" })),
                                    leftFormat !== 'text' && React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => formatEditorContent(jsonEditorInstance.current, leftFormat, setJsonText),
                                        title: "格式化"
                                    }, React.createElement("i", { className: "fas fa-indent" })),
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => {
                                            if (jsonEditorInstance.current) jsonEditorInstance.current.setValue('');
                                            setJsonText('');
                                        },
                                        title: "清空"
                                    }, React.createElement("i", { className: "fas fa-trash" }))
                                )
                            ),
                            React.createElement("div", {
                                ref: diffLeftEditorRef,
                                className: "diff-content"
                            })
                        ),

                        // 中间差异信息框 (30%) - 终端样式
                        React.createElement("div", { className: "diff-info-panel", style: { flex: '0 0 30%', maxWidth: '30%', width: '30%' } },
                             React.createElement("div", { className: "terminal-header" },
                                React.createElement("div", { className: "terminal-dot", style: { background: '#ef4444' } }),
                                React.createElement("div", { className: "terminal-dot", style: { background: '#eab308' } }),
                                React.createElement("div", { className: "terminal-dot", style: { background: '#22c55e' } }),
                                React.createElement("span", { style: { marginLeft: '10px' } }, "Diff Analysis Terminal")
                             ),
                             React.createElement("div", { className: "terminal-content" },
                                 !diffAnalysis ?
                                    React.createElement("div", { style: { color: '#64748b' } },
                                        "> 等待执行对比...\n> 请点击上方 '执行对比' 按钮"
                                    ) :
                                    React.createElement(React.Fragment, null,
                                        React.createElement("div", { style: { marginBottom: '10px', borderBottom: '1px dashed #334155', paddingBottom: '10px' } },
                                            React.createElement("div", null, `> 原始格式: ${DATA_FORMATS[diffAnalysis.leftFormat].name}`),
                                            React.createElement("div", null, `> 目标格式: ${DATA_FORMATS[diffAnalysis.rightFormat].name}`),
                                            React.createElement("div", null, `> 差异统计: +${diffAnalysis.stats.added} / -${diffAnalysis.stats.removed} / ~${diffAnalysis.stats.modified}`)
                                        ),
                                        diffAnalysis.differences.length === 0 ?
                                            React.createElement("div", { style: { color: '#22c55e' } }, "> √ 两份数据在语义上完全一致") :
                                            diffAnalysis.differences.map((diff, i) =>
                                                React.createElement("div", { key: i, style: { marginBottom: '8px', fontFamily: 'monospace' } },
                                                    React.createElement("div", { style: { color: '#94a3b8', display: 'flex', justifyContent: 'space-between', alignItems: 'center' } },
                                                        React.createElement("span", null, `PATH: ${diff.path || '(root)'}`),
                                                        React.createElement("span", { style: { fontSize: '10px', color: '#64748b' } },
                                                            diff.leftLine || diff.rightLine ?
                                                                `L:${diff.leftLine || '-'} / R:${diff.rightLine || '-'}` : ''
                                                        )
                                                    ),
                                                    (diff.type === 'removed' || diff.type === 'modified') &&
                                                        React.createElement("div", { style: { color: '#ef4444', display: 'flex', alignItems: 'center', gap: '8px' } },
                                                            diff.leftLine && React.createElement("span", { style: { fontSize: '10px', color: '#f87171', minWidth: '35px' } }, `[${diff.leftLine}]`),
                                                            React.createElement("span", null, `- ${JSON.stringify(diff.oldValue !== undefined ? diff.oldValue : diff.value)}`)
                                                        ),
                                                    (diff.type === 'added' || diff.type === 'modified') &&
                                                        React.createElement("div", { style: { color: '#22c55e', display: 'flex', alignItems: 'center', gap: '8px' } },
                                                            diff.rightLine && React.createElement("span", { style: { fontSize: '10px', color: '#4ade80', minWidth: '35px' } }, `[${diff.rightLine}]`),
                                                            React.createElement("span", null, `+ ${JSON.stringify(diff.newValue !== undefined ? diff.newValue : diff.value)}`)
                                                        )
                                                )
                                            )
                                    )
                             )
                        ),

                        // 右侧编辑器 (35%)
                        React.createElement("div", { className: "diff-side", style: { flex: '0 0 35%', maxWidth: '35%', width: '35%' } },
                            // 右侧 Header
                            React.createElement("div", { className: "diff-header" },
                                React.createElement("div", { className: "diff-title" },
                                    React.createElement("select", {
                                            className: "format-select compact-select",
                                            value: rightFormat,
                                            onChange: (e) => handleSmartFormatChange(e.target.value, 'diff-right'),
                                            style: { marginRight: '8px' }
                                        },
                                        Object.entries(DATA_FORMATS).map(([val, conf]) =>
                                            React.createElement("option", { key: val, value: val }, conf.name)
                                        )
                                    ),
                                    "对比文本"
                                ),
                                React.createElement("div", { className: "header-conversion-tools" },
                                    // 右侧上传按钮
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => triggerUpload('diff'),
                                        title: "上传文件",
                                        style: { marginRight: "4px" }
                                    }, React.createElement("i", { className: "fas fa-upload" })),
                                    rightFormat !== 'text' && React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => formatEditorContent(diffEditorInstance.current, rightFormat, setDiffText),
                                        title: "格式化"
                                    }, React.createElement("i", { className: "fas fa-indent" })),
                                    React.createElement("button", {
                                        className: "btn btn-secondary btn-sm",
                                        onClick: () => {
                                            if (diffEditorInstance.current) diffEditorInstance.current.setValue('');
                                            setDiffText('');
                                        },
                                        title: "清空"
                                    }, React.createElement("i", { className: "fas fa-trash" }))
                                )
                            ),
                            React.createElement("div", {
                                ref: diffEditorRef,
                                className: "diff-content"
                            })
                        )
                    )
                )
            )
        ),

                isCodeGenMode && React.createElement("div", { className: "status-bar" },
                    React.createElement("div", { className: "status-item" },
                        React.createElement("div", { className: "language-badge" },
                            // 判断是 Emoji 还是 FontAwesome 类名
                            LANGUAGE_CONFIG[lang].icon.startsWith('fa')
                                ? React.createElement("i", { className: LANGUAGE_CONFIG[lang].icon })
                                : React.createElement("span", { style: { marginRight: '6px' } }, LANGUAGE_CONFIG[lang].icon),
                            LANGUAGE_CONFIG[lang].name
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: inlineStruct ? "#86efac" : "#fbbf24"
                                }
                            },
                            inlineStruct ? "内联模式" : "拆分模式"
                        ),
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: includeComments ? "#86efac" : "#94a3b8"
                                }
                            },
                            includeComments ? "含注释" : "无注释"
                        ),
                        detectTime && timeFieldsDetected > 0 &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#60a5fa"
                                }
                            },
                            `时间字段: ${timeFieldsDetected}`
                        ),
                        mergeArrayFields &&
                        React.createElement("span", {
                                style: {
                                    marginLeft: "6px",
                                    fontSize: "11px",
                                    color: "#fbbf24"
                                }
                            },
                            "合并数组"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("i", { className: "fas fa-info-circle info-icon" }),
                        React.createElement("span", null,
                            CASE_FORMATS[caseFormat]?.name || "大驼峰 (PascalCase)"
                        )
                    ),
                    React.createElement("div", { className: "status-item" },
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: copyCode,
                                disabled: !generatedCode
                            },
                            React.createElement("i", { className: "fas fa-copy" }),
                            "复制"
                        ),
                        React.createElement("button", {
                                className: "btn btn-secondary btn-sm",
                                onClick: downloadCode,
                                disabled: !generatedCode,
                            },
                            React.createElement("i", { className: "fas fa-download" }),
                            "下载"
                        )
                    )
                ),

                React.createElement("div", { className: "footer" },
                    React.createElement("div", null,
                        "© 2024 JSON Converter Tool | ",
                        React.createElement("a", { href: "#", onClick: (e) => e.preventDefault() }, "京ICP备XXXXXXXX号-1"),
                        " | ",
                        React.createElement("a", { href: "#", onClick: (e) => e.preventDefault() }, "隐私政策")
                    )
                )
            )
        }

        // ============= 修复的辅助函数 =============

        function isTimeString(value) {
            return TIME_PATTERNS.some(pattern => pattern.test(value));
        }

        function isTimeFieldName(fieldName) {
            return /(time|date|timestamp|created|updated|start|end|at)$/i.test(fieldName);
        }

        function isTimeField(key, value) {
            if (typeof value === 'string' && isTimeString(value)) {
                return true;
            }
            if (isTimeFieldName(key)) {
                return true;
            }
            return false;
        }

        function getTimeType(lang) {
            switch(lang) {
                case 'go': return 'time.Time';
                case 'java': return 'java.time.LocalDateTime';
                case 'typescript': return 'Date';
                case 'python': return 'datetime.datetime';
                case 'kotlin': return 'java.time.LocalDateTime';
                case 'rust': return 'chrono::DateTime<chrono::Utc>';
                default: return 'string';
            }
        }

        // 修复的字段名格式化函数（保留中文）
        function formatFieldName(name, format, lang, isStructName = false) {
            if (!name || name.trim() === '') return name;

            // 检查是否是中文字段
            const hasChinese = /[\u4e00-\u9fa5]/.test(name);

            let cleaned = name;

            // 如果不是中文，进行格式转换
            if (!hasChinese && CASE_FORMATS[format]) {
                cleaned = CASE_FORMATS[format].fn(cleaned);
            }

            // Go语言的结构体名需要首字母大写
            if (lang === 'go' && isStructName) {
                if (hasChinese) {
                    cleaned = cleaned;
                } else {
                    cleaned = cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
                }
            }

            // 如果开头是数字，添加前缀
            if (/^\d/.test(cleaned)) {
                cleaned = 'field' + cleaned;
            }

            return cleaned;
        }

        function generateCodeFromObject(obj, lang, structName, goTags, inlineStruct, detectTime, comments, caseFormat) {
            const formatName = (name, isStructName = false) =>
                formatFieldName(name, caseFormat, lang, isStructName);

            if (lang === "go") return genGo(obj, formatName(structName, true), goTags, inlineStruct, detectTime, comments, formatName);
            if (lang === "typescript") return genTypeScript(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "java") return genJava(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "python") return genPython(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "kotlin") return genKotlin(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            if (lang === "rust") return genRust(obj, formatName(structName, true), inlineStruct, detectTime, comments, formatName);
            return `// 不支持的语言: ${lang}`;
        }

        // 修复的inferType函数，支持多维数组
        function inferType(value, lang, key = '', detectTime = false, parentPath = '') {
            if (detectTime && isTimeField(key, value)) {
                return getTimeType(lang);
            }

            if (value === null) {
                if (lang === "typescript") return "null";
                if (lang === "java") return "Object";
                if (lang === "kotlin") return "Any?";
                if (lang === "rust") return "Option<serde_json::Value>";
                return "any";
            }

            if (Array.isArray(value)) {
                if (value.length === 0) {
                    if (lang === "go") return "[]interface{}";
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                const firstItem = value[0];

                // 处理多维数组
                if (Array.isArray(firstItem)) {
                    // 递归推断内部数组类型
                    const innerType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                    const baseType = innerType
                        .replace('[]', '')
                        .replace('List<', '')
                        .replace('>', '')
                        .replace('Vec<', '')
                        .replace('List[', '')
                        .replace(']', '');

                    if (lang === "go") return `[][]${baseType}`;
                    if (lang === "typescript") return `${baseType}[][]`;
                    if (lang === "java") return `List<List<${baseType}>>`;
                    if (lang === "kotlin") return `List<List<${baseType}>>`;
                    if (lang === "rust") return `Vec<Vec<${baseType}>>`;
                    if (lang === "python") return `List[List[${baseType}]]`;
                }

                // 检查数组元素是否都是对象
                const allObjects = value.every(item => item && typeof item === 'object' && !Array.isArray(item));

                if (allObjects) {
                    // 对于Go语言，返回占位符，由上层函数处理
                    if (lang === "go") return "[]struct{}";
                    // 其他语言返回通用类型
                    if (lang === "typescript") return "any[]";
                    if (lang === "java") return "List<Object>";
                    if (lang === "kotlin") return "List<Any?>";
                    if (lang === "rust") return "Vec<serde_json::Value>";
                    if (lang === "python") return "List[Any]";
                }

                // 基本类型数组
                const itemType = inferType(firstItem, lang, key, detectTime, parentPath + '.' + key);
                if (lang === "go") return `[]${itemType}`;
                if (lang === "typescript") return `${itemType}[]`;
                if (lang === "java") return `List<${itemType}>`;
                if (lang === "kotlin") return `List<${itemType}>`;
                if (lang === "rust") return `Vec<${itemType}>`;
                if (lang === "python") return `List[${itemType}]`;
            }

            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                if (Object.keys(value).length === 0) {
                    if (lang === "go") return "map[string]interface{}";
                    if (lang === "typescript") return "Record<string, any>";
                    if (lang === "java") return "Map<String, Object>";
                    if (lang === "kotlin") return "Map<String, Any?>";
                    if (lang === "rust") return "HashMap<String, serde_json::Value>";
                    if (lang === "python") return "Dict[str, Any]";
                } else {
                    if (lang === "go") return "struct";
                    if (lang === "typescript") return "any";
                    if (lang === "java") return "Object";
                    if (lang === "kotlin") return "Any?";
                    if (lang === "rust") return "serde_json::Value";
                    if (lang === "python") return "dict";
                }
            }

            switch (typeof value) {
                case "number":
                    if (Number.isInteger(value)) {
                        if (value > 2147483647 || value < -2147483648) {
                            if (lang === "go") return "int64";
                            if (lang === "java") return "Long";
                            if (lang === "kotlin") return "Long";
                            if (lang === "rust") return "i64";
                        } else {
                            if (lang === "go") return "int";
                            if (lang === "typescript") return "number";
                            if (lang === "java") return "Integer";
                            if (lang === "kotlin") return "Int";
                            if (lang === "rust") return "i32";
                            if (lang === "python") return "int";
                        }
                    } else {
                        if (lang === "go") return "float64";
                        if (lang === "typescript") return "number";
                        if (lang === "java") return "Double";
                        if (lang === "kotlin") return "Double";
                        if (lang === "rust") return "f64";
                        if (lang === "python") return "float";
                    }
                    break;
                case "string":
                    if (lang === "go") return "string";
                    if (lang === "typescript") return "string";
                    if (lang === "java") return "String";
                    if (lang === "kotlin") return "String";
                    if (lang === "rust") return "String";
                    if (lang === "python") return "str";
                    break;
                case "boolean":
                    if (lang === "go") return "bool";
                    if (lang === "typescript") return "boolean";
                    if (lang === "java") return "Boolean";
                    if (lang === "kotlin") return "Boolean";
                    if (lang === "rust") return "bool";
                    if (lang === "python") return "bool";
                    break;
            }

            return "any";
        }

        // 生成Go代码
        function genGo(obj, name, tags, inlineStruct, detectTime, comments, formatName) {
            let allStructs = {};
            let mainStructCode = "";

            mainStructCode = genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs, 0, comments, formatName);

            let code = "";

            if (comments && comments.fieldComments[name]) {
                code += `// ${comments.fieldComments[name]}\n`;
            }

            let hasTimeField = false;
            const checkTimeField = (obj) => {
                for (const [key, value] of Object.entries(obj)) {
                    if (detectTime && isTimeField(key, value)) {
                        return true;
                    }
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        if (checkTimeField(value)) return true;
                    } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        if (checkTimeField(value[0])) return true;
                    }
                }
                return false;
            };
            hasTimeField = checkTimeField(obj);

            if (hasTimeField) {
                code = "import \"time\"\n\n" + code;
            }

            if (!inlineStruct) {
                for (const [structName, structCode] of Object.entries(allStructs)) {
                    if (structName !== name) {
                        code += structCode + "\n\n";
                    }
                }
            }

            code += mainStructCode;

            return code;
        }

        // 修复的genGoStruct函数，正确处理多维数组和深度合并
        function genGoStruct(obj, name, tags, inlineStruct, detectTime, allStructs = {}, depth = 0, comments, formatName, path = '') {
            if (depth > 20) {
                return `type ${name} struct {\n  // 嵌套深度过大，建议简化JSON结构\n  Data map[string]interface{} \`json:"data"\`\n}`;
            }

            let code = `type ${name} struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);

                const comment = comments ? comments.fieldComments[key] : null;
                if (comment) {
                    code += `  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }
                if (tags.gorm) {
                    tagParts.push(`gorm:"column:${key}"`);
                }
                if (tags.yaml) {
                    tagParts.push(`yaml:"${key}"`);
                }
                if (tags.xml) {
                    tagParts.push(`xml:"${key}"`);
                }
                if (tags.validate) {
                    const validateRules = [];
                    if (typeof value === "string") {
                        if (value.includes("@")) validateRules.push("email");
                        if (key.toLowerCase().includes("url")) validateRules.push("url");
                    }
                    if (typeof value === "number") validateRules.push("numeric");
                    if (validateRules.length > 0) {
                        tagParts.push(`validate:"${validateRules.join(",")}"`);
                    }
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null) {
                    if (Array.isArray(value)) {
                        // 处理数组类型
                        if (value.length === 0) {
                            code += `  ${fieldName} []interface{}${tagStr}\n`;
                        } else {
                            const firstItem = value[0];

                            // 处理多维数组
                            if (Array.isArray(firstItem)) {
                                // 多维数组中的元素可能是对象
                                const nestedItem = firstItem[0] || {};
                                if (typeof nestedItem === 'object' && nestedItem !== null && Object.keys(nestedItem).length > 0) {
                                    const itemTypeName = formatName(key, true) + 'Item';
                                    if (!allStructs[itemTypeName]) {
                                        // 递归生成嵌套结构体
                                        allStructs[itemTypeName] = genGoStruct(nestedItem, itemTypeName, tags, false, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                    code += `  ${fieldName} [][]${itemTypeName}${tagStr}\n`;
                                } else {
                                    // 多维基本类型数组
                                    const itemType = inferType(nestedItem, "go", key, detectTime, currentPath);
                                    code += `  ${fieldName} [][]${itemType}${tagStr}\n`;
                                }
                            } else if (typeof firstItem === "object" && firstItem !== null) {
                                // 对象数组
                                const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);

                                if (inlineStruct) {
                                    code += `  ${fieldName} []${genGoInlineStruct(firstItem, itemTypeName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                                } else {
                                    code += `  ${fieldName} []${itemTypeName}${tagStr}\n`;

                                    if (!allStructs[itemTypeName]) {
                                        allStructs[itemTypeName] = genGoStruct(firstItem, itemTypeName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                                    }
                                }
                            } else {
                                // 基本类型数组
                                const itemType = inferType(firstItem, "go", key, detectTime, currentPath);
                                code += `  ${fieldName} []${itemType}${tagStr}\n`;
                            }
                        }
                    } else {
                        // 对象类型
                        const nestedStructName = formatName(key, true);

                        if (Object.keys(value).length === 0) {
                            code += `  ${fieldName} map[string]interface{}${tagStr}\n`;
                        } else if (inlineStruct) {
                            code += `  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                        } else {
                            code += `  ${fieldName} ${nestedStructName}${tagStr}\n`;

                            if (!allStructs[nestedStructName]) {
                                allStructs[nestedStructName] = genGoStruct(value, nestedStructName, tags, inlineStruct, detectTime, allStructs, depth + 1, comments, formatName, currentPath);
                            }
                        }
                    }
                } else {
                    // 基本类型
                    code += `  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += "}";

            if (!allStructs[name]) {
                allStructs[name] = code;
            }

            return code;
        }

        function genGoInlineStruct(obj, name, tags, detectTime, depth, comments, formatName, path) {
            let indent = "  ".repeat(depth);
            let code = `${indent}struct {\n`;

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                let fieldType = inferType(value, "go", key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    code += `${indent}  // ${comment}\n`;
                }

                let tagParts = [];
                if (tags.json) {
                    tagParts.push(`json:"${key}${tags.omitempty ? ",omitempty" : ""}"`);
                }
                if (tags.mapstructure) {
                    tagParts.push(`mapstructure:"${key}"`);
                }

                const tagStr = tagParts.length > 0 ? ` \`${tagParts.join(" ")}\`` : "";

                if (typeof value === "object" && value !== null && !Array.isArray(value)) {
                    const nestedStructName = formatName(key, true);
                    code += `${indent}  ${fieldName} ${genGoInlineStruct(value, nestedStructName, tags, detectTime, depth + 1, comments, formatName, currentPath)}${tagStr}\n`;
                } else if (Array.isArray(value) && value.length > 0 && typeof value[0] === "object") {
                    const itemTypeName = formatName(key.endsWith('s') ? key.slice(0, -1) : key + 'Item', true);
                    code += `${indent}  ${fieldName} []${itemTypeName}${tagStr}\n`;
                } else {
                    code += `${indent}  ${fieldName} ${fieldType}${tagStr}\n`;
                }
            }

            code += `${indent}}`;
            return code;
        }

        function genTypeScript(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "typescript", inlineStruct, detectTime, comments, formatName);
        }

        function genJava(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "java", inlineStruct, detectTime, comments, formatName);
        }

        function genPython(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "python", inlineStruct, detectTime, comments, formatName);
        }

        function genKotlin(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "kotlin", inlineStruct, detectTime, comments, formatName);
        }

        function genRust(obj, name, inlineStruct, detectTime, comments, formatName) {
            return generateGenericCode(obj, name, "rust", inlineStruct, detectTime, comments, formatName);
        }

        function generateGenericCode(obj, name, lang, inlineStruct, detectTime, comments, formatName, depth = 0, path = '') {
            if (depth > 10) {
                return `// 结构嵌套过深，建议简化JSON\n// ${name} 类型定义`;
            }

            let code = '';

            switch(lang) {
                case 'typescript':
                    code = `interface ${name} {\n`;
                    break;
                case 'java':
                    code = `public class ${name} {\n`;
                    break;
                case 'python':
                    code = `class ${name}:\n`;
                    break;
                case 'kotlin':
                    code = `data class ${name}(\n`;
                    break;
                case 'rust':
                    code = `pub struct ${name} {\n`;
                    break;
            }

            const indent = lang === 'python' ? '    ' : '  ';

            for (const [key, value] of Object.entries(obj)) {
                const fieldName = formatName(key, false);
                const currentPath = path ? `${path}.${key}` : key;
                const fieldType = inferType(value, lang, key, detectTime, currentPath);
                const comment = comments ? comments.fieldComments[key] : null;

                if (comment) {
                    switch(lang) {
                        case 'typescript':
                        case 'java':
                        case 'kotlin':
                        case 'rust':
                            code += `${indent}// ${comment}\n`;
                            break;
                        case 'python':
                            code += `${indent}# ${comment}\n`;
                            break;
                    }
                }

                switch(lang) {
                    case 'typescript':
                        code += `${indent}${fieldName}: ${fieldType};\n`;
                        break;
                    case 'java':
                        code += `${indent}private ${fieldType} ${fieldName};\n`;
                        break;
                    case 'python':
                        code += `${indent}${fieldName}: ${fieldType}\n`;
                        break;
                    case 'kotlin':
                        code += `${indent}val ${fieldName}: ${fieldType},\n`;
                        break;
                    case 'rust':
                        code += `${indent}pub ${fieldName}: ${fieldType},\n`;
                        break;
                }
            }

            switch(lang) {
                case 'typescript':
                    code += '}';
                    break;
                case 'java':
                    code += '}';
                    break;
                case 'python':
                    break;
                case 'kotlin':
                    code = code.slice(0, -2) + '\n)';
                    break;
                case 'rust':
                    code = code.slice(0, -2) + '\n}';
                    break;
            }

            return code;
        }

        // 渲染应用
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    });
</script>
</body>
</html>
